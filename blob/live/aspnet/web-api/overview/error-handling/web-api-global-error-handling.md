---
uid: web-api/overview/error-handling/web-api-global-error-handling
title: "Globální zpracování chyb v rozhraní ASP.NET Web API 2 | Microsoft Docs"
author: davidmatson
description: 
ms.author: aspnetcontent
manager: wpickett
ms.date: 02/03/2014
ms.topic: article
ms.assetid: bffd7863-f63b-4b23-a13c-372b5492e9fb
ms.technology: dotnet-webapi
ms.prod: .net-framework
msc.legacyurl: /web-api/overview/error-handling/web-api-global-error-handling
msc.type: authoredcontent
ms.openlocfilehash: d2bdf04b4da2a099f3a2af100b16682c68f946f2
ms.sourcegitcommit: 9a9483aceb34591c97451997036a9120c3fe2baf
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 11/10/2017
---
<a name="global-error-handling-in-aspnet-web-api-2"></a><span data-ttu-id="5823e-102">Globální zpracování chyb v rozhraní ASP.NET Web API 2</span><span class="sxs-lookup"><span data-stu-id="5823e-102">Global Error Handling in ASP.NET Web API 2</span></span>
====================
<span data-ttu-id="5823e-103">podle [David Matson](https://github.com/davidmatson), [Rick Anderson](https://github.com/Rick-Anderson)</span><span class="sxs-lookup"><span data-stu-id="5823e-103">by [David Matson](https://github.com/davidmatson), [Rick Anderson](https://github.com/Rick-Anderson)</span></span>

<span data-ttu-id="5823e-104">V rozhraní Web API protokolu nebo zpracovávat chyby globálně dnes neexistuje žádný snadný způsob.</span><span class="sxs-lookup"><span data-stu-id="5823e-104">Today there's no easy way in Web API to log or handle errors globally.</span></span> <span data-ttu-id="5823e-105">Některé neošetřené výjimky může zpracovat prostřednictvím [filtry výjimek](exception-handling.md), ale existuje několik případů, které nelze zpracovat filtry výjimek.</span><span class="sxs-lookup"><span data-stu-id="5823e-105">Some unhandled exceptions can be processed via [exception filters](exception-handling.md), but there are a number of cases that exception filters can't handle.</span></span> <span data-ttu-id="5823e-106">Příklad:</span><span class="sxs-lookup"><span data-stu-id="5823e-106">For example:</span></span>

1. <span data-ttu-id="5823e-107">Výjimky vydané z konstruktorů řadiče.</span><span class="sxs-lookup"><span data-stu-id="5823e-107">Exceptions thrown from controller constructors.</span></span>
2. <span data-ttu-id="5823e-108">Výjimek vyvolaných z obslužné rutiny zpráv.</span><span class="sxs-lookup"><span data-stu-id="5823e-108">Exceptions thrown from message handlers.</span></span>
3. <span data-ttu-id="5823e-109">Výjimky vydané během trasování.</span><span class="sxs-lookup"><span data-stu-id="5823e-109">Exceptions thrown during routing.</span></span>
4. <span data-ttu-id="5823e-110">Výjimky vydané během serializace obsahu odpovědi.</span><span class="sxs-lookup"><span data-stu-id="5823e-110">Exceptions thrown during response content serialization .</span></span>

<span data-ttu-id="5823e-111">Chceme jednoduchý a konzistentní způsob zpracování (kde je to možné) a přihlaste se tyto výjimky.</span><span class="sxs-lookup"><span data-stu-id="5823e-111">We want to provide a simple, consistent way to log and handle (where possible) these exceptions.</span></span> 

<span data-ttu-id="5823e-112">Existují dvě hlavní případy pro zpracování výjimek, v případě, že jsme se moct posílat chybnou odpověď a protokolu výjimka je případ, kdy všechny můžeme dělat.</span><span class="sxs-lookup"><span data-stu-id="5823e-112">There are two major cases for handling exceptions, the case where we are able to send an error response and the case where all we can do is log the exception.</span></span> <span data-ttu-id="5823e-113">Příklad pro druhém případě je, když je vyvolána výjimka uprostřed streamování obsahu odpovědi; v takovém případě je příliš pozdě odesílat novou zprávu odpovědi, protože stavový kód, hlavičky a Částečný obsah již šly přes přenosu, takže jsme jednoduše přerušit připojení.</span><span class="sxs-lookup"><span data-stu-id="5823e-113">An example for the latter case is when an exception is thrown in the middle of streaming response content; in that case it is too late to send a new response message since the status code, headers, and partial content have already gone across the wire, so we simply abort the connection.</span></span> <span data-ttu-id="5823e-114">I když nelze zpracovat výjimku, k vytvoření nové zprávy odpovědi, stále podporu protokolování výjimky.</span><span class="sxs-lookup"><span data-stu-id="5823e-114">Even though the exception can't be handled to produce a new response message, we still support logging the exception.</span></span> <span data-ttu-id="5823e-115">V případech, kde jsme může rozpoznat chybu jsme vrátí odpověď příslušná chybová, jak je znázorněno v následující:</span><span class="sxs-lookup"><span data-stu-id="5823e-115">In cases where we can detect an error, we can return an appropriate error response as shown in the following:</span></span>

[!code-csharp[Main](web-api-global-error-handling/samples/sample1.cs?highlight=6)]

### <a name="existing-options"></a><span data-ttu-id="5823e-116">Stávající možnosti</span><span class="sxs-lookup"><span data-stu-id="5823e-116">Existing Options</span></span>

<span data-ttu-id="5823e-117">Kromě [filtry výjimek](exception-handling.md), [obslužné rutiny zpráv](../advanced/http-message-handlers.md) umožňuje dnes sledovat všechny odpovědi na úrovni 500, ale funguje na tyto odpovědi je obtížné, protože nemají kontextu o původní chybě.</span><span class="sxs-lookup"><span data-stu-id="5823e-117">In addition to [exception filters](exception-handling.md), [message handlers](../advanced/http-message-handlers.md) can be used today to observe all 500-level responses, but acting on those responses is difficult, as they lack context about the original error.</span></span> <span data-ttu-id="5823e-118">Obslužné rutiny zpráv mít také některé stejná omezení jako filtry výjimek týkající se případy, které se může zpracovat. Během webového rozhraní API nemá infrastruktury trasování, které zaznamenává chybové stavy infrastruktury trasování je pro účely diagnostiky a není určená nebo vhodné pro spuštění v produkčním prostředí.</span><span class="sxs-lookup"><span data-stu-id="5823e-118">Message handlers also have some of the same limitations as exception filters regarding the cases they can handle.While Web API does have tracing infrastructure that captures error conditions the tracing infrastructure is for diagnostics purposes and is not designed or suited for running in production environments.</span></span> <span data-ttu-id="5823e-119">Globální zpracování výjimek a protokolování by měla být služby, které můžete spustit během výroby a zapojené do stávajících řešení pro monitorování (například [ELMAH](https://code.google.com/p/elmah/) ).</span><span class="sxs-lookup"><span data-stu-id="5823e-119">Global exception handling and logging should be services that can run during production and be plugged into existing monitoring solutions (for example, [ELMAH](https://code.google.com/p/elmah/) ).</span></span>

### <a name="solution-overview"></a><span data-ttu-id="5823e-120">Přehled řešení</span><span class="sxs-lookup"><span data-stu-id="5823e-120">Solution Overview</span></span>

 <span data-ttu-id="5823e-121">Poskytujeme dva nové výměnná uživatele služby, [IExceptionLogger](../releases/whats-new-in-aspnet-web-api-21.md) a IExceptionHandler, protokolování a zpracování neošetřených výjimek.</span><span class="sxs-lookup"><span data-stu-id="5823e-121">We provide two new user-replaceable services, [IExceptionLogger](../releases/whats-new-in-aspnet-web-api-21.md) and IExceptionHandler, to log and handle unhandled exceptions.</span></span> <span data-ttu-id="5823e-122">Služby jsou velmi podobné, s dva hlavní rozdíly:</span><span class="sxs-lookup"><span data-stu-id="5823e-122">The services are very similar, with two main differences:</span></span>

1. <span data-ttu-id="5823e-123">Podporujeme registrace protokolovačů více výjimek, ale jenom jeden výjimka obslužná rutina.</span><span class="sxs-lookup"><span data-stu-id="5823e-123">We support registering multiple exception loggers but only a single exception handler.</span></span>
2. <span data-ttu-id="5823e-124">Protokolovačů výjimek vždy zavolána, i když jsme se chystáte přerušit připojení.</span><span class="sxs-lookup"><span data-stu-id="5823e-124">Exception loggers always get called, even if we're about to abort the connection.</span></span> <span data-ttu-id="5823e-125">Obslužné rutiny výjimek získat volat jenom když jsme stále moci vybrat které zpráva odpověď k odeslání.</span><span class="sxs-lookup"><span data-stu-id="5823e-125">Exception handlers only get called when we're still able to choose which response message to send.</span></span>

<span data-ttu-id="5823e-126">Obě služby poskytovat přístup k kontext výjimky obsahující příslušné informace z bodu, kde byla zjištěna výjimka, zejména v [HttpRequestMessage](https://msdn.microsoft.com/en-us/library/system.net.http.httprequestmessage(v=vs.110).aspx), [HttpRequestContext](https://msdn.microsoft.com/en-us/library/system.web.http.controllers.httprequestcontext(v=vs.118).aspx), vyvolána výjimka a zdroji výjimky (níže uvedené podrobnosti).</span><span class="sxs-lookup"><span data-stu-id="5823e-126">Both services provide access to an exception context containing relevant information from the point where the exception was detected, particularly the [HttpRequestMessage](https://msdn.microsoft.com/en-us/library/system.net.http.httprequestmessage(v=vs.110).aspx), the [HttpRequestContext](https://msdn.microsoft.com/en-us/library/system.web.http.controllers.httprequestcontext(v=vs.118).aspx), the thrown exception and the exception source (details below).</span></span>

### <a name="design-principles"></a><span data-ttu-id="5823e-127">Principy návrhu</span><span class="sxs-lookup"><span data-stu-id="5823e-127">Design Principles</span></span>

1. <span data-ttu-id="5823e-128">**Žádné dodatečné změny** vzhledem k tomu, že tato funkce je přidáván v vedlejší verzi, ten je důležité omezení, které mají vliv na řešení, který existovat žádné nejnovější změny, buď na typ kontrakty nebo chování.</span><span class="sxs-lookup"><span data-stu-id="5823e-128">**No breaking changes** Because this functionality is being added in a minor release, one important constraint impacting the solution is that there be no breaking changes, either to type contracts or to behavior.</span></span> <span data-ttu-id="5823e-129">Toto omezení vyloučit některé čištění, kterou jsme chtěli hotové z hlediska existující bloků catch vypnutí výjimky do odpovědi 500.</span><span class="sxs-lookup"><span data-stu-id="5823e-129">This constraint ruled out some cleanup we would like to have done in terms of existing catch blocks turning exceptions into 500 responses.</span></span> <span data-ttu-id="5823e-130">Tato další čištění je něco, co jsme zvažte pro následné hlavní verze.</span><span class="sxs-lookup"><span data-stu-id="5823e-130">This additional cleanup is something we might consider for a subsequent major release.</span></span> <span data-ttu-id="5823e-131">Pokud to je důležité si prosím hlasovat o v [hlasové uživatelské rozhraní ASP.NET Web API](http://aspnet.uservoice.com/forums/147201-asp-net-web-api/suggestions/5451321-add-flag-to-enable-iexceptionlogger-and-iexception).</span><span class="sxs-lookup"><span data-stu-id="5823e-131">If this is important to you please vote on it at [ASP.NET Web API user voice](http://aspnet.uservoice.com/forums/147201-asp-net-web-api/suggestions/5451321-add-flag-to-enable-iexceptionlogger-and-iexception).</span></span>
2. <span data-ttu-id="5823e-132">**Zachování konzistence s webového rozhraní API vytvoří** kanál rozhraní Web API filtru je skvělým způsobem, jak zpracovat mezi vyjímání obavy pružně použití logiku v určité akci, specifické pro řadič ani globální obor.</span><span class="sxs-lookup"><span data-stu-id="5823e-132">**Maintaining consistency with Web API constructs** Web API's filter pipeline is a great way to handle cross-cutting concerns with the flexibility of applying the logic at an action-specific, controller-specific or global scope.</span></span> <span data-ttu-id="5823e-133">Filtry, včetně filtry výjimek, akce a kontroler kontextů, mít vždy, i v případě, že je zaregistrován v globálním oboru.</span><span class="sxs-lookup"><span data-stu-id="5823e-133">Filters, including exception filters, always have action and controller contexts, even when registered at the global scope.</span></span> <span data-ttu-id="5823e-134">Kontrakt smysl pro filtry, ale znamená, že filtry výjimek, i globálně vymezená ty nejsou vhodné pro zpracování případech, například výjimky z obslužné rutiny zpráv, kde žádný kontext akce nebo kontroleru některé výjimek existuje.</span><span class="sxs-lookup"><span data-stu-id="5823e-134">That contract makes sense for filters, but it means that exception filters, even globally scoped ones, aren't a good fit for some exception handling cases, such as exceptions from message handlers, where no action or controller context exists.</span></span> <span data-ttu-id="5823e-135">Pokud nám chcete použít, flexibilní zaměření poskytované filtry výjimek, potřebujeme ještě filtry výjimek.</span><span class="sxs-lookup"><span data-stu-id="5823e-135">If we want to use the flexible scoping afforded by filters for exception handling, we still need exception filters.</span></span> <span data-ttu-id="5823e-136">Ale pokud je zapotřebí zpracovat výjimka mimo kontext kontroleru, potřebujeme také samostatné konstrukce úplné globální při zpracování chyb (něco bez řadiče kontextu a akce kontextu omezení).</span><span class="sxs-lookup"><span data-stu-id="5823e-136">But if we need to handle exception outside of a controller context, we also need a separate construct for full global error handling (something without the controller context and action context constraints).</span></span>

### <a name="when-to-use"></a><span data-ttu-id="5823e-137">Kdy použít</span><span class="sxs-lookup"><span data-stu-id="5823e-137">When to Use</span></span>

- <span data-ttu-id="5823e-138">Protokolovací nástroje výjimky jsou řešení zobrazuje všechny nezpracované výjimce zachytila webového rozhraní API.</span><span class="sxs-lookup"><span data-stu-id="5823e-138">Exception loggers are the solution to seeing all unhandled exception caught by Web API.</span></span>
- <span data-ttu-id="5823e-139">Obslužné rutiny výjimek jsou řešení pro přizpůsobení všechny možné odpovědí neošetřených výjimek zachytila webového rozhraní API.</span><span class="sxs-lookup"><span data-stu-id="5823e-139">Exception handlers are the solution for customizing all possible responses to unhandled exceptions caught by Web API.</span></span>
- <span data-ttu-id="5823e-140">Filtry výjimek jsou Nejsnazším řešením pro zpracování podmnožina neošetřené výjimky související s konkrétní akce nebo kontroleru.</span><span class="sxs-lookup"><span data-stu-id="5823e-140">Exception filters are the easiest solution for processing the subset unhandled exceptions related to a specific action or controller.</span></span>

### <a name="service-details"></a><span data-ttu-id="5823e-141">Podrobnosti služby</span><span class="sxs-lookup"><span data-stu-id="5823e-141">Service Details</span></span>

 <span data-ttu-id="5823e-142">Rozhraní služby protokolovače a obslužné rutiny výjimky jsou jednoduché asynchronní metody trvá příslušných kontexty:</span><span class="sxs-lookup"><span data-stu-id="5823e-142">The exception logger and handler service interfaces are simple async methods taking the respective contexts:</span></span> 

[!code-csharp[Main](web-api-global-error-handling/samples/sample2.cs)]

 <span data-ttu-id="5823e-143">Poskytujeme také základní třídy pro obě tato rozhraní.</span><span class="sxs-lookup"><span data-stu-id="5823e-143">We also provide base classes for both of these interfaces.</span></span> <span data-ttu-id="5823e-144">Přepsání metody jádra (synchronizace nebo asynchronní) je všechno, co je potřeba protokolu nebo zpracování na doporučené časy.</span><span class="sxs-lookup"><span data-stu-id="5823e-144">Overriding the core (sync or async) methods is all that is required to log or handle at the recommended times.</span></span> <span data-ttu-id="5823e-145">Pro protokolování `ExceptionLogger` základní třída zajistí, že základní protokolování se zavolá tato metoda pouze jednou pro každou výjimce (i v případě, že později rozšíří další až zásobník volání a znovu zasekne).</span><span class="sxs-lookup"><span data-stu-id="5823e-145">For logging, the `ExceptionLogger` base class will ensure that the core logging method is only called once for each exception (even if it later propagates further up the call stack and is caught again).</span></span> <span data-ttu-id="5823e-146">`ExceptionHandler` Základní třídu bude volat základní metodu zpracování pouze pro výjimky v horní části zásobníku volání, ignoruje starší vnořené bloky catch.</span><span class="sxs-lookup"><span data-stu-id="5823e-146">The `ExceptionHandler` base class will call the core handling method only for exceptions at the top of the call stack, ignoring legacy nested catch blocks.</span></span> <span data-ttu-id="5823e-147">(Zjednodušená verzích tyto základní třídy jsou v příloze níže). Obě `IExceptionLogger` a `IExceptionHandler` získat informace o výjimce prostřednictvím `ExceptionContext`.</span><span class="sxs-lookup"><span data-stu-id="5823e-147">(Simplified versions of these base classes are in the appendix below.) Both `IExceptionLogger` and `IExceptionHandler` receive information about the exception via an `ExceptionContext`.</span></span>

[!code-csharp[Main](web-api-global-error-handling/samples/sample3.cs)]

<span data-ttu-id="5823e-148">Když architektura volá protokolovač výjimek nebo obslužné rutiny výjimek, bude vždy poskytovat `Exception` a `Request`.</span><span class="sxs-lookup"><span data-stu-id="5823e-148">When the framework calls an exception logger or an exception handler, it will always provide an `Exception` and a `Request`.</span></span> <span data-ttu-id="5823e-149">Výjimkou je testování částí, bude také vždy poskytovat `RequestContext`.</span><span class="sxs-lookup"><span data-stu-id="5823e-149">Except for unit testing, it will also always provide a `RequestContext`.</span></span> <span data-ttu-id="5823e-150">Občas bude poskytovat `ControllerContext` a `ActionContext` (jen při volání z bloku catch pro filtry výjimek).</span><span class="sxs-lookup"><span data-stu-id="5823e-150">It will rarely provide a `ControllerContext` and `ActionContext` (only when calling from the catch block for exception filters).</span></span> <span data-ttu-id="5823e-151">Poskytne velmi zřídka `Response`(pouze v určitých případech IIS při uprostřed pokusu o zápis odpověď).</span><span class="sxs-lookup"><span data-stu-id="5823e-151">It will very rarely provide a `Response`(only in certain IIS cases when in the middle of trying to write the response).</span></span> <span data-ttu-id="5823e-152">Všimněte si, že vzhledem k tomu, že některé z těchto vlastností může být `null` je až příjemce zkontrolujte `null` před přístup ke členům třídy výjimek.`CatchBlock`</span><span class="sxs-lookup"><span data-stu-id="5823e-152">Note that because some of these properties may be `null` it is up to the consumer to check for `null` before accessing members of the exception class.`CatchBlock`</span></span> <span data-ttu-id="5823e-153">je řetězec označující, které blok catch viděli výjimku.</span><span class="sxs-lookup"><span data-stu-id="5823e-153">is a string indicating which catch block saw the exception.</span></span> <span data-ttu-id="5823e-154">Řetězce bloku catch jsou následující:</span><span class="sxs-lookup"><span data-stu-id="5823e-154">The catch block strings are as follows:</span></span>

- <span data-ttu-id="5823e-155">HttpServer (SendAsync metoda)</span><span class="sxs-lookup"><span data-stu-id="5823e-155">HttpServer (SendAsync method)</span></span>
- <span data-ttu-id="5823e-156">HttpControllerDispatcher (SendAsync metoda)</span><span class="sxs-lookup"><span data-stu-id="5823e-156">HttpControllerDispatcher (SendAsync method)</span></span>
- <span data-ttu-id="5823e-157">HttpBatchHandler (SendAsync metoda)</span><span class="sxs-lookup"><span data-stu-id="5823e-157">HttpBatchHandler (SendAsync method)</span></span>
- <span data-ttu-id="5823e-158">IExceptionFilter (objektu ApiController na zpracování kanálu filtru výjimek v ExecuteAsync)</span><span class="sxs-lookup"><span data-stu-id="5823e-158">IExceptionFilter (ApiController's processing of the exception filter pipeline in ExecuteAsync)</span></span>
- <span data-ttu-id="5823e-159">OWIN hostitele:</span><span class="sxs-lookup"><span data-stu-id="5823e-159">OWIN host:</span></span>

    - <span data-ttu-id="5823e-160">HttpMessageHandlerAdapter.BufferResponseContentAsync (pro ukládání výstupu do vyrovnávací paměti)</span><span class="sxs-lookup"><span data-stu-id="5823e-160">HttpMessageHandlerAdapter.BufferResponseContentAsync (for buffering output)</span></span>
    - <span data-ttu-id="5823e-161">HttpMessageHandlerAdapter.CopyResponseContentAsync (pro streaming výstup)</span><span class="sxs-lookup"><span data-stu-id="5823e-161">HttpMessageHandlerAdapter.CopyResponseContentAsync (for streaming output)</span></span>
- <span data-ttu-id="5823e-162">Webového hostitele:</span><span class="sxs-lookup"><span data-stu-id="5823e-162">Web host:</span></span>

    - <span data-ttu-id="5823e-163">HttpControllerHandler.WriteBufferedResponseContentAsync (pro ukládání výstupu do vyrovnávací paměti)</span><span class="sxs-lookup"><span data-stu-id="5823e-163">HttpControllerHandler.WriteBufferedResponseContentAsync (for buffering output)</span></span>
    - <span data-ttu-id="5823e-164">HttpControllerHandler.WriteStreamedResponseContentAsync (pro streaming výstup)</span><span class="sxs-lookup"><span data-stu-id="5823e-164">HttpControllerHandler.WriteStreamedResponseContentAsync (for streaming output)</span></span>
    - <span data-ttu-id="5823e-165">HttpControllerHandler.WriteErrorResponseContentAsync (pro selhání v zotavení z chyb v režimu výstup do vyrovnávací paměti)</span><span class="sxs-lookup"><span data-stu-id="5823e-165">HttpControllerHandler.WriteErrorResponseContentAsync (for failures in error recovery under buffered output mode)</span></span>

<span data-ttu-id="5823e-166">Seznam řetězců bloku catch je také k dispozici prostřednictvím vlastnosti statické jen pro čtení.</span><span class="sxs-lookup"><span data-stu-id="5823e-166">The list of catch block strings is also available via static readonly properties.</span></span> <span data-ttu-id="5823e-167">(Řetězec bloku catch základní jsou na statické ExceptionCatchBlocks; zbytek zobrazí na jednu statickou třídu každý pro OWIN a webového hostitele).`IsTopLevelCatchBlock`</span><span class="sxs-lookup"><span data-stu-id="5823e-167">(The core catch block string are on the static ExceptionCatchBlocks; the remainder appear on one static class each for OWIN and web host).`IsTopLevelCatchBlock`</span></span> <span data-ttu-id="5823e-168">je užitečné pro následující doporučené vzor zpracování výjimek pouze v horní části zásobníku volání.</span><span class="sxs-lookup"><span data-stu-id="5823e-168">is helpful for following the recommended pattern of handling exceptions only at the top of the call stack.</span></span> <span data-ttu-id="5823e-169">Místo vypnutí výjimky do 500 odpovědi, všude, kde dochází vnořený blok catch, obslužné rutiny výjimek nechat výjimky rozšířit až o do vidět hostitele.</span><span class="sxs-lookup"><span data-stu-id="5823e-169">Rather than turning exceptions into 500 responses anywhere a nested catch block occurs, an exception handler can let exceptions propagate until they are about to be seen by the host.</span></span>

<span data-ttu-id="5823e-170">Kromě `ExceptionContext`, protokoly získá jednu další část informací prostřednictvím kompletní `ExceptionLoggerContext`:</span><span class="sxs-lookup"><span data-stu-id="5823e-170">In addition to the `ExceptionContext`, a logger gets one more piece of information via the full `ExceptionLoggerContext`:</span></span>

[!code-csharp[Main](web-api-global-error-handling/samples/sample4.cs)]

<span data-ttu-id="5823e-171">Druhou vlastností `CanBeHandled`, umožňuje protokolovacího nástroje k identifikaci výjimka, která nelze zpracovat.</span><span class="sxs-lookup"><span data-stu-id="5823e-171">The second property, `CanBeHandled`, allows a logger to identify an exception that cannot be handled.</span></span> <span data-ttu-id="5823e-172">Při připojení je přerušena a nelze odesílat žádné nové zprávy odpovědi, nezavolá se protokolovacích nástrojů ale obslužná rutina se ***není*** volat, a protokolovacích nástrojů můžete identifikovat tento scénář z této vlastnosti.</span><span class="sxs-lookup"><span data-stu-id="5823e-172">When the connection is about to be aborted and no new response message can be sent, the loggers will be called but the handler will ***not*** be called, and the loggers can identify this scenario from this property.</span></span>

<span data-ttu-id="5823e-173">V další `ExceptionContext`, obslužná rutina získá jeden další vlastnost můžete nastavit na celý `ExceptionHandlerContext` účelem ošetření výjimky:</span><span class="sxs-lookup"><span data-stu-id="5823e-173">In additional to the `ExceptionContext`, a handler gets one more property it can set on the full `ExceptionHandlerContext` to handle the exception:</span></span>

[!code-csharp[Main](web-api-global-error-handling/samples/sample5.cs)]

<span data-ttu-id="5823e-174">Obslužné rutiny výjimek označuje, že se má výjimka ošetřena nastavením `Result` vlastnost na výsledek akce (například [ExceptionResult](https://msdn.microsoft.com/en-us/library/system.web.http.results.exceptionresult(v=vs.118).aspx), [InternalServerErrorResult](https://msdn.microsoft.com/en-us/library/system.web.http.results.internalservererrorresult(v=vs.118).aspx), [ StatusCodeResult](https://msdn.microsoft.com/en-us/library/system.web.http.results.statuscoderesult(v=vs.118).aspx), nebo vlastní výsledek).</span><span class="sxs-lookup"><span data-stu-id="5823e-174">An exception handler indicates that it has handled an exception by setting the `Result` property to an action result (for example, an [ExceptionResult](https://msdn.microsoft.com/en-us/library/system.web.http.results.exceptionresult(v=vs.118).aspx), [InternalServerErrorResult](https://msdn.microsoft.com/en-us/library/system.web.http.results.internalservererrorresult(v=vs.118).aspx), [StatusCodeResult](https://msdn.microsoft.com/en-us/library/system.web.http.results.statuscoderesult(v=vs.118).aspx), or a custom result).</span></span> <span data-ttu-id="5823e-175">Pokud `Result` vlastnost má hodnotu null, neošetřené výjimky a původní výjimka bude znovu.</span><span class="sxs-lookup"><span data-stu-id="5823e-175">If the `Result` property is null, the exception is unhandled and the original exception will be re-thrown.</span></span>

<span data-ttu-id="5823e-176">Výjimky v horní části zásobníku volání vzali jsme krok navíc k zajištění, že odpověď je vhodný pro volající rozhraní API.</span><span class="sxs-lookup"><span data-stu-id="5823e-176">For exceptions at the top of the call stack, we took an extra step to ensure the response is appropriate for API callers.</span></span> <span data-ttu-id="5823e-177">Pokud se výjimka šíří až hostitel, volající by žlutý obrazovku smrti nebo některých jiných hostitele zadaný odpovědi, což je většinou HTML a obvykle odpovídající chybnou odpověď rozhraní API.</span><span class="sxs-lookup"><span data-stu-id="5823e-177">If the exception propagates up to the host, the caller would see the yellow screen of death or some other host provided response which is typically HTML and not usually an appropriate API error response.</span></span> <span data-ttu-id="5823e-178">V těchto případech spustí výsledek na jinou hodnotu než null a pouze v případě jeho obslužná rutina vlastní výjimky explicitně nastaví zpět na `null` (neošetřená) se výjimka šíří do hostitele.</span><span class="sxs-lookup"><span data-stu-id="5823e-178">In these cases, the Result starts out non-null, and only if a custom exception handler explicitly sets it back to `null` (unhandled) will the exception propagate to the host.</span></span> <span data-ttu-id="5823e-179">Nastavení `Result` k `null` v takových případech může být užitečná pro dva scénáře:</span><span class="sxs-lookup"><span data-stu-id="5823e-179">Setting `Result` to `null` in such cases can be useful for two scenarios:</span></span>

1. <span data-ttu-id="5823e-180">OWIN hostované webového rozhraní API s vlastní zpracování middleware zaregistrován webového rozhraní API před a vnější výjimek.</span><span class="sxs-lookup"><span data-stu-id="5823e-180">OWIN hosted Web API with custom exception handling middleware registered before/outside Web API.</span></span>
2. <span data-ttu-id="5823e-181">Místní ladění prostřednictvím prohlížeče, kde žlutý obrazovka smrti je ve skutečnosti užitečné odpovědi pro k neošetřené výjimce.</span><span class="sxs-lookup"><span data-stu-id="5823e-181">Local debugging via a browser, where the yellow screen of death is actually a helpful response for an unhandled exception.</span></span>

<span data-ttu-id="5823e-182">Pro protokolovačů výjimek a obslužné rutiny výjimek jsme nedělají nic nic k obnovení v případě protokolovacího nástroje nebo obslužná rutina, samotné vyvolá výjimku.</span><span class="sxs-lookup"><span data-stu-id="5823e-182">For both exception loggers and exception handlers, we don't do anything to recover if the logger or handler itself throws an exception.</span></span> <span data-ttu-id="5823e-183">(Než umožníte výjimka rozšířit, sdělit svůj názor v dolní části této stránky, pokud máte lepší přístup.) Kontrakt protokolovačů výjimek a obslužné rutiny je, že by neměl umožňují výjimky rozšířit až jejich volající; v opačném výjimka právě rozšíří, často zcela na hostitele, což vede k chybě ve formátu HTML (například soubor ASP. Žlutý obrazovky na NET) odesílány zpět na klientovi (a která obvykle není upřednostňovanou možnost pro volající rozhraní API, které očekávají XML nebo JSON).</span><span class="sxs-lookup"><span data-stu-id="5823e-183">(Other than letting the exception propagate, leave feedback at the bottom of this page if you have a better approach.) The contract for exception loggers and handlers is that they should not let exceptions propagate up to their callers; otherwise, the exception will just propagate, often all the way to the host resulting in an HTML error (like the ASP.NET's yellow screen) being sent back to the client (which usually isn't the preferred option for API callers that expect JSON or XML).</span></span>

## <a name="examples"></a><span data-ttu-id="5823e-184">Příklady</span><span class="sxs-lookup"><span data-stu-id="5823e-184">Examples</span></span>

### <a name="tracing-exception-logger"></a><span data-ttu-id="5823e-185">Protokolovač výjimek trasování</span><span class="sxs-lookup"><span data-stu-id="5823e-185">Tracing Exception Logger</span></span>

<span data-ttu-id="5823e-186">Níže uvedené výjimky protokoly odeslat data výjimky nakonfigurované trasování zdrojů (včetně ve výstupním okně ladění v sadě Visual Studio).</span><span class="sxs-lookup"><span data-stu-id="5823e-186">The exception logger below send exception data to configured Trace sources (including the Debug output window in Visual Studio).</span></span>

[!code-csharp[Main](web-api-global-error-handling/samples/sample6.cs)]

### <a name="custom-error-message-exception-handler"></a><span data-ttu-id="5823e-187">Obslužná rutina výjimky vlastní chybové zprávy</span><span class="sxs-lookup"><span data-stu-id="5823e-187">Custom Error Message Exception Handler</span></span>

<span data-ttu-id="5823e-188">Následující níže vytvoří vlastní chybové odpovědi pro klienty, včetně e-mailovou adresu pro kontaktování podpory.</span><span class="sxs-lookup"><span data-stu-id="5823e-188">The following below produces a custom error response to clients, including an email address for contacting support.</span></span>

[!code-csharp[Main](web-api-global-error-handling/samples/sample7.cs)]

## <a name="registering-exception-filters"></a><span data-ttu-id="5823e-189">Registrace filtry výjimek</span><span class="sxs-lookup"><span data-stu-id="5823e-189">Registering Exception Filters</span></span>

<span data-ttu-id="5823e-190">Pokud použijete k vytvoření projektu šablony projektu "ASP.NET MVC 4 webové aplikace", uveďte kódu webového rozhraní API konfigurace uvnitř `WebApiConfig` třídy v *aplikace nebo s_pustit* složky:</span><span class="sxs-lookup"><span data-stu-id="5823e-190">If you use the "ASP.NET MVC 4 Web Application" project template to create your project, put your Web API configuration code inside the `WebApiConfig` class, in the *App/_Start* folder:</span></span>

[!code-csharp[Main](exception-handling/samples/sample7.cs?highlight=5)]

## <a name="appendix-base-class-details"></a><span data-ttu-id="5823e-191">Dodatek: Základní třída podrobnosti</span><span class="sxs-lookup"><span data-stu-id="5823e-191">Appendix: Base Class Details</span></span>

[!code-csharp[Main](web-api-global-error-handling/samples/sample8.cs)]
