---
title: Hierarchie účelů a víceklientské aplikace v ASP.NET Core
author: rick-anderson
description: Seznamte se s hierarchií řetězců pro účely a víceklientské architektury, protože se týká rozhraní API ochrany ASP.NET Core dat.
ms.author: riande
ms.date: 10/14/2016
no-loc:
- ASP.NET Core Identity
- cookie
- Cookie
- Blazor
- Blazor Server
- Blazor WebAssembly
- Identity
- Let's Encrypt
- Razor
- SignalR
uid: security/data-protection/consumer-apis/purpose-strings-multitenancy
ms.openlocfilehash: 65799c10b8e810853023c094b95ccafa0d71eb8b
ms.sourcegitcommit: 65add17f74a29a647d812b04517e46cbc78258f9
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 08/19/2020
ms.locfileid: "88632080"
---
# <a name="purpose-hierarchy-and-multi-tenancy-in-aspnet-core"></a><span data-ttu-id="9e29a-103">Hierarchie účelů a víceklientské aplikace v ASP.NET Core</span><span class="sxs-lookup"><span data-stu-id="9e29a-103">Purpose hierarchy and multi-tenancy in ASP.NET Core</span></span>

<span data-ttu-id="9e29a-104">Vzhledem k `IDataProtector` tomu, že je také implicitně `IDataProtectionProvider` a účelně lze zřetězit.</span><span class="sxs-lookup"><span data-stu-id="9e29a-104">Since an `IDataProtector` is also implicitly an `IDataProtectionProvider`, purposes can be chained together.</span></span> <span data-ttu-id="9e29a-105">V tomto smyslu `provider.CreateProtector([ "purpose1", "purpose2" ])` je ekvivalentem `provider.CreateProtector("purpose1").CreateProtector("purpose2")` .</span><span class="sxs-lookup"><span data-stu-id="9e29a-105">In this sense, `provider.CreateProtector([ "purpose1", "purpose2" ])` is equivalent to `provider.CreateProtector("purpose1").CreateProtector("purpose2")`.</span></span>

<span data-ttu-id="9e29a-106">To umožňuje určitým zajímavým hierarchickým vztahům prostřednictvím systému ochrany dat.</span><span class="sxs-lookup"><span data-stu-id="9e29a-106">This allows for some interesting hierarchical relationships through the data protection system.</span></span> <span data-ttu-id="9e29a-107">V předchozím příkladu [contoso. Messaging. SecureMessage](xref:security/data-protection/consumer-apis/purpose-strings#data-protection-contoso-purpose)může komponenta SecureMessage zavolat `provider.CreateProtector("Contoso.Messaging.SecureMessage")` po frontě dopředu a uložit výsledek do soukromého `_myProvider` pole.</span><span class="sxs-lookup"><span data-stu-id="9e29a-107">In the earlier example of [Contoso.Messaging.SecureMessage](xref:security/data-protection/consumer-apis/purpose-strings#data-protection-contoso-purpose), the SecureMessage component can call `provider.CreateProtector("Contoso.Messaging.SecureMessage")` once up-front and cache the result into a private `_myProvider` field.</span></span> <span data-ttu-id="9e29a-108">Budoucí ochrana se pak dají vytvořit prostřednictvím volání a `_myProvider.CreateProtector("User: username")` Tato ochrana se použije k zabezpečení jednotlivých zpráv.</span><span class="sxs-lookup"><span data-stu-id="9e29a-108">Future protectors can then be created via calls to `_myProvider.CreateProtector("User: username")`, and these protectors would be used for securing the individual messages.</span></span>

<span data-ttu-id="9e29a-109">To lze také Překlopit.</span><span class="sxs-lookup"><span data-stu-id="9e29a-109">This can also be flipped.</span></span> <span data-ttu-id="9e29a-110">Vezměte v úvahu jednu logickou aplikaci, která hostuje více tenantů (CMS se jeví jako přiměřenou), a každý tenant se dá nakonfigurovat s vlastním systémem pro správu ověřování a stavu.</span><span class="sxs-lookup"><span data-stu-id="9e29a-110">Consider a single logical application which hosts multiple tenants (a CMS seems reasonable), and each tenant can be configured with its own authentication and state management system.</span></span> <span data-ttu-id="9e29a-111">Aplikace zastřešující má jednoho hlavního poskytovatele a volá `provider.CreateProtector("Tenant 1")` a, `provider.CreateProtector("Tenant 2")` aby každému tenantovi poskytoval svůj vlastní izolovaný řez systému ochrany dat.</span><span class="sxs-lookup"><span data-stu-id="9e29a-111">The umbrella application has a single master provider, and it calls `provider.CreateProtector("Tenant 1")` and `provider.CreateProtector("Tenant 2")` to give each tenant its own isolated slice of the data protection system.</span></span> <span data-ttu-id="9e29a-112">Klienti by pak mohli odvodit své vlastní ochrany v závislosti na svých vlastních potřebách, ale bez ohledu na to, jak je to obtížné, můžou vytvářet ochrany, které kolidují s jakýmkoli jiným klientem v systému.</span><span class="sxs-lookup"><span data-stu-id="9e29a-112">The tenants could then derive their own individual protectors based on their own needs, but no matter how hard they try they cannot create protectors which collide with any other tenant in the system.</span></span> <span data-ttu-id="9e29a-113">Graficky funguje tak, jak je znázorněno níže.</span><span class="sxs-lookup"><span data-stu-id="9e29a-113">Graphically, this is represented as below.</span></span>

![Víceklientské účely](purpose-strings-multitenancy/_static/purposes-multi-tenancy.png)

>[!WARNING]
> <span data-ttu-id="9e29a-115">To předpokládá, že aplikace zastřešující řídí, která rozhraní API jsou k dispozici pro jednotlivé klienty a že klienti nemohou spouštět libovolný kód na serveru.</span><span class="sxs-lookup"><span data-stu-id="9e29a-115">This assumes the umbrella application controls which APIs are available to individual tenants and that tenants cannot execute arbitrary code on the server.</span></span> <span data-ttu-id="9e29a-116">Pokud může tenant spustit libovolný kód, mohl by provést soukromou reflexi k přerušení záruk izolace, nebo by mohl jednoduše přečíst hlavní klíč klíče přímo a odvodit jakékoli podklíče, které si chtějí.</span><span class="sxs-lookup"><span data-stu-id="9e29a-116">If a tenant can execute arbitrary code, they could perform private reflection to break the isolation guarantees, or they could just read the master keying material directly and derive whatever subkeys they desire.</span></span>

<span data-ttu-id="9e29a-117">Systém ochrany dat ve skutečnosti používá řazení více tenantů ve výchozí předem připravené konfiguraci.</span><span class="sxs-lookup"><span data-stu-id="9e29a-117">The data protection system actually uses a sort of multi-tenancy in its default out-of-the-box configuration.</span></span> <span data-ttu-id="9e29a-118">Ve výchozím nastavení jsou hlavní materiálové klíče uložené ve složce profilu uživatele účtu pracovního procesu (nebo v registru pro identity fondu aplikací služby IIS).</span><span class="sxs-lookup"><span data-stu-id="9e29a-118">By default master keying material is stored in the worker process account's user profile folder (or the registry, for IIS application pool identities).</span></span> <span data-ttu-id="9e29a-119">V podstatě je ale poměrně běžné používat jeden účet ke spouštění více aplikací, takže všechny tyto aplikace budou mít na začátku sdílení obsahu hlavního klíče.</span><span class="sxs-lookup"><span data-stu-id="9e29a-119">But it's actually fairly common to use a single account to run multiple applications, and thus all these applications would end up sharing the master keying material.</span></span> <span data-ttu-id="9e29a-120">Pro vyřešení toho systém ochrany dat automaticky vloží identifikátor jedinečnosti podle aplikace jako první prvek v řetězci celkového účelu.</span><span class="sxs-lookup"><span data-stu-id="9e29a-120">To solve this, the data protection system automatically inserts a unique-per-application identifier as the first element in the overall purpose chain.</span></span> <span data-ttu-id="9e29a-121">Tento implicitní účel slouží k [izolaci jednotlivých aplikací](xref:security/data-protection/configuration/overview#per-application-isolation) tím, že efektivně zpracovává každou aplikaci jako jedinečného tenanta v systému a proces vytváření ochrany vypadá stejně jako obrázek výše.</span><span class="sxs-lookup"><span data-stu-id="9e29a-121">This implicit purpose serves to [isolate individual applications](xref:security/data-protection/configuration/overview#per-application-isolation) from one another by effectively treating each application as a unique tenant within the system, and the protector creation process looks identical to the image above.</span></span>
