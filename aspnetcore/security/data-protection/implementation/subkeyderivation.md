---
title: Odvození podklíče a ověřované šifrování v ASP.NET Core
author: rick-anderson
description: Přečtěte si podrobnosti o implementaci ASP.NET Core odvození podklíče ochrany dat a ověřovaného šifrování.
ms.author: riande
ms.date: 10/14/2016
no-loc:
- Blazor
- Identity
- Let's Encrypt
- Razor
- SignalR
uid: security/data-protection/implementation/subkeyderivation
ms.openlocfilehash: c4b4076d532e33b48b3438f842507a8cda2d71b6
ms.sourcegitcommit: 70e5f982c218db82aa54aa8b8d96b377cfc7283f
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 05/04/2020
ms.locfileid: "82776848"
---
# <a name="subkey-derivation-and-authenticated-encryption-in-aspnet-core"></a><span data-ttu-id="a1179-103">Odvození podklíče a ověřované šifrování v ASP.NET Core</span><span class="sxs-lookup"><span data-stu-id="a1179-103">Subkey derivation and authenticated encryption in ASP.NET Core</span></span>

<a name="data-protection-implementation-subkey-derivation"></a>

<span data-ttu-id="a1179-104">Většina klíčů ve službě Key Ring bude obsahovat určitou formu entropie a bude mít informace o algoritmech "CBC-Mode Encryption + HMAC Validation" nebo "GCM Encryption + Validation".</span><span class="sxs-lookup"><span data-stu-id="a1179-104">Most keys in the key ring will contain some form of entropy and will have algorithmic information stating "CBC-mode encryption + HMAC validation" or "GCM encryption + validation".</span></span> <span data-ttu-id="a1179-105">V těchto případech odkazujeme na vloženou entropii jako na hlavní klíč (nebo KM) pro tento klíč a k odvození klíčů, které se budou používat pro skutečné kryptografické operace, provedeme funkci odvození klíče.</span><span class="sxs-lookup"><span data-stu-id="a1179-105">In these cases, we refer to the embedded entropy as the master keying material (or KM) for this key, and we perform a key derivation function to derive the keys that will be used for the actual cryptographic operations.</span></span>

> [!NOTE]
> <span data-ttu-id="a1179-106">Klíče jsou abstraktní a vlastní implementace se nemusí chovat, jak je uvedeno níže.</span><span class="sxs-lookup"><span data-stu-id="a1179-106">Keys are abstract, and a custom implementation might not behave as below.</span></span> <span data-ttu-id="a1179-107">Pokud klíč poskytuje svou vlastní implementaci `IAuthenticatedEncryptor` namísto použití jednoho z našich vestavěných továren, mechanizmus popsaný v této části se už nepoužívá.</span><span class="sxs-lookup"><span data-stu-id="a1179-107">If the key provides its own implementation of `IAuthenticatedEncryptor` rather than using one of our built-in factories, the mechanism described in this section no longer applies.</span></span>

<a name="data-protection-implementation-subkey-derivation-aad"></a>

## <a name="additional-authenticated-data-and-subkey-derivation"></a><span data-ttu-id="a1179-108">Další ověřená data a odvození podklíčů</span><span class="sxs-lookup"><span data-stu-id="a1179-108">Additional authenticated data and subkey derivation</span></span>

<span data-ttu-id="a1179-109">`IAuthenticatedEncryptor` Rozhraní slouží jako základní rozhraní pro všechny ověřované operace šifrování.</span><span class="sxs-lookup"><span data-stu-id="a1179-109">The `IAuthenticatedEncryptor` interface serves as the core interface for all authenticated encryption operations.</span></span> <span data-ttu-id="a1179-110">Jeho `Encrypt` metoda přijímá dvě vyrovnávací paměti: prosté a ADDITIONALAUTHENTICATEDDATA (AAD).</span><span class="sxs-lookup"><span data-stu-id="a1179-110">Its `Encrypt` method takes two buffers: plaintext and additionalAuthenticatedData (AAD).</span></span> <span data-ttu-id="a1179-111">Tok obsahu ve formátu prostého textu nemění volání `IDataProtector.Protect`, ale v systému je vygenerováno AAD a skládá se ze tří součástí:</span><span class="sxs-lookup"><span data-stu-id="a1179-111">The plaintext contents flow unchanged the call to `IDataProtector.Protect`, but the AAD is generated by the system and consists of three components:</span></span>

1. <span data-ttu-id="a1179-112">32 hlavička Magic F0 C9 F0, která identifikuje tuto verzi systému ochrany dat.</span><span class="sxs-lookup"><span data-stu-id="a1179-112">The 32-bit magic header 09 F0 C9 F0 that identifies this version of the data protection system.</span></span>

2. <span data-ttu-id="a1179-113">ID 128 klíče.</span><span class="sxs-lookup"><span data-stu-id="a1179-113">The 128-bit key id.</span></span>

3. <span data-ttu-id="a1179-114">Řetězec s proměnlivou délkou tvořený řetězcem účelu, který vytvořil `IDataProtector` tuto operaci.</span><span class="sxs-lookup"><span data-stu-id="a1179-114">A variable-length string formed from the purpose chain that created the `IDataProtector` that's performing this operation.</span></span>

<span data-ttu-id="a1179-115">Vzhledem k tomu, že je AAD jedinečný pro řazenou kolekci členů všech tří součástí, můžeme ji použít k odvození nových klíčů od KM místo samotného použití KM ve všech našich kryptografických operacích.</span><span class="sxs-lookup"><span data-stu-id="a1179-115">Because the AAD is unique for the tuple of all three components, we can use it to derive new keys from KM instead of using KM itself in all of our cryptographic operations.</span></span> <span data-ttu-id="a1179-116">Pro každé volání metody `IAuthenticatedEncryptor.Encrypt`dojde k následujícímu procesu odvození klíče:</span><span class="sxs-lookup"><span data-stu-id="a1179-116">For every call to `IAuthenticatedEncryptor.Encrypt`, the following key derivation process takes place:</span></span>

<span data-ttu-id="a1179-117">(K_E, K_H) = SP800_108_CTR_HMACSHA512 (K_M, AAD, contextHeader | | modifikátor písmen)</span><span class="sxs-lookup"><span data-stu-id="a1179-117">( K_E, K_H ) = SP800_108_CTR_HMACSHA512(K_M, AAD, contextHeader || keyModifier)</span></span>

<span data-ttu-id="a1179-118">Tady zavoláme NIST SP800-108 KDF v režimu čítače (viz [NIST SP800-108](https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-108.pdf), Sec. 5,1) s následujícími parametry:</span><span class="sxs-lookup"><span data-stu-id="a1179-118">Here, we're calling the NIST SP800-108 KDF in Counter Mode (see [NIST SP800-108](https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-108.pdf), Sec. 5.1) with the following parameters:</span></span>

* <span data-ttu-id="a1179-119">Klíč odvození klíče (KDK) = K_M</span><span class="sxs-lookup"><span data-stu-id="a1179-119">Key derivation key (KDK) = K_M</span></span>

* <span data-ttu-id="a1179-120">PRF = HMACSHA512</span><span class="sxs-lookup"><span data-stu-id="a1179-120">PRF = HMACSHA512</span></span>

* <span data-ttu-id="a1179-121">Label = additionalAuthenticatedData</span><span class="sxs-lookup"><span data-stu-id="a1179-121">label = additionalAuthenticatedData</span></span>

* <span data-ttu-id="a1179-122">kontext = contextHeader | | Modifikátor</span><span class="sxs-lookup"><span data-stu-id="a1179-122">context = contextHeader || keyModifier</span></span>

<span data-ttu-id="a1179-123">Záhlaví kontextu má proměnlivou délku a v podstatě slouží jako kryptografický otisk algoritmů, pro které je odvozeno K_E a K_H.</span><span class="sxs-lookup"><span data-stu-id="a1179-123">The context header is of variable length and essentially serves as a thumbprint of the algorithms for which we're deriving K_E and K_H.</span></span> <span data-ttu-id="a1179-124">Klávesovým zkratem je 128 řetězec, který se náhodně generuje pro každé volání `Encrypt` a slouží k zajištění, že pravděpodobnost zahlcení, které pro a b, jsou pro tuto konkrétní operaci šifrování ověřování jedinečné, a to i v případě, že všechny ostatní vstupy KDF jsou konstantní.</span><span class="sxs-lookup"><span data-stu-id="a1179-124">The key modifier is a 128-bit string randomly generated for each call to `Encrypt` and serves to ensure with overwhelming probability that KE and KH are unique for this specific authentication encryption operation, even if all other input to the KDF is constant.</span></span>

<span data-ttu-id="a1179-125">Pro CBC režim šifrování + ověřování HMAC | K_E | je délka šifrovacího klíče symetrického bloku a | K_H | je velikost Digest rutiny HMAC.</span><span class="sxs-lookup"><span data-stu-id="a1179-125">For CBC-mode encryption + HMAC validation operations, | K_E | is the length of the symmetric block cipher key, and | K_H | is the digest size of the HMAC routine.</span></span> <span data-ttu-id="a1179-126">Pro GCM šifrování a operace ověřování | K_H | = 0.</span><span class="sxs-lookup"><span data-stu-id="a1179-126">For GCM encryption + validation operations, | K_H | = 0.</span></span>

## <a name="cbc-mode-encryption--hmac-validation"></a><span data-ttu-id="a1179-127">Šifrování v režimu CBC a ověřování HMAC</span><span class="sxs-lookup"><span data-stu-id="a1179-127">CBC-mode encryption + HMAC validation</span></span>

<span data-ttu-id="a1179-128">Jakmile se K_E generuje prostřednictvím výše uvedeného mechanismu, vygenerujeme náhodný vektor inicializace a spustíme algoritmus symetrického šifrování bloku, který zakódování prostý text.</span><span class="sxs-lookup"><span data-stu-id="a1179-128">Once K_E is generated via the above mechanism, we generate a random initialization vector and run the symmetric block cipher algorithm to encipher the plaintext.</span></span> <span data-ttu-id="a1179-129">Inicializační vektor a šifrovaný text se pak spustí pomocí rutiny HMAC inicializované s klíčem, který se K_H, aby se vytvořila adresa MAC.</span><span class="sxs-lookup"><span data-stu-id="a1179-129">The initialization vector and ciphertext are then run through the HMAC routine initialized with the key K_H to produce the MAC.</span></span> <span data-ttu-id="a1179-130">Tento proces a návratová hodnota jsou znázorněny na obrázku níže.</span><span class="sxs-lookup"><span data-stu-id="a1179-130">This process and the return value is represented graphically below.</span></span>

![Proces a návrat v CBC režimu](subkeyderivation/_static/cbcprocess.png)

<span data-ttu-id="a1179-132">*výstup: = modifikátor IV | | E_cbc (K_E, IV, data) | | HMAC (K_H, IV | | E_cbc (K_E, IV, data))*</span><span class="sxs-lookup"><span data-stu-id="a1179-132">*output:= keyModifier || iv || E_cbc (K_E,iv,data) || HMAC(K_H, iv || E_cbc (K_E,iv,data))*</span></span>

> [!NOTE]
> <span data-ttu-id="a1179-133">`IDataProtector.Protect` Implementace před návratem do volajícího předřadí [hlavičku Magic a ID klíče](xref:security/data-protection/implementation/authenticated-encryption-details) do výstupu.</span><span class="sxs-lookup"><span data-stu-id="a1179-133">The `IDataProtector.Protect` implementation will [prepend the magic header and key id](xref:security/data-protection/implementation/authenticated-encryption-details) to output before returning it to the caller.</span></span> <span data-ttu-id="a1179-134">Vzhledem k tomu, že hlavičky Magic a ID klíče jsou implicitně součástí [AAD](xref:security/data-protection/implementation/subkeyderivation#data-protection-implementation-subkey-derivation-aad), a protože Modifikátor klíče je jako vstup podáván do KDF, znamená to, že Mac ověřuje každý jednotlivý bajt konečné vrácené datové části.</span><span class="sxs-lookup"><span data-stu-id="a1179-134">Because the magic header and key id are implicitly part of [AAD](xref:security/data-protection/implementation/subkeyderivation#data-protection-implementation-subkey-derivation-aad), and because the key modifier is fed as input to the KDF, this means that every single byte of the final returned payload is authenticated by the MAC.</span></span>

## <a name="galoiscounter-mode-encryption--validation"></a><span data-ttu-id="a1179-135">Galois/režim čítače šifrování + ověřování</span><span class="sxs-lookup"><span data-stu-id="a1179-135">Galois/Counter Mode encryption + validation</span></span>

<span data-ttu-id="a1179-136">Jakmile se K_E generuje prostřednictvím výše uvedeného mechanismu, vygenerujeme náhodnou 96nou hodnotu nonce a spustíte algoritmus symetrického šifrování bloku, který zakódování prostý text a vytvoří 128 značku ověřování.</span><span class="sxs-lookup"><span data-stu-id="a1179-136">Once K_E is generated via the above mechanism, we generate a random 96-bit nonce and run the symmetric block cipher algorithm to encipher the plaintext and produce the 128-bit authentication tag.</span></span>

![Proces a návrat v GCM režimu](subkeyderivation/_static/galoisprocess.png)

<span data-ttu-id="a1179-138">*výstup: = modifikátor hodnota nonce | | E_gcm (K_E, nonce, data) | | authTag*</span><span class="sxs-lookup"><span data-stu-id="a1179-138">*output := keyModifier || nonce || E_gcm (K_E,nonce,data) || authTag*</span></span>

> [!NOTE]
> <span data-ttu-id="a1179-139">I když GCM nativně podporuje koncept AAD, pořád ještě neposkytujeme do původního KDFu AAD, která se zapojuje k předání prázdného řetězce do GCM pro svůj parametr AAD.</span><span class="sxs-lookup"><span data-stu-id="a1179-139">Even though GCM natively supports the concept of AAD, we're still feeding AAD only to the original KDF, opting to pass an empty string into GCM for its AAD parameter.</span></span> <span data-ttu-id="a1179-140">Důvodem je dvojí přeložení.</span><span class="sxs-lookup"><span data-stu-id="a1179-140">The reason for this is two-fold.</span></span> <span data-ttu-id="a1179-141">Nejprve [pro podporu flexibility, které](xref:security/data-protection/implementation/context-headers#data-protection-implementation-context-headers) nikdy nechcete používat K_M přímo jako šifrovací klíč.</span><span class="sxs-lookup"><span data-stu-id="a1179-141">First, [to support agility](xref:security/data-protection/implementation/context-headers#data-protection-implementation-context-headers) we never want to use K_M directly as the encryption key.</span></span> <span data-ttu-id="a1179-142">Kromě toho GCM ukládá velmi přísné požadavky jedinečnosti na své vstupy.</span><span class="sxs-lookup"><span data-stu-id="a1179-142">Additionally, GCM imposes very strict uniqueness requirements on its inputs.</span></span> <span data-ttu-id="a1179-143">Pravděpodobnost, že se rutina šifrování GCM někdy vyvolala na dvou nebo více různých sadách vstupních dat se stejnou dvojicí (Key, nonce), nesmí překročit 2 ^ 32.</span><span class="sxs-lookup"><span data-stu-id="a1179-143">The probability that the GCM encryption routine is ever invoked on two or more distinct sets of input data with the same (key, nonce) pair must not exceed 2^32.</span></span> <span data-ttu-id="a1179-144">Pokud opravujeme K_E nemůžeme provést více než 2 ^ 32 operací šifrování předtím, než spustíte afoul limitu 2 ^-32.</span><span class="sxs-lookup"><span data-stu-id="a1179-144">If we fix K_E we cannot perform more than 2^32 encryption operations before we run afoul of the 2^-32 limit.</span></span> <span data-ttu-id="a1179-145">Může se zdát, že se jedná o velmi velký počet operací, ale webový server s vysokým provozem může projít 4 000 000 000 požadavky v pouhých dnech, a to i v normálním trvání těchto klíčů.</span><span class="sxs-lookup"><span data-stu-id="a1179-145">This might seem like a very large number of operations, but a high-traffic web server can go through 4 billion requests in mere days, well within the normal lifetime for these keys.</span></span> <span data-ttu-id="a1179-146">Aby zůstalo v souladu s limitem 2 ^-32, používáme modifikátor 128 bitového klíče a 96-bit nonce, který odpíná počet použitelných operací pro všechny dané K_M.</span><span class="sxs-lookup"><span data-stu-id="a1179-146">To stay compliant of the 2^-32 probability limit, we continue to use a 128-bit key modifier and 96-bit nonce, which radically extends the usable operation count for any given K_M.</span></span> <span data-ttu-id="a1179-147">Pro jednoduchost návrhu sdílíme cestu kódu KDF mezi CBC a GCM operacemi a vzhledem k tomu, že AAD je už v KDF zvážené, není potřeba je přesměrovat do rutiny GCM.</span><span class="sxs-lookup"><span data-stu-id="a1179-147">For simplicity of design we share the KDF code path between CBC and GCM operations, and since AAD is already considered in the KDF there's no need to forward it to the GCM routine.</span></span>
