---
title: Migrace z ASP.NET Core 2,2 na 3,0
author: rick-anderson
description: Přečtěte si, jak migrovat projekt ASP.NET Core 2,2 do ASP.NET Core 3,0.
ms.author: riande
ms.custom: mvc
ms.date: 05/03/2020
no-loc:
- Blazor
- Identity
- Let's Encrypt
- Razor
- SignalR
uid: migration/22-to-30
ms.openlocfilehash: 5156e21cd33e6779ef005c9a12dec6be4685d485
ms.sourcegitcommit: 70e5f982c218db82aa54aa8b8d96b377cfc7283f
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 05/04/2020
ms.locfileid: "82777238"
---
# <a name="migrate-from-aspnet-core-22-to-30"></a>Migrace z ASP.NET Core 2,2 na 3,0

[Scottem Addie](https://github.com/scottaddie) a [Rick Anderson](https://twitter.com/RickAndMSFT)

Tento článek vysvětluje, jak aktualizovat existující projekt ASP.NET Core 2,2 na ASP.NET Core 3,0. Může být užitečné vytvořit nový projekt ASP.NET Core 3,0 pro:

* Porovnejte s kódem ASP.NET Core 2,2.
* Zkopírujte příslušné změny do projektu ASP.NET Core 3,0.

## <a name="prerequisites"></a>Požadavky

# <a name="visual-studio"></a>[Visual Studio](#tab/visual-studio)

[!INCLUDE[](~/includes/net-core-prereqs-vs-3.0.md)]

# <a name="visual-studio-code"></a>[Visual Studio Code](#tab/visual-studio-code)

[!INCLUDE[](~/includes/net-core-prereqs-vsc-3.0.md)]

# <a name="visual-studio-for-mac"></a>[Visual Studio pro Mac](#tab/visual-studio-mac)

[!INCLUDE[](~/includes/net-core-prereqs-mac-3.0.md)]

---

## <a name="update-net-core-sdk-version-in-globaljson"></a>Aktualizace verze .NET Core SDK v Global. JSON

Pokud vaše řešení využívá soubor [Global. JSON](/dotnet/core/tools/global-json) pro cílení na konkrétní verzi .NET Core SDK, aktualizujte jeho `version` vlastnost na verzi 3,0 nainstalovanou na vašem počítači:

```json
{
  "sdk": {
    "version": "3.0.100"
  }
}
```

## <a name="update-the-project-file"></a>Aktualizovat soubor projektu

### <a name="update-the-target-framework"></a>Aktualizace cílového rozhraní .NET Framework

ASP.NET Core 3,0 a novější se spouští pouze v .NET Core. Nastavte [moniker cílového rozhraní .NET Framework (TFM)](/dotnet/standard/frameworks) na `netcoreapp3.0`:

[!code-xml[](22-to-30/samples/Web1.csproj?highlight=4)]

### <a name="remove-obsolete-package-references"></a>Odebrat zastaralé odkazy na balíčky

Pro ASP.NET Core 3,0 není vytvořený velký počet balíčků NuGet. Tyto odkazy na balíčky by měly být odebrány ze souboru projektu. Vezměte v úvahu následující soubor projektu pro webovou aplikaci ASP.NET Core 2,2:

```xml
<Project Sdk="Microsoft.NET.Sdk.Web">

  <PropertyGroup>
    <TargetFramework>netcoreapp2.2</TargetFramework>
    <AspNetCoreHostingModel>InProcess</AspNetCoreHostingModel>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.AspNetCore.App"/>
    <PackageReference Include="Microsoft.AspNetCore.Razor.Design" Version="2.2.0" PrivateAssets="All" />
  </ItemGroup>

</Project>
```

Aktualizovaný soubor projektu pro ASP.NET Core 3,0:

[!code-xml[](22-to-30/samples/Web1.csproj?highlight=4)]

Aktualizovaný soubor projektu ASP.NET Core 3,0:

* V `<PropertyGroup>`:
  * Aktualizuje TFM na.`netcoreapp3.0`
  * Odebere `<AspNetCoreHostingModel>` prvek. Další informace najdete v tématu [model hostování v procesu](#in-process-hosting-model) v tomto dokumentu.

* V `<ItemGroup>`:
  * `Microsoft.AspNetCore.App`je odebráno. Další informace najdete v tématu [Reference k rozhraní](#framework-reference) v tomto dokumentu.
  * `Microsoft.AspNetCore.Razor.Design`odebrána a v následujícím seznamu balíčků již nejsou vytvářeny.

Úplný seznam balíčků, které už nejsou vytvořené, zobrazíte tak, že vyberete následující seznam rozbalit:

<details>
    <summary>Kliknutím rozbalíte seznam balíčků, které už nejsou vyráběny.</summary>
    <ul>
        <li>Microsoft. AspNetCore</li>
        <li>Microsoft. AspNetCore. All</li>
        <li>Microsoft. AspNetCore. app</li>
        <li>Microsoft.AspNetCore.Antiforgery</li>
        <li>Microsoft.AspNetCore.Authentication</li>
        <li>Microsoft.AspNetCore.Authentication.Abstractions</li>
        <li>Microsoft.AspNetCore.Authentication.Cookies</li>
        <li>Microsoft.AspNetCore.Authentication.Core</li>
        <li>Microsoft.AspNetCore.Authentication.OAuth</li>
        <li>Microsoft.AspNetCore.Authorization.Policy</li>
        <li>Microsoft.AspNetCore.CookiePolicy</li>
        <li>Microsoft.AspNetCore.Cors</li>
        <li>Microsoft.AspNetCore.Diagnostics</li>
        <li>Microsoft.AspNetCore.Diagnostics.HealthChecks</li>
        <li>Microsoft. AspNetCore. HostFiltering</li>
        <li>Microsoft. AspNetCore. hosting</li>
        <li>Microsoft.AspNetCore.Hosting.Abstractions</li>
        <li>Microsoft.AspNetCore.Hosting.Server.Abstractions</li>
        <li>Microsoft.AspNetCore.Http</li>
        <li>Microsoft.AspNetCore.Http.Abstractions</li>
        <li>Microsoft.AspNetCore.Http.Connections</li>
        <li>Microsoft.AspNetCore.Http.Extensions</li>
        <li>Microsoft.AspNetCore.HttpOverrides</li>
        <li>Microsoft.AspNetCore.HttpsPolicy</li>
        <li>Microsoft. AspNetCore.Identity</li>
        <li>Microsoft.AspNetCore.Localization</li>
        <li>Microsoft.AspNetCore.Localization.Routing</li>
        <li>Microsoft. AspNetCore. Mvc</li>
        <li>Microsoft.AspNetCore.Mvc.Abstractions</li>
        <li>Microsoft.AspNetCore.Mvc.Analyzers</li>
        <li>Microsoft.AspNetCore.Mvc.ApiExplorer</li>
        <li>Microsoft.AspNetCore.Mvc.Api.Analyzers</li>
        <li>Microsoft.AspNetCore.Mvc.Core</li>
        <li>Microsoft.AspNetCore.Mvc.Cors</li>
        <li>Microsoft.AspNetCore.Mvc.DataAnnotations</li>
        <li>Microsoft.AspNetCore.Mvc.Formatters.Json</li>
        <li>Microsoft.AspNetCore.Mvc.Formatters.Xml</li>
        <li>Microsoft.AspNetCore.Mvc.Localization</li>
        <li>Microsoft. AspNetCore. Mvc.Razor</li>
        <li>Microsoft. AspNetCore. Mvc. Razor. ViewCompilation</li>
        <li>Microsoft.AspNetCore.Mvc.RazorPages</li>
        <li>Microsoft.AspNetCore.Mvc.TagHelpers</li>
        <li>Microsoft.AspNetCore.Mvc.ViewFeatures</li>
        <li>Microsoft. AspNetCore.Razor</li>
        <li>Microsoft. AspNetCore. Razor. Runtime</li>
        <li>Microsoft. AspNetCore. Razor. Vytvořit</li>
        <li>Microsoft.AspNetCore.ResponseCaching</li>
        <li>Microsoft.AspNetCore.ResponseCaching.Abstractions</li>
        <li>Microsoft.AspNetCore.ResponseCompression</li>
        <li>Microsoft.AspNetCore.Rewrite</li>
        <li>Microsoft. AspNetCore. Routing</li>
        <li>Microsoft.AspNetCore.Routing.Abstractions</li>
        <li>Microsoft.AspNetCore.Server.HttpSys</li>
        <li>Microsoft.AspNetCore.Server.IIS</li>
        <li>Microsoft.AspNetCore.Server.IISIntegration</li>
        <li>Microsoft.AspNetCore.Server.Kestrel</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Core</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Https</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets</li>
        <li>Microsoft.AspNetCore.Session</li>
        <li>Microsoft. AspNetCore.SignalR</li>
        <li>Microsoft. AspNetCore. SignalR. Core</li>
        <li>Microsoft. AspNetCore. StaticFiles</li>
        <li>Microsoft.AspNetCore.WebSockets</li>
        <li>Microsoft.AspNetCore.WebUtilities</li>
        <li>Microsoft.Net.Http.Headers </li>
    </ul>
</details>

### <a name="review-breaking-changes"></a>Kontrola nejnovějších změn

[Kontrola nejnovějších změn](#break)

### <a name="framework-reference"></a>Odkaz na rozhraní

Funkce ASP.NET Core, které byly k dispozici prostřednictvím jednoho z výše uvedených balíčků, jsou k dispozici `Microsoft.AspNetCore.App` jako součást sdíleného rozhraní. *Sdílené rozhraní* je sada sestavení (soubory *. dll* ), které jsou nainstalovány na počítači a zahrnují komponentu modulu runtime a sadu targeting pack. Další informace najdete v tématu [sdílené rozhraní](https://natemcmaster.com/blog/2018/08/29/netcore-primitives-2/).

* Projekty, které cílí `Microsoft.NET.Sdk.Web` na sadu SDK, implicitně odkazují na `Microsoft.AspNetCore.App` rozhraní.

  Pro tyto projekty nejsou vyžadovány žádné další odkazy:

  ```xml
  <Project Sdk="Microsoft.NET.Sdk.Web">
    <PropertyGroup>
      <TargetFramework>netcoreapp3.0</TargetFramework>
    </PropertyGroup>
      ...
  </Project>
  ```

* Projekty, které `Microsoft.NET.Sdk` cílí `Microsoft.NET.Sdk.Razor` na sadu SDK, by měly `FrameworkReference` přidat `Microsoft.AspNetCore.App`explicitní pro:

  ```xml
  <Project Sdk="Microsoft.NET.Sdk.Razor">
    <PropertyGroup>
      <TargetFramework>netcoreapp3.0</TargetFramework>
    </PropertyGroup>

    <ItemGroup>
      <FrameworkReference Include="Microsoft.AspNetCore.App" />
    </ItemGroup>
      ...
  </Project>
  ```

#### <a name="framework-dependent-builds-using-docker"></a>Sestavení závislá na rozhraních pomocí Docker

Sestavení závislé na rozhraních konzolových aplikací, které používají balíček, který závisí na ASP.NET Core [sdílenému rozhraní](https://natemcmaster.com/blog/2018/08/29/netcore-primitives-2/) , mohou poskytnout následující chybu za běhu:

```console
It was not possible to find any compatible framework version
The specified framework 'Microsoft.AspNetCore.App', version '3.0.0' was not found.
  - No frameworks were found.
```

`Microsoft.AspNetCore.App`je sdílené rozhraní obsahující modul runtime ASP.NET Core a je k dispozici pouze v imagi [dotnet/Core/ASPNET](https://hub.docker.com/_/microsoft-dotnet-core-aspnet/) Docker. Sada SDK 3,0 omezuje velikost sestavení závislých na rozhraních pomocí ASP.NET Core nezahrnují duplicitní kopie knihoven, které jsou k dispozici ve sdíleném rozhraní. Jedná se o potenciální úspory až 18 MB, ale vyžaduje, aby se při spuštění aplikace spustil nebo nainstaloval modul runtime ASP.NET Core.

Pokud chcete zjistit, jestli má aplikace závislost (buď přímá, nebo nepřímá) na ASP.NET Core sdíleném rozhraním, Projděte si soubor *runtimeconfig. JSON* vygenerovaný během sestavování/publikování vaší aplikace. Následující soubor JSON ukazuje závislost na ASP.NET Core sdílené rozhraní:

```json
{
  "runtimeOptions": {
    "tfm": "netcoreapp3.0",
    "framework": {
      "name": "Microsoft.AspNetCore.App",
      "version": "3.0.0"
    },
    "configProperties": {
      "System.GC.Server": true
    }
  }
}
```

Pokud vaše aplikace používá Docker, použijte základní image, která zahrnuje ASP.NET Core 3,0. Například, `docker pull mcr.microsoft.com/dotnet/core/aspnet:3.0`.

### <a name="add-package-references-for-removed-assemblies"></a>Přidat odkazy na balíčky pro odebraná sestavení

ASP.NET Core 3,0 odstraní některá sestavení, která byla dříve součástí odkazu `Microsoft.AspNetCore.App` na balíček. Chcete-li vizualizovat, která sestavení byla odebrána, Porovnejte dvě sdílené složky rozhraní. Například porovnání verzí 2.2.7 a 3.0.0:

![porovnání sestavení sdílených rozhraní](22-to-30/_static/assembly-diff.png)

Chcete-li pokračovat v používání funkcí poskytovaných odebranými sestaveními, odkazujte na verze 3,0 odpovídajících balíčků:

* Webová aplikace vygenerovaná šablonou s **jednotlivými uživatelskými účty** vyžaduje přidání následujících balíčků:

  [!code-xml[](22-to-30/samples/WebFull.csproj?highlight=9-13)]

* [Microsoft. EntityFrameworkCore](https://www.nuget.org/packages/Microsoft.EntityFrameworkCore)

  Další informace o odkazování na balíček pro konkrétního poskytovatele databáze najdete v tématu [poskytovatelé databáze](/ef/core/providers/index).

* IdentityROZHRANÍ

  Podporu [ Identity uživatelského rozhraní](xref:security/authentication/identity) lze přidat odkazem na [Microsoft. AspNetCore.Identity Balíček uživatelského rozhraní](https://www.nuget.org/packages/Microsoft.AspNetCore.Identity.UI) .

* Služby SPA

  * [Microsoft. AspNetCore. SpaServices](https://www.nuget.org/packages/Microsoft.AspNetCore.SpaServices)
  * [Microsoft. AspNetCore. SpaServices. Extensions](https://www.nuget.org/packages/Microsoft.AspNetCore.SpaServices.Extensions)

* Podpora &ndash; ověřování pro toky ověřování třetích stran je k dispozici jako balíčky NuGet:

  * Facebook OAuth ([Microsoft. AspNetCore. Authentication. Facebook](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Facebook))
  * Google OAuth ([Microsoft. AspNetCore. Authentication. Google](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Google))
  * Ověřování účtu Microsoft ([Microsoft. AspNetCore. Authentication. MicrosoftAccount](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.MicrosoftAccount))
  * OpenID Connect Authentication ([Microsoft. AspNetCore. Authentication. OpenIdConnect](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.OpenIdConnect))
  * Token nosiče OpenID Connect ([Microsoft. AspNetCore. Authentication. JwtBearer](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.JwtBearer))
  * Twitter OAuth ([Microsoft. AspNetCore. Authentication. Twitter](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Twitter))
  * Ověřování WsFederation ([Microsoft. AspNetCore. Authentication. WsFederation](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.WsFederation))

* Podpora formátování a vyjednávání obsahu pro `System.Net.HttpClient` &ndash; balíček NuGet [Microsoft. ASPNET. WebApi. Client](https://www.nuget.org/packages/Microsoft.AspNet.WebApi.Client/) poskytuje užitečné rozšíření pro `System.Net.HttpClient` rozhraní API, jako jsou `ReadAsAsync` a `PostJsonAsync`.

* RazorPodpora kompilace &ndash; za běhu pro kompilaci Razor zobrazení a stránek je teď součástí [Microsoft. AspNetCore. Mvc..Razor RuntimeCompilation](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation).

* MVC `Newtonsoft.Json` (JSON.NET) podpora &ndash; pro použití MVC se `Newtonsoft.Json` teď nachází v části [Microsoft. AspNetCore. Mvc. NewtonsoftJson](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson).

## <a name="startup-changes"></a>Změny při spuštění

Na následujícím obrázku vidíte odstraněné a změněné řádky ve webové aplikaci Razor ASP.NET Core 2,2 Pages:

![odstraněné a změněné řádky ve webové aplikaci Razor ASP.NET Core 2,2](22-to-30/_static/startup2.2.png)

Na předchozím obrázku se odstraněný kód zobrazuje červeně. Odstraněný kód nezobrazuje kód možnosti souboru cookie, který byl odstraněn před porovnáním souborů.

Následující obrázek znázorňuje přidané a změněné řádky ve webové aplikaci ASP.NET Core 3,0 Razor Pages:

![přidané a změněné řádky ve webové aplikaci ASP.NET Core 3,0 Razor](22-to-30/_static/startup3.0.png)

Na předchozím obrázku se přidaný kód zobrazuje zeleně. Informace o následujících změnách:

* `services.AddMvc`do `services.AddRazorPages`najdete v tématu [Registrace služby MVC](#mvc-service-registration) v tomto dokumentu.
* `CompatibilityVersion`naleznete v <xref:mvc/compatibility-version>tématu.
* `IHostingEnvironment`na `IWebHostEnvironment`najdete [Toto oznámení GitHubu](https://github.com/dotnet/AspNetCore/issues/7749).
* `app.UseAuthorization`bylo přidáno do šablon, aby se zobrazila klauzule autorizačního rozhraní ORDER by se měla přidat. Pokud aplikace nepoužívá autorizaci, můžete volání bezpečně odebrat `app.UseAuthorization`.
* `app.UseEndpoints`, přečtěte si téma [ Razor stránky](#razor-pages) nebo [migrujte Startup. Configure](#migrate-startupconfigure) v tomto dokumentu.

### <a name="analyzer-support"></a>Podpora analyzátoru

Projekty, které `Microsoft.NET.Sdk.Web` cílí na implicitně referenční analyzátory dříve dodávané jako součást balíčku [Microsoft. AspNetCore. Mvc. analyzers](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Analyzers/) . K povolení těchto kroků nejsou vyžadovány žádné další odkazy.

Pokud vaše aplikace používá [analyzátory rozhraní API](xref:web-api/advanced/analyzers) dříve dodávané pomocí balíčku [Microsoft. AspNetCore. Mvc. API. analyzers](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Api.Analyzers/) , upravte soubor projektu tak, aby odkazoval na analyzátory dodávané jako součást sady .NET Core web SDK:

```xml
<Project Sdk="Microsoft.NET.Sdk.Web">
    <PropertyGroup>
        <TargetFramework>netcoreapp3.0</TargetFramework>
        <IncludeOpenAPIAnalyzers>true</IncludeOpenAPIAnalyzers>
    </PropertyGroup>

    ...
</Project>
```

### <a name="razor-class-library"></a>RazorKnihovna tříd

RazorProjekty knihovny tříd, které poskytují komponenty uživatelského rozhraní pro MVC, `AddRazorSupportForMvc` musí nastavit vlastnost v souboru projektu:

```xml
<PropertyGroup>
  <AddRazorSupportForMvc>true</AddRazorSupportForMvc>
</PropertyGroup>
```

### <a name="in-process-hosting-model"></a>Model hostování v procesu

Projekty jsou ve výchozím nastavení pro [model hostování v rámci procesu](xref:host-and-deploy/aspnet-core-module#in-process-hosting-model) v ASP.NET Core 3,0 nebo novějším. Případně můžete odebrat `<AspNetCoreHostingModel>` vlastnost v souboru projektu, pokud je `InProcess`její hodnota.

## <a name="kestrel"></a>Kestrel

### <a name="configuration"></a>Konfigurace

Migruje konfiguraci Kestrel do [Tvůrce webového hostitele](#hostb) , který `ConfigureWebHostDefaults` poskytuje (*program.cs*):

```csharp
public static IHostBuilder CreateHostBuilder(string[] args) =>
    Host.CreateDefaultBuilder(args)
        .ConfigureWebHostDefaults(webBuilder =>
        {
            webBuilder.ConfigureKestrel(serverOptions =>
            {
                // Set properties and call methods on options
            })
            .UseStartup<Startup>();
        });
```

Pokud aplikace vytvoří hostitele ručně pomocí `HostBuilder`, zavolejte `UseKestrel` na tvůrce webového hostitele v: `ConfigureWebHostDefaults`

```csharp
public static void Main(string[] args)
{
    var host = new HostBuilder()
        .UseContentRoot(Directory.GetCurrentDirectory())
        .ConfigureWebHostDefaults(webBuilder =>
        {
            webBuilder.UseKestrel(serverOptions =>
            {
                // Set properties and call methods on options
            })
            .UseIISIntegration()
            .UseStartup<Startup>();
        })
        .Build();

    host.Run();
}
```

### <a name="connection-middleware-replaces-connection-adapters"></a>Middleware připojení nahrazuje adaptéry připojení

Připojovací adaptéry (`Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.IConnectionAdapter`) byly odebrány z Kestrel. Nahraďte připojovací adaptéry pomocí middleware připojení. Middleware připojení se podobá middlewaru protokolu HTTP v kanálu ASP.NET Core, ale pro připojení nižší úrovně. Protokol HTTPS a protokolování připojení:

* Byly přesunuty z připojovacích adaptérů na middleware připojení.
* Tyto metody rozšíření fungují jako v předchozích verzích ASP.NET Core. 

Další informace najdete v [příkladu TlsFilterConnectionHandler v části ListenOptions. Protocols článku Kestrel](/aspnet/core/fundamentals/servers/kestrel?view=aspnetcore-3.0#listenoptionsprotocols).

### <a name="transport-abstractions-moved-and-made-public"></a>Přemístění a zpřístupnění abstrakcí přenosu

Přenosová vrstva Kestrel byla vystavena jako veřejné rozhraní v `Connections.Abstractions`. Jako součást těchto aktualizací:

* `Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions`a přidružené typy byly odebrány.
* <xref:Microsoft.AspNetCore.Server.Kestrel.KestrelServerOptions.NoDelay>byl přesunut z <xref:Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions> na možnosti přenosu.
* `Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions.Internal.SchedulingMode`bylo odebráno <xref:Microsoft.AspNetCore.Server.Kestrel.KestrelServerOptions>z.

Další informace najdete v následujících materiálech GitHubu:

* [Abstrakce sítě klienta/serveru (dotnet/AspNetCore #10308)](https://github.com/dotnet/AspNetCore/issues/10308)
* [Implementujte nové abstrakce naslouchacího procesu Bedrock a Kestrel znovu platně (dotnet/AspNetCore #10321)](https://github.com/dotnet/AspNetCore/pull/10321)

### <a name="kestrel-request-trailer-headers"></a>Hlavičky přípojných vozidel žádosti Kestrel

Pro aplikace, které cílí na starší verze ASP.NET Core:

* Kestrel přidá hlavičky přípojného bodu HTTP/1.1 do kolekce hlaviček požadavků.
* Po načtení textu žádosti na konec jsou k dispozici Přípojná místa.

To způsobuje některé obavy z nejednoznačnosti mezi hlavičkami a přípojnými vozidly, takže přípojná vozidla byla přesunuta do nové kolekce (`RequestTrailerExtensions`) v 3,0.

Přívěsy žádostí HTTP/2 jsou:

* Není k dispozici v ASP.NET Core 2,2.
* K dispozici v `RequestTrailerExtensions`3,0 jako.

Pro přístup k těmto přípojným vozidlům jsou k dispozici nové metody rozšíření žádosti. Stejně jako v případě protokolu HTTP/1.1 jsou po načtení textu žádosti na konec k dispozici Přípojná místa.

Pro vydání 3,0 jsou k dispozici `RequestTrailerExtensions` následující metody:

* `GetDeclaredTrailers`&ndash; Načte hlavičku žádosti `Trailer` , která zobrazí seznam přípojných vozidel, která se mají po tělo očekávat.
* `SupportsTrailers`&ndash; Určuje, zda požadavek podporuje příjem hlaviček přípojných vozidel.
* `CheckTrailersAvailable`&ndash; Kontroluje, zda požadavek podporuje Přípojná místa a zda jsou k dispozici pro čtení. Tato kontrolu nepředpokládá, že existuje přívěsy ke čtení. Není možné, aby bylo možné číst bez přípojných míst, i když `true` je tato metoda vrácena.
* `GetTrailer`&ndash; Získá požadovanou ukončovací hlavičku z odpovědi. `SupportsTrailers` Před voláním `GetTrailer`nebo se <xref:System.NotSupportedException> může vyskytnout, pokud požadavek nepodporuje koncové hlavičky.

Další informace najdete v tématu [o umístění přípojných vozidel v samostatné kolekci (dotnet/AspNetCore #10410)](https://github.com/dotnet/AspNetCore/pull/10410).

### <a name="allowsynchronousio-disabled"></a>AllowSynchronousIO zakázané

`AllowSynchronousIO`povoluje nebo zakazuje synchronní vstupně-výstupní rozhraní API, `HttpRequest.Body.Read`například `HttpResponse.Body.Write`, a `Stream.Flush`. Tato rozhraní API jsou zdrojem vyčerpání vláken, který vede k selhání aplikace. V 3,0 `AllowSynchronousIO` je ve výchozím nastavení zakázáno. Další informace najdete v [části synchronní v/v v článku Kestrel](/aspnet/core/fundamentals/servers/kestrel?view=aspnetcore-3.0#synchronous-io).

Pokud je potřeba synchronní vstupně-výstupní operace, můžete ji povolit nakonfigurováním `AllowSynchronousIO` možnosti na serveru, který se používá (například při `ConfigureKestrel`volání, pokud používáte Kestrel). Upozorňujeme, že servery (Kestrel, HttpSys, TestServer atd.) mají svou vlastní `AllowSynchronousIO` možnost, která nebude mít vliv na ostatní servery. Synchronní vstupně-výstupní operace lze povolit pro všechny servery na základě jednotlivých požadavků pomocí `IHttpBodyControlFeature.AllowSynchronousIO` možnosti:

```csharp
var syncIOFeature = HttpContext.Features.Get<IHttpBodyControlFeature>();

if (syncIOFeature != null)
{
    syncIOFeature.AllowSynchronousIO = true;
}
```

Pokud máte problémy s <xref:System.IO.TextWriter> implementacemi nebo jinými datovými proudy, které volají synchronní rozhraní API v <xref:System.IO.Stream.DisposeAsync*> [Dispose](/dotnet/standard/garbage-collection/implementing-dispose), zavolejte místo toho nové rozhraní API.

Další informace najdete v tématu [[oznámení] AllowSynchronousIO zakázáno na všech serverech (dotnet/AspNetCore #7644)](https://github.com/dotnet/AspNetCore/issues/7644).

### <a name="microsoftaspnetcoreserverkestrelhttps-assembly-removed"></a>Bylo odebráno sestavení Microsoft. AspNetCore. Server. Kestrel. https.

V ASP.NET Core 2,1 se obsah souboru *Microsoft. AspNetCore. Server. Kestrel. https. dll* přesunul do souboru *Microsoft. AspNetCore. Server. Kestrel. Core. dll*. Toto byla neprůlomová aktualizace pomocí `TypeForwardedTo` atributů. Pro 3,0 byla odebrána prázdná sestavení *Microsoft. AspNetCore. Server. Kestrel. https. dll* a balíček NuGet.

Knihovny odkazující na [Microsoft. AspNetCore. Server. Kestrel. https](https://www.nuget.org/packages/Microsoft.AspNetCore.Server.Kestrel.Https) by měly aktualizovat ASP.NET Core závislosti na 2,1 nebo novější.

Aplikace a knihovny cílené na ASP.NET Core 2,1 nebo novější by měly odebrat všechny přímé odkazy na balíček [Microsoft. AspNetCore. Server. Kestrel. https](https://www.nuget.org/packages/Microsoft.AspNetCore.Server.Kestrel.Https) .

<a id="jsonnet-support"></a>

## <a name="newtonsoftjson-jsonnet-support"></a>Podpora Newtonsoft. JSON (Json.NET)

Jako součást práce pro [zlepšení ASP.NET Core sdílených rozhraním](https://blogs.msdn.microsoft.com/webdev/2018/10/29/a-first-look-at-changes-coming-in-asp-net-core-3-0/)se z ASP.NET Core sdílené architektury odebrala [Newtonsoft. JSON (JSON.NET)](https://www.newtonsoft.com/json/help/html/Introduction.htm) .

Výchozí serializátor JSON pro ASP.NET Core je teď <xref:System.Text.Json>, což je v .net Core 3,0 nové. Zvažte použití `System.Text.Json` , pokud je to možné. Je to vysoký výkon a nevyžaduje další závislost knihovny. Jelikož `System.Text.Json` je však novinkou, může v současnosti chybět funkce, které vaše aplikace potřebuje. Další informace najdete v tématu [Postup migrace z Newtonsoft. JSON na System. text. JSON](/dotnet/standard/serialization/system-text-json-migrate-from-newtonsoft-how-to).

### <a name="use-newtonsoftjson-in-an-aspnet-core-30-signalr-project"></a>Použití Newtonsoft. JSON v projektu ASP.NET Core 3,0 SignalR

* Nainstalujte [Microsoft. AspNetCoreSignalR.. Balíček NuGet Protocols. NewtonsoftJson](https://www.nuget.org/packages/Microsoft.AspNetCore.SignalR.Protocols.NewtonsoftJson)

* Na straně klienta řetězit volání `AddNewtonsoftJsonProtocol` metody do `HubConnectionBuilder` instance:

  ```csharp
  new HubConnectionBuilder()
      .WithUrl("/chatHub")
      .AddNewtonsoftJsonProtocol(...)
      .Build();
  ```

* Na serveru řetězit `AddNewtonsoftJsonProtocol` volání `AddSignalR` metody volání metody: `Startup.ConfigureServices`

  ```csharp
  services.AddSignalR()
      .AddNewtonsoftJsonProtocol(...);
  ```

### <a name="use-newtonsoftjson-in-an-aspnet-core-30-mvc-project"></a>Použití Newtonsoft. JSON v projektu ASP.NET Core 3,0 MVC

* Nainstalujte balíček [Microsoft. AspNetCore. Mvc. NewtonsoftJson](https://nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson) .

* Aktualizujte `Startup.ConfigureServices` volání `AddNewtonsoftJson`.

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson();
  ```

  `AddNewtonsoftJson`je kompatibilní s novými metodami registrace služby MVC:

  * `AddRazorPages`
  * `AddControllersWithViews`
  * `AddControllers`

  ```csharp
  services.AddControllers()
      .AddNewtonsoftJson();
  ```

  `Newtonsoft.Json`nastavení lze nastavit v volání `AddNewtonsoftJson`:

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson(options =>
             options.SerializerSettings.ContractResolver =
                new CamelCasePropertyNamesContractResolver());
  ```

**Poznámka:** Pokud tato `AddNewtonsoftJson` metoda není k dispozici, ujistěte se, že jste nainstalovali balíček [Microsoft. AspNetCore. Mvc. NewtonsoftJson](https://nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson) . Běžnou chybou je instalace balíčku [Newtonsoft. JSON](https://www.nuget.org/packages/Newtonsoft.Json/) namísto balíčku [Microsoft. AspNetCore. Mvc. NewtonsoftJson](https://nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson) .

## <a name="mvc-service-registration"></a>Registrace služby MVC

ASP.NET Core 3,0 přidává nové možnosti pro registraci scénářů MVC `Startup.ConfigureServices`v rámci.

K dispozici jsou tři nové metody rozšíření na `IServiceCollection` nejvyšší úrovni související s scénáři MVC. Šablony používají tyto nové metody místo `AddMvc`. Nicméně se `AddMvc` i nadále chová jako v předchozích verzích.

Následující příklad přidá podporu pro řadiče a funkce související s rozhraním API, ale ne zobrazení nebo stránky. Šablona rozhraní API používá tento kód:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllers();
}
```

Následující příklad přidá podporu pro řadiče, funkce související s rozhraním API a zobrazení, ale ne stránky. Šablona webové aplikace (MVC) používá tento kód:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews();
}
```

V následujícím příkladu je přidána podpora Razor pro stránky a minimální Podpora řadičů. Šablona webové aplikace používá tento kód:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddRazorPages();
}
```

Nové metody lze také kombinovat. Následující příklad je ekvivalentní volání `AddMvc` v ASP.NET Core 2,2:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews();
    services.AddRazorPages();
}
```

## <a name="routing-startup-code"></a>Spouštěcí kód směrování

Pokud je to aplikace `UseMvc` , `UseSignalR`nebo pokud je to možné, proveďte migraci aplikace do [Směrování koncových bodů](xref:fundamentals/routing) . Pro zlepšení kompatibility směrování koncových bodů s předchozími verzemi MVC jsme vrátili některé změny v adrese URL představené v ASP.NET Core 2,2. Pokud jste narazili na problémy s používáním směrování koncových bodů v 2,2, můžete očekávat vylepšení ASP.NET Core 3,0 s následujícími výjimkami:

* Pokud aplikace implementuje `IRouter` nebo dědí z `Route`, použijte jako náhradu [DynamicRouteValuesTransformer](https://github.com/dotnet/AspNetCore.Docs/issues/12997) .
* Pokud aplikace přímo přistupuje k analýze `RouteData.Routers` adres URL v rámci MVC, můžete ji nahradit použitím [LinkParser. ParsePathByEndpointName](xref:Microsoft.AspNetCore.Routing.LinkParserEndpointNameAddressExtensions.ParsePathByEndpointName*). 
  * Zadejte trasu s názvem trasy.
  * Použijte `LinkParser.ParsePathByEndpointName` a předejte název požadované trasy.

Směrování koncového bodu podporuje stejnou syntaxi vzorů směrování a funkce vytváření vzorů směrování jako `IRouter`. Směrování koncového `IRouteConstraint`bodu podporuje. Směrování koncového `[Route]`bodu `[HttpGet]`podporuje, a další atributy směrování MVC.

Pro většinu aplikací vyžaduje pouze `Startup` změny.

### <a name="migrate-startupconfigure"></a>Migrovat Startup. Configure

Obecné pokyny:

* Přidat `UseRouting`.
* Pokud je aplikace volána `UseStaticFiles`, umístěte `UseStaticFiles` **před** `UseRouting`.
* Pokud aplikace používá funkce ověřování/autorizace, jako je `AuthorizePage` nebo `[Authorize]`, umístěte volání do `UseAuthentication` a `UseAuthorization`: **After** `UseRouting` a `UseCors`, ale před: `UseEndpoints`

  ```csharp
  public void Configure(IApplicationBuilder app)
  {
    ...

    app.UseStaticFiles();

    app.UseRouting();
    app.UseCors();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints => {
       endpoints.MapControllers();
    });
  ```

* `UseMvc` Nahraďte `UseSignalR` nebo `UseEndpoints`s.
* Pokud aplikace používá scénáře [CORS](xref:security/cors) , například `[EnableCors]`, umístěte volání do `UseCors` jakéhokoli jiného middlewaru, který používá CORS (například na místo `UseCors` před `UseAuthentication`, `UseAuthorization`a `UseEndpoints`).
* `IHostingEnvironment` Nahraďte `IWebHostEnvironment` `using` výrazem a přidejte příkaz pro <xref:Microsoft.Extensions.Hosting?displayProperty=fullName> obor názvů.
* `IApplicationLifetime` Nahraďte <xref:Microsoft.Extensions.Hosting.IHostApplicationLifetime> (<xref:Microsoft.Extensions.Hosting?displayProperty=fullName> oborem názvů).
* `EnvironmentName` Nahraďte <xref:Microsoft.Extensions.Hosting.Environments> (<xref:Microsoft.Extensions.Hosting?displayProperty=fullName> oborem názvů).

Následující kód je příkladem `Startup.Configure` typické aplikace ASP.NET Core 2,2:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();

    app.UseAuthentication();

    app.UseSignalR(hubs =>
    {
        hubs.MapHub<ChatHub>("/chat");
    });

    app.UseMvc(routes =>
    {
        routes.MapRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

Po aktualizaci předchozího `Startup.Configure` kódu:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();

    app.UseRouting();

    app.UseCors();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>("/chat");
        endpoints.MapControllerRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

> [!WARNING]
> Pro většinu aplikací `UseAuthentication`se volání, `UseAuthorization`a `UseCors` musí objevit mezi voláními `UseRouting` a `UseEndpoints` v platnosti.

### <a name="health-checks"></a>Kontroly stavu

Kontroly stavu používají směrování koncových bodů u obecného hostitele. V `Startup.Configure`nástroji zavolejte `MapHealthChecks` na tvůrce koncového bodu s adresou URL koncového bodu nebo relativní cestou:

```csharp
app.UseEndpoints(endpoints =>
{
    endpoints.MapHealthChecks("/health");
});
```

Koncové body kontrol stavu můžou:

* Zadejte minimálně jednoho povoleného hostitele nebo portů.
* Vyžadovat autorizaci.
* Vyžadovat CORS

Další informace naleznete v tématu <xref:host-and-deploy/health-checks>.

### <a name="security-middleware-guidance"></a>Doprovodné materiály k zabezpečení middlewaru

Podpora pro autorizaci a CORS je sjednocená v rámci přístupu [middlewaru](xref:fundamentals/middleware/index) . To umožňuje používat stejný middlewar a funkčnost v těchto scénářích. V této verzi je k dispozici aktualizovaný middleware autorizace a middleware CORS je vylepšený, aby bylo možné pochopit atributy používané řadiči MVC.

#### <a name="cors"></a>CORS

V minulosti mohlo být obtížné nakonfigurovat CORS. Middleware byl poskytnut pro použití v některých případech použití, ale filtry MVC byly určeny k použití **bez** middlewaru v jiných případech použití. U ASP.NET Core 3,0 doporučujeme, aby všechny aplikace, které vyžadují CORS, používaly middleware CORS v kombinaci s směrováním koncových bodů. `UseCors`dá se zadat s výchozí zásadou a `[EnableCors]` pomocí `[DisableCors]` atributů můžete v případě potřeby přepsat výchozí zásady.

V následujícím příkladu:

* U všech koncových bodů s `default` pojmenovanou zásadou je povolená CORS.
* `MyController` Třída zakáže CORS s `[DisableCors]` atributem.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseCors("default");

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[DisableCors]
public class MyController : ControllerBase
{
    ...
}
```

#### <a name="authorization"></a>Autorizace

V dřívějších verzích ASP.NET Core byla poskytnuta podpora autorizace prostřednictvím `[Authorize]` atributu. Autorizační middleware není k dispozici. V ASP.NET Core 3,0 se vyžaduje middleware autorizace. Doporučujeme umístit middleware autorizace ASP.NET Core (`UseAuthorization`) hned po. `UseAuthentication` Middleware autorizace se dá nakonfigurovat taky s výchozími zásadami, které se dají přepsat.

V ASP.NET Core 3,0 nebo novějším `UseAuthorization` se volá v `Startup.Configure`a následující `HomeController` vyžaduje přihlášeného uživatele:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

public class HomeController : Controller
{
    [Authorize]
    public IActionResult BuyWidgets()
    {
        ...
    }
}
```

Při použití směrování koncového bodu doporučujeme nakonfigurovat `<xref:Microsoft.AspNetCore.Mvc.Authorization.AuthorizeFilter>` a místo toho spoléhat na middleware autorizace.  Pokud aplikace používá `AuthorizeFilter` jako globální filtr v MVC, doporučujeme v volání metody refaktoring kódu, aby poskytovala zásady `AddAuthorization`.

`DefaultPolicy` Je zpočátku nakonfigurovaný tak, aby vyžadoval ověřování, takže se nevyžaduje žádná další konfigurace. V následujícím příkladu jsou koncové body MVC označeny jako `RequireAuthorization` tak, že všechny požadavky musí být autorizovány na základě `DefaultPolicy`. `HomeController` Povolit přístup bez přihlášení uživatele do aplikace je však z důvodu `[AllowAnonymous]`:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute().RequireAuthorization();
    });
}

[AllowAnonymous]
public class HomeController : Controller
{
    ...
}
```

### <a name="authorization-for-specific-endpoints"></a>Autorizace pro konkrétní koncové body

Autorizaci lze také nakonfigurovat pro konkrétní třídy koncových bodů. Následující kód je příkladem převodu aplikace MVC, která nakonfigurovala globální `AuthorizeFilter` aplikaci na aplikaci s konkrétní zásadou, která vyžaduje autorizaci:

[!code-csharp[](22-to-30/samples/Startup.cs?name=snippet&highlight=8-9,21-22,26-27,53-54)]

Zásady je také možné přizpůsobit. `DefaultPolicy` Je nakonfigurován tak, aby vyžadoval ověřování:

[!code-csharp[](22-to-30/samples/Startup2.cs?name=snippet&highlight=21-26,52)]

[!code-csharp[](22-to-30/samples/HomeController.cs?name=snippet)]

Alternativně lze všechny koncové body nakonfigurovat tak, aby vyžadovaly `RequireAuthorization` autorizaci bez `FallbackPolicy` `[Authorize]` nebo konfigurací. `FallbackPolicy` Se liší od `DefaultPolicy`. `DefaultPolicy` Spustí `[Authorize]` se nebo `RequireAuthorization`, když `FallbackPolicy` se aktivuje, když nejsou nastavené žádné jiné zásady. `FallbackPolicy`je zpočátku nakonfigurovaný tak, aby povoloval požadavky bez autorizace.

Následující příklad je stejný jako předchozí `DefaultPolicy` příklad, ale používá, `FallbackPolicy` aby vždy vyžadoval ověřování u všech koncových bodů s výjimkou případů, kdy `[AllowAnonymous]` je zadána:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    ...

    services.AddAuthorization(options =>
    {
        options.FallbackPolicy = new AuthorizationPolicyBuilder()
          .RequireAuthenticatedUser()
          .Build();
    });
}

public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[AllowAnonymous]
public class HomeController : Controller
{
    ...
}
```

Ověřování pomocí middlewaru funguje bez rozhraní, které má konkrétní znalosti o autorizaci. [Kontroly stavu](xref:host-and-deploy/health-checks) například nemají žádné konkrétní znalosti o autorizaci, ale kontroly stavu můžou mít konfigurovatelné zásady autorizace, které používá middleware.

Každý koncový bod navíc může přizpůsobit své autorizační požadavky. V `UseAuthorization` následujícím příkladu zpracovává autorizaci pomocí `DefaultPolicy`nástroje, ale koncový bod `/healthz` kontroly stavu vyžaduje `admin` uživatele:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints
            .MapHealthChecks("/healthz")
            .RequireAuthorization(new AuthorizeAttribute(){ Roles = "admin", });
    });
}
```

Ochrana je implementovaná pro některé scénáře. Middleware koncové body vyvolá výjimku, pokud se zásada autorizace nebo CORS z důvodu chybějícího middlewaru přeskočí. Podpora analyzátoru, která poskytuje další názory na neplatnou konfiguraci.

#### <a name="custom-authorization-handlers"></a>Vlastní obslužné rutiny autorizace

Pokud aplikace používá vlastní [obslužné rutiny autorizace](xref:security/authorization/policies#authorization-handlers), směrování koncového bodu předá obslužné rutině od MVC jiný typ prostředku. Obslužné rutiny, které očekávají, že prostředek kontextu obslužné rutiny autorizace mají typ <xref:Microsoft.AspNetCore.Mvc.Filters.AuthorizationFilterContext> (typ prostředku [poskytovaný filtry MVC](xref:security/authorization/policies#accessing-mvc-request-context-in-handlers)), se musí aktualizovat, aby se zpracovaly prostředky typu <xref:Microsoft.AspNetCore.Routing.RouteEndpoint> (typ prostředku, který se předala obslužným rutinám autorizace podle směrování koncových bodů).

MVC stále používá `AuthorizationFilterContext` prostředky, takže pokud aplikace používá AUTORIZAČNÍ filtry MVC spolu s autorizací směrování koncových bodů, může být nutné zpracovat oba typy prostředků.

### SignalR

Mapování SignalR Center se teď provádí v rámci `UseEndpoints`.

Namapujte každé centrum `MapHub`pomocí. Stejně jako v předchozích verzích je každé centrum výslovně uvedené.

V následujícím příkladu se přidá podpora `ChatHub` SignalR centra:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>();
    });
}
```

Pro řízení omezení velikosti zprávy od klientů je k dispozici nová možnost. Například v `Startup.ConfigureServices`:

```csharp
services.AddSignalR(hubOptions =>
{
    hubOptions.MaximumReceiveMessageSize = 32768;
});
```

V ASP.NET Core 2,2 můžete nastavit `TransportMaxBufferSize` a, které by účinně ovládají maximální velikost zprávy. V ASP.NET Core 3,0 Tato možnost nyní určuje pouze maximální velikost před nedodržením přítlaku.

### <a name="mvc-controllers"></a>Řadiče MVC

Mapování řadičů se teď provádí v rámci `UseEndpoints`.

Přidejte `MapControllers` , pokud aplikace používá směrování atributů. Vzhledem k tomu, že směrování zahrnuje podporu pro mnoho platforem v ASP.NET Core 3,0 nebo novějších, je přidání řadičů směrovaných k atributům výslovný souhlas.

Nahraďte následující:

* `MapRoute`řetězce`MapControllerRoute`
* `MapAreaRoute`řetězce`MapAreaControllerRoute`

Vzhledem k tomu, že směrování nyní zahrnuje podporu pro více než jen MVC, se terminologie změnila, aby tyto metody jasně zajistila, co dělají. Konvenční trasy, například `MapControllerRoute` / `MapAreaControllerRoute` / `MapDefaultControllerRoute` , jsou aplikovány v pořadí, v jakém byly přidány. Nejprve umístěte konkrétnější trasy (například trasy pro oblast).

V následujícím příkladu:

* `MapControllers`Přidá podporu pro řadiče směrované atributy.
* `MapAreaControllerRoute`Přidá konvenční trasu pro řadiče v oblasti.
* `MapControllerRoute`Přidá konvenční trasu pro řadiče.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapControllers();
        endpoints.MapAreaControllerRoute(
            "admin",
            "admin",
            "Admin/{controller=Home}/{action=Index}/{id?}");
        endpoints.MapControllerRoute(
            "default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

#### <a name="async-suffix-removal-from-controller-action-names"></a>Odebrání asynchronní přípony z názvů akcí kontroleru

V ASP.NET Core 3,0 ASP.NET Core MVC odstraní `Async` příponu z názvů akcí řadiče. Tato nová výchozí hodnota má vliv na generaci směrování i propojení. Příklad:

```csharp
public class ProductsController : Controller
{
    public async Task<IActionResult> ListAsync()
    {
        var model = await _dbContext.Products.ToListAsync();
        return View(model);
    }
}
```

Před ASP.NET Core 3,0:

* K předchozí akci může být přistup v trase *Products/ListAsync* .
* Vyžaduje se vytváření odkazů, `Async` které určuje příponu. Příklad:

    ```cshtml
    <a asp-controller="Products" asp-action="ListAsync">List</a>
    ```

V ASP.NET Core 3,0:

* Předchozí akce je k dispozici na trase *Products/List* .
* Generování propojení nevyžaduje zadání `Async` přípony. Příklad:

    ```cshtml
    <a asp-controller="Products" asp-action="List">List</a>
    ```

Tato změna nemá vliv na [`[ActionName]`](/dotnet/api/microsoft.aspnetcore.mvc.actionnameattribute) názvy zadané pomocí atributu. Výchozí chování lze zakázat pomocí následujícího kódu v `Startup.ConfigureServices`:

```csharp
services.AddMvc(options =>
    options.SuppressAsyncSuffixInActionNames = false);
```

#### <a name="changes-to-link-generation"></a>Změny při vytváření propojení

Jak je vysvětleno v dokumentaci k [rozdílům z dřívějších verzí směrování](xref:fundamentals/routing#differences-from-earlier-versions-of-routing), existují rozdíly v generování odkazů (například `Url.Link` pomocí a podobných rozhraní API). Mezi ně patří:

* Ve výchozím nastavení platí, že při použití směrování koncových bodů není velká a malá písmena parametrů trasy v generovaných identifikátorech URI nutně zachovaná. Toto chování lze řídit pomocí `IOutboundParameterTransformer` rozhraní.
* Generování identifikátoru URI pro neplatnou trasu (kontroler/akce nebo stránka, která neexistuje) vytvoří v rámci směrování koncového bodu prázdný řetězec místo vytvoření neplatného identifikátoru URI.
* Okolní hodnoty (parametry tras z aktuálního kontextu) se automaticky nepoužívají při vytváření odkazů s směrováním koncových bodů. Dříve při generování odkazu na jinou akci (nebo stránku) byly neurčené hodnoty tras odvozeny od hodnot okolí *aktuální* trasy. Při použití směrování koncového bodu musí být všechny parametry směrování explicitně zadané během generování propojení.

### <a name="razor-pages"></a>RazorStránky

Stránky Razor mapování teď probíhá uvnitř `UseEndpoints`.

Přidejte `MapRazorPages` , pokud aplikace používá Razor stránky. Vzhledem k tomu, že směrování koncových bodů zahrnuje podporu Razor pro spoustu platforem, je teď přihlášená možnost Přidat stránky.

V následující `Startup.Configure` metodě `MapRazorPages` přidá podporu pro Razor stránky:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapRazorPages();
    });
}
```

### <a name="use-mvc-without-endpoint-routing"></a>Použití MVC bez směrování koncových bodů

Použití MVC prostřednictvím `UseMvc` nebo `UseMvcWithDefaultRoute` v ASP.NET Core 3,0 vyžaduje explicitní výslovný souhlas v rámci `Startup.ConfigureServices`. To je nutné, protože MVC musí zjistit, jestli se může při inicializaci spoléhat na autorizaci a middleware CORS. K dispozici je analyzátor, který se upozorní, pokud se aplikace pokusí použít nepodporovanou konfiguraci.

Pokud aplikace vyžaduje starší `IRouter` verzi podpory, zakažte `EnableEndpointRouting` použití některého z následujících přístupů v `Startup.ConfigureServices`nástroji:

```csharp
services.AddMvc(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllers(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllersWithViews(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddRazorPages().AddMvcOptions(options => options.EnableEndpointRouting = false);
```

### <a name="health-checks"></a>Kontroly stavu

Kontroly stavu lze použít jako *směrovač* s směrováním koncových bodů.

Přidejte `MapHealthChecks` k použití kontrol stavu pomocí směrování koncových bodů. `MapHealthChecks` Metoda přijímá argumenty podobné `UseHealthChecks`. Výhodou použití `MapHealthChecks` funkce Over `UseHealthChecks` je možnost použít autorizaci a mít větší jemně odstupňovanou kontrolu nad zásadami pro porovnání.

V následujícím příkladu `MapHealthChecks` je volána pro koncový bod kontroly stavu v `/healthz`:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHealthChecks("/healthz", new HealthCheckOptions() { });
    });
}
```

<a name="hostb"></a>

## <a name="hostbuilder-replaces-webhostbuilder"></a>HostBuilder nahrazuje WebHostBuilder

Šablony ASP.NET Core 3,0 používají [obecného hostitele](xref:fundamentals/host/generic-host). Předchozí verze používaly [webového hostitele](xref:fundamentals/host/web-host). Následující kód ukazuje třídu vygenerovanou `Program` šablonou ASP.NET Core 3,0:

[!code-csharp[](22-to-30/samples/Program.cs?name=snippet)]

Následující kód ukazuje třídu vygenerovanou `Program` šablonou ASP.NET Core 2,2:

[!code-csharp[](22-to-30/samples/Program2.2.cs?name=snippet)]

<xref:Microsoft.AspNetCore.Hosting.IWebHostBuilder>zůstává v 3,0 a je typ `webBuilder` zobrazený v předchozí ukázce kódu. <xref:Microsoft.AspNetCore.Hosting.WebHostBuilder>bude zastaralá v budoucí verzi a nahrazena nástrojem `HostBuilder`.

Nejvýznamnější změna z `WebHostBuilder` na `HostBuilder` je v [vkládání závislostí (di)](xref:fundamentals/dependency-injection). Při použití `HostBuilder`nástroje lze vložit do `Startup`konstruktoru pouze následující:

* <xref:Microsoft.Extensions.Configuration.IConfiguration>
* <xref:Microsoft.Extensions.Hosting.IHostEnvironment>
* <xref:Microsoft.AspNetCore.Hosting.IWebHostEnvironment>

Omezení `HostBuilder` di:

* Povolí sestavení kontejneru DI jenom jednou.
* Předejde výsledným problémům životního cyklu objektů, jako je například řešení více instancí singleton.

Další informace najdete v tématu [předcházení vkládání spouštěcích služeb v ASP.NET Core 3](https://andrewlock.net/avoiding-startup-service-injection-in-asp-net-core-3/).

## <a name="addauthorization-moved-to-a-different-assembly"></a>AddAuthorization přesunuté do jiného sestavení

ASP.NET Core 2,2 a nižší `AddAuthorization` metody v souboru *Microsoft. AspNetCore. Authorization. dll*:

* Bylo přejmenováno `AddAuthorizationCore`.
* Byly přesunuty do souboru *Microsoft. AspNetCore. Authorization. Policy. dll*.

Aplikace používající *Microsoft. AspNetCore. Authorization. dll* a *Microsoft. AspNetCore. Authorization. Policy. dll* nejsou ovlivněny.

Aplikace, které nepoužívají *Microsoft. AspNetCore. Authorization. Policy. dll* , by měly provádět jednu z následujících akcí:

* Přidejte odkaz na *Microsoft. AspNetCore. Authorization. Policy. dll*. Tento přístup je vhodný pro většinu aplikací a je nutný.
* Přepnout na použití`AddAuthorizationCore`

Další informace naleznete v tématu zásadní [Změna v `AddAuthorization(o =>`) přetížení života v jiném sestavení #386](https://github.com/aspnet/Announcements/issues/386).

## <a name="identity-ui"></a>IdentityROZHRANÍ

IdentityAktualizace uživatelského rozhraní pro ASP.NET Core 3,0:

* Přidat odkaz na balíček do [Microsoft. AspNetCore.Identity. Uživatelské rozhraní](https://nuget.org/packages/Microsoft.AspNetCore.Identity.UI).
* Aplikace, které nepoužívají Razor stránky, `MapRazorPages`musí volat. Zobrazit [ Razor stránky](#razor-pages) v tomto dokumentu.
* Výchozí architektura uživatelského rozhraní je Bootstrap 4. Nastavte vlastnost `IdentityUIFrameworkVersion` projektu, aby se změnila výchozí hodnota. Další informace najdete v [tomto oznámení GitHubu](https://github.com/aspnet/Announcements/issues/380).

## SignalR

Klient SignalR jazyka JavaScript se změnil z `@aspnet/signalr` na `@microsoft/signalr`. Chcete-li tuto změnu reagovat, změňte odkazy v příkazech *Package. JSON* , `require` Statements a `import` ECMAScript.

### <a name="systemtextjson-is-the-default-protocol"></a>System. text. JSON je výchozí protokol.

`System.Text.Json`je teď výchozím protokolem rozbočovače používaným klientem i serverem.

V `Startup.ConfigureServices`nástroji zavolejte `AddJsonProtocol` na nastavit možnosti serializátoru.

**WebServer**

```csharp
services.AddSignalR(...)
        .AddJsonProtocol(options =>
        {
            options.PayloadSerializerOptions.WriteIndented = false;
        })
```

**Služba**

```csharp
new HubConnectionBuilder()
    .WithUrl("/chatHub")
    .AddJsonProtocol(options =>
    {
        options.PayloadSerializerOptions.WriteIndented = false;
    })
    .Build();
```

### <a name="switch-to-newtonsoftjson"></a>Přepnout na Newtonsoft. JSON

Pokud používáte [funkce Newtonsoft. JSON, které nejsou podporované v System. text. JSON](/dotnet/standard/serialization/system-text-json-migrate-from-newtonsoft-how-to), můžete přejít zpátky na `Newtonsoft.Json`. Viz [použití Newtonsoft. JSON v projektu ASP.NET Core 3,0 SignalR ](#use-newtonsoftjson-in-an-aspnet-core-30-signalr-project) výše v tomto článku.

## <a name="redis-distributed-caches"></a>Redis distribuované mezipaměti

Balíček [Microsoft. Extensions. Caching. Redis](https://www.nuget.org/packages/Microsoft.Extensions.Caching.Redis) není dostupný pro aplikace ASP.NET Core 3,0 nebo novější. Nahraďte odkaz na balíček příponou [Microsoft. Extensions. Caching. StackExchangeRedis](https://www.nuget.org/packages/Microsoft.Extensions.Caching.StackExchangeRedis). Další informace naleznete v tématu <xref:performance/caching/distributed>.

## <a name="opt-in-to-runtime-compilation"></a>Přihlásit se ke kompilaci za běhu

Před ASP.NET Core 3,0 byla kompilace zobrazení běhového prostředí implicitní funkcí rozhraní. Kompilace za běhu doplňuje kompilaci zobrazení v době sestavení. Umožňuje rozhraní kompilovat Razor zobrazení a stránky (soubory *. cshtml* ) při změně souborů, aniž by bylo nutné znovu sestavit celou aplikaci. Tato funkce podporuje scénář pro rychlé úpravy v integrovaném vývojovém prostředí (IDE) a aktualizaci prohlížeče pro zobrazení změn.

V ASP.NET Core 3,0 je kompilace modulu runtime v případě výslovného souhlasu. Kompilace při sestavení je jediným mechanismem pro zobrazení kompilace, která je ve výchozím nastavení povolená. Modul runtime spoléhá na aplikaci Visual Studio nebo [dotnet – Sledujte](xref:tutorials/dotnet-watch) v Visual Studio Code pro opětovné sestavení projektu, když detekuje změny souborů *. cshtml* . V aplikaci Visual Studio se změny v souborech *. cs*, *. cshtml*nebo *. Razor* v projektu spouštějí (<kbd>CTRL + F5</kbd>), ale ne laděné (<kbd>F5</kbd>), spusťte opětovnou kompilaci projektu.

Povolení kompilace za běhu v projektu ASP.NET Core 3,0:

1. Nainstalujte [Microsoft. AspNetCore. Mvc.Razor. ](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation)Balíček NuGet RuntimeCompilation
1. Aktualizovat `Startup.ConfigureServices` volání `AddRazorRuntimeCompilation`:

    Pro ASP.NET Core MVC použijte následující kód:

    ```csharp
    services.AddControllersWithViews()
        .AddRazorRuntimeCompilation(...);
    ```
 
    Pro ASP.NET Core Razor stránky použijte následující kód:
 
    ```csharp
    services.AddRazorPages()
        .AddRazorRuntimeCompilation(...);
    ```
 
Ukázka v https://github.com/aspnet/samples/tree/master/samples/aspnetcore/mvc/runtimecompilation ukazuje příklad povolení běhové kompilace podmíněně ve vývojových prostředích.

Další informace o Razor kompilaci souborů naleznete v tématu <xref:mvc/views/view-compilation>.

## <a name="migrate-libraries-via-multi-targeting"></a>Migrace knihoven přes cílení na více platforem

Knihovny často potřebují podporovat více verzí ASP.NET Core. Většina knihoven kompilovaných pro předchozí verze ASP.NET Core by měla pokračovat bez problémů. Následující podmínky vyžadují křížové kompilování aplikace:

* Knihovna se spoléhá na funkci, která má binární zásadní [změnu](#breaking-api-changes).
* Knihovna chce využívat nové funkce v ASP.NET Core 3,0. 

Příklad:

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFrameworks>netcoreapp3.0;netstandard2.0</TargetFrameworks>
  </PropertyGroup>

  <ItemGroup Condition="'$(TargetFramework)' == 'netcoreapp3.0'">
    <FrameworkReference Include="Microsoft.AspNetCore.App" />
  </ItemGroup>

  <ItemGroup Condition="'$(TargetFramework)' == 'netstandard2.0'">
    <PackageReference Include="Microsoft.AspNetCore" Version="2.1.0" />
  </ItemGroup>
</Project>
```

Použijte `#ifdefs` k povolení rozhraní API specifických pro ASP.NET Core 3,0:

```csharp
var webRootFileProvider =
#if NETCOREAPP3_0
    GetRequiredService<IWebHostEnvironment>().WebRootFileProvider;
#elif NETSTANDARD2_0
    GetRequiredService<IHostingEnvironment>().WebRootFileProvider;
#else
#error unknown target framework
#endif
```

Další informace o použití rozhraní API ASP.NET Core v knihovně tříd naleznete v tématu <xref:fundamentals/target-aspnetcore>.

## <a name="miscellaneous-changes"></a>Různé změny

Systém ověřování v .NET Core 3,0 a novějším zpracovává parametry bez hodnoty null nebo vázané vlastnosti, jako kdyby měl `[Required]` atribut. Další informace naleznete v tématu [[required] Attribute](xref:mvc/models/validation?view=aspnetcore-3.1#required-attribute).

### <a name="publish"></a>Publikování

Odstraňte složky *bin* a *obj* v adresáři projektu.

## <a name="testserver"></a>TestServer

U aplikací, které <xref:Microsoft.AspNetCore.TestHost.TestServer> se používají přímo u [obecného hostitele](xref:fundamentals/host/web-host), vytvořte `TestServer` <xref:Microsoft.AspNetCore.Hosting.IWebHostBuilder> v nástroji <xref:Microsoft.Extensions.Hosting.GenericHostWebHostBuilderExtensions.ConfigureWebHost%2A>:

```csharp
[Fact]
public async Task GenericCreateAndStartHost_GetTestServer()
{
    using var host = await new HostBuilder()
        .ConfigureWebHost(webBuilder =>
        {
            webBuilder
                .UseTestServer()
                .Configure(app => { });
        })
    .StartAsync();

    var response = await host.GetTestServer().CreateClient().GetAsync("/");

    Assert.Equal(HttpStatusCode.NotFound, response.StatusCode);
}
```

<a name="break"></a>

## <a name="breaking-api-changes"></a>Přerušení změn rozhraní API

Kontrola nejnovějších změn:

* [Úplný seznam nejnovějších změn v ASP.NET Core vydání 3,0](https://github.com/aspnet/Announcements/issues?page=1&q=is%3Aissue+is%3Aopen+label%3A%22Breaking+change%22+label%3A3.0.0)
* [Rušení změn rozhraní API v antipadělání, CORS, diagnostice, MVC a směrování](https://github.com/aspnet/Announcements/issues/387). Tento seznam obsahuje zásadní změny pro přepínače kompatibility.
* Shrnutí 2,2-až 3,0 přerušující změny v rámci .NET Core, ASP.NET Core a Entity Framework Core najdete v tématu [přerušující změny migrace z verze 2,2 na 3,0](/dotnet/core/compatibility/2.2-3.0).

## <a name="endpoint-routing-with-catch-all-parameter"></a>Směrování koncového bodu s parametrem catch-All

[!INCLUDE[](~/includes/catchall.md)]

## <a name="net-core-30-on-azure-app-service"></a>.NET Core 3,0 na Azure App Service

Zavedení .NET Core do Azure App Service je dokončené. .NET Core 3,0 je k dispozici ve všech datových centrech Azure App Service.
