---
title: Migrace z ASP.NET Core 2,2 na 3,0
author: rick-anderson
description: Přečtěte si, jak migrovat projekt ASP.NET Core 2,2 do ASP.NET Core 3,0.
ms.author: riande
ms.custom: mvc
ms.date: 09/24/2019
uid: migration/22-to-30
ms.openlocfilehash: 0c1aee2c5be0687ed9e9ed88a2999ce2494d5da3
ms.sourcegitcommit: fae6f0e253f9d62d8f39de5884d2ba2b4b2a6050
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 09/25/2019
ms.locfileid: "71256168"
---
# <a name="migrate-from-aspnet-core-22-to-30"></a>Migrace z ASP.NET Core 2,2 na 3,0

[Scottem Addie](https://github.com/scottaddie) a [Rick Anderson](https://twitter.com/RickAndMSFT)

Tento článek vysvětluje, jak aktualizovat existující projekt ASP.NET Core 2,2 na ASP.NET Core 3,0.

## <a name="prerequisites"></a>Požadavky

# <a name="visual-studiotabvisual-studio"></a>[Visual Studio](#tab/visual-studio)

[!INCLUDE[](~/includes/net-core-prereqs-vs-3.0.md)]

# <a name="visual-studio-codetabvisual-studio-code"></a>[Visual Studio Code](#tab/visual-studio-code)

[!INCLUDE[](~/includes/net-core-prereqs-vsc-3.0.md)]

# <a name="visual-studio-for-mactabvisual-studio-mac"></a>[Visual Studio pro Mac](#tab/visual-studio-mac)

[!INCLUDE[](~/includes/net-core-prereqs-mac-3.0.md)]

---

## <a name="update-the-project-file"></a>Aktualizovat soubor projektu

### <a name="update-the-target-framework"></a>Aktualizace cílového rozhraní .NET Framework

ASP.NET Core 3.0 a novější poběží jenom na platformě .NET Core. Nastavte [moniker cílového rozhraní .NET Framework (TFM)](/dotnet/standard/frameworks) na `netcoreapp3.0`:

```xml
  <TargetFramework>netcoreapp3.0</TargetFramework>
```

### <a name="remove-obsolete-package-references"></a>Odebrat zastaralé odkazy na balíčky

ASP.NET Core už nevytváří velký počet funkcí balíčků NuGet. Tyto odkazy na balíčky by měly být odebrány ze souboru projektu. Úplný seznam balíčků, které už nejsou vyráběné, najdete níže:

<details>
    <summary>Kliknutím sem rozbalíte seznam balíčků, které už nejsou vyráběny.</summary>

    * Microsoft.AspNetCore
    * Microsoft.AspNetCore.All
    * Microsoft.AspNetCore.App
    * Microsoft. AspNetCore. antipadělání
    * Microsoft. AspNetCore. Authentication
    * Microsoft. AspNetCore. Authentication. abstrakce
    * Microsoft. AspNetCore. Authentication. cookies
    * Microsoft. AspNetCore. Authentication. Core
    * Microsoft. AspNetCore. Authentication. JwtBearer
    * Microsoft. AspNetCore. Authentication. OAuth
    * Microsoft. AspNetCore. Authentication. OpenIdConnect
    * Microsoft. AspNetCore. Authorization
    * Microsoft. AspNetCore. Authorization. Policy
    * Microsoft. AspNetCore. CookiePolicy
    * Microsoft. AspNetCore. Cors
    * Microsoft. AspNetCore. Cryptography. Internal
    * Odvození od společnosti Microsoft. AspNetCore. Cryptography.
    * Microsoft.AspNetCore.DataProtection
    * Microsoft. AspNetCore. DataProtection. abstrakce
    * Microsoft. AspNetCore. DataProtection. Extensions
    * Microsoft. AspNetCore. Diagnostics
    * Microsoft. AspNetCore. Diagnostics. HealthChecks
    * Microsoft.AspNetCore.HostFiltering
    * Microsoft.AspNetCore.Hosting
    * Microsoft. AspNetCore. Hosting. abstrakce
    * Microsoft. AspNetCore. Hosting. Server. abstrakce
    * Microsoft. AspNetCore. http
    * Microsoft. AspNetCore. http. abstrakce
    * Microsoft. AspNetCore. http. Connections
    * Microsoft. AspNetCore. http. Extensions
    * Microsoft. AspNetCore. http. Features
    * Microsoft. AspNetCore. HttpOverrides
    * Microsoft. AspNetCore. HttpsPolicy
    * Microsoft. AspNetCore. identity
    * Microsoft. AspNetCore. Localization
    * Microsoft. AspNetCore. Localization. Routing
    * Microsoft. AspNetCore. MiddlewareAnalysis
    * Microsoft.AspNetCore.Mvc
    * Microsoft. AspNetCore. Mvc. abstrakce
    * Microsoft. AspNetCore. Mvc. Analyzers
    * Microsoft. AspNetCore. Mvc. ApiExplorer
    * Microsoft. AspNetCore. Mvc. API. Analyzers
    * Microsoft. AspNetCore. Mvc. Core
    * Microsoft. AspNetCore. Mvc. Cors
    * Microsoft. AspNetCore. Mvc. DataAnnotations
    * Microsoft. AspNetCore. Mvc. formátovací modul. JSON
    * Microsoft. AspNetCore. Mvc. formátovací modul. XML
    * Microsoft. AspNetCore. Mvc. Localization
    * Microsoft.AspNetCore.Mvc.Razor
    * Microsoft. AspNetCore. Mvc. Razor. Extensions
    * Microsoft. AspNetCore. Mvc. Razor. ViewCompilation
    * Microsoft. AspNetCore. Mvc. RazorPages
    * Microsoft. AspNetCore. Mvc. TagHelpers
    * Microsoft. AspNetCore. Mvc. ViewFeatures
    * Microsoft. AspNetCore. Razor
    * Microsoft. AspNetCore. Razor. Runtime
    * Microsoft. AspNetCore. Razor. Design
    * Microsoft. AspNetCore. ResponseCaching
    * Microsoft. AspNetCore. ResponseCaching. abstrakce
    * Microsoft. AspNetCore. ResponseCompression
    * Microsoft. AspNetCore. Rewrite
    * Microsoft.AspNetCore.Routing
    * Microsoft. AspNetCore. Routing. Abstracts
    * Microsoft. AspNetCore. Server. HttpSys
    * Microsoft. AspNetCore. Server. IIS
    * Microsoft. AspNetCore. Server. IISIntegration
    * Microsoft. AspNetCore. Server. Kestrel
    * Microsoft. AspNetCore. Server. Kestrel. Core
    * Microsoft. AspNetCore. Server. Kestrel. https
    * Microsoft. AspNetCore. Server. Kestrel. Transports. abstrakce
    * Microsoft. AspNetCore. Server. Kestrel. Transport. Sockets
    * Microsoft. AspNetCore. Session
    * Microsoft. AspNetCore. Signal
    * Microsoft. AspNetCore. Signaler. Core
    * Microsoft.AspNetCore.StaticFiles
    * Microsoft. AspNetCore. WebSockets
    * Microsoft. AspNetCore. webutilities
    * Microsoft.Net. http. Headers</details>

### <a name="framework-reference"></a>Odkaz na rozhraní

Funkce ASP.NET Core, které byly k dispozici prostřednictvím jednoho z výše uvedených balíčků, jsou k dispozici `Microsoft.AspNetCore.App` jako součást sdíleného rozhraní.  *Sdílené rozhraní* je sada sestavení (soubory *. dll* ), které jsou nainstalovány na počítači a zahrnují komponentu modulu runtime a sadu targeting pack. Další informace najdete v tématu [sdílené rozhraní](https://natemcmaster.com/blog/2018/08/29/netcore-primitives-2/).


* Projekty, které cílí `Microsoft.NET.Sdk.Web` na sadu SDK, implicitně odkazují na `Microsoft.AspNetCore.App` rozhraní.

Pro tyto projekty nejsou vyžadovány žádné další odkazy:

```xml
<Project Sdk="Microsoft.NET.Sdk.Web">
  <PropertyGroup>
    <TargetFramework>netcoreapp3.0</TargetFramework>
  </PropertyGroup>
    ...
</Project>
```

* Projekty, které `Microsoft.NET.Sdk` cílí `Microsoft.NET.Sdk.Razor` na sadu SDK, by měly `FrameworkReference` přidat `Microsoft.AspNetCore.App`explicitní pro:

```xml
<Project Sdk="Microsoft.NET.Sdk.Razor">
  <PropertyGroup>
    <TargetFramework>netcoreapp3.0</TargetFramework>
  </PropertyGroup>

  <ItemGroup>
    <FrameworkReference Include="Microsoft.AspNetCore.App" />
  </ItemGroup>
    ...
</Project>
```

### <a name="add-package-references-for-removed-assemblies"></a>Přidat odkazy na balíčky pro odebraná sestavení

ASP.NET Core 3,0 odstraní některá sestavení, která byla dříve součástí odkazu `Microsoft.AspNetCore.App` na balíček. Chcete-li pokračovat v používání funkcí poskytovaných těmito sestaveními, odkazujte na verze 3,0 odpovídajících balíčků:

* Další &ndash; informace https://docs.microsoft.com/ef/core/providers/index o tom, jak odkazovat na balíček pro konkrétního poskytovatele databáze, najdete v Entity Framework Core.

* Uživatelské rozhraní identity

  Podporu [uživatelského rozhraní identity](xref:security/authentication/identity) lze přidat odkazem na balíček [Microsoft. AspNetCore. identity. UI](https://www.nuget.org/packages/Microsoft.AspNetCore.Identity.UI) .

* Služby SPA
  * [Microsoft. AspNetCore. SpaServices](https://www.nuget.org/packages/Microsoft.AspNetCore.SpaServices)
  * [Microsoft. AspNetCore. SpaServices. Extensions](https://www.nuget.org/packages/Microsoft.AspNetCore.SpaServices.Extensions)

* Podpora &ndash; ověřování pro toky ověřování třetích stran je k dispozici jako balíčky NuGet:

  * Facebook OAuth ([Microsoft. AspNetCore. Authentication. Facebook](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Facebook))
  * Google OAuth ([Microsoft. AspNetCore. Authentication. Google](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Google))
  * Token nosiče OpenID Connect ([Microsoft. AspNetCore. Authentication. JwtBearer](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.JwtBearer))
  * Ověřování účtu Microsoft ([Microsoft. AspNetCore. Authentication. MicrosoftAccount](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.MicrosoftAccount))
  * OpenID Connect Authentication ([Microsoft. AspNetCore. Authentication. OpenIdConnect](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.OpenIdConnect))
  * Twitter OAuth ([Microsoft. AspNetCore. Authentication. Twitter](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Twitter))
  * Ověřování WsFederation ([Microsoft. AspNetCore. Authentication. WsFederation](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.WsFederation))

* Podpora formátování a vyjednávání obsahu pro `System.Net.HttpClient` &ndash; balíček NuGet [Microsoft. ASPNET. WebApi. Client](https://www.nuget.org/packages/Microsoft.AspNet.WebApi.Client/) poskytuje `System.Net.HttpClient` `ReadAsAsync`užitečné rozšíření pro rozhraní API, `PostJsonAsync` například atd.

* Podpora kompilace &ndash; Razor runtime pro kompilaci za běhu zobrazení a stránek je teď součástí [Microsoft. AspNetCore. Mvc. Razor. RuntimeCompilation](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation).

* Podpora `Newtonsoft.Json` MVC &ndash; podpory pro použití MVC se `Newtonsoft.Json` teď nachází v části [Microsoft. AspNetCore. Mvc. NewtonsoftJson](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson).

### <a name="analyzer-support"></a>Podpora analyzátoru

* Projekty, které `Microsoft.NET.Sdk.Web` cílí na implicitně referenční analyzátory dříve dodávané jako součást balíčku [Microsoft. AspNetCore. Mvc. analyzers](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Analyzers/) . K povolení těchto kroků nejsou vyžadovány žádné další odkazy.

* Pokud vaše aplikace používá [analyzátory rozhraní API](xref:web-api/advanced/analyzers) dříve dodávané pomocí balíčku [Microsoft. AspNetCore. Mvc. API. analyzers](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Api.Analyzers/) , upravte soubor projektu tak, aby odkazoval na analyzátory dodávané jako součást sady .NET Core web SDK:

```xml
<Project Sdk="Microsoft.NET.Sdk.Web">
  <PropertyGroup>
    <TargetFramework>netcoreapp3.0</TargetFramework>
    <IncludeOpenAPIAnalyzers>true</IncludeOpenAPIAnalyzers>
  </PropertyGroup>

  ...
</Project>
```

### <a name="razor-class-library"></a>Knihovna tříd Razor

Projekty knihovny tříd Razor, které poskytují komponenty uživatelského rozhraní pro MVC, `AddRazorSupportForMvc` musí nastavit vlastnost v souboru projektu:

```xml
<PropertyGroup>
  <AddRazorSupportForMvc>true</AddRazorSupportForMvc>
</PropertyGroup>
```

### <a name="in-process-hosting-model"></a>Model hostování v procesu

* Projekty jsou ve výchozím nastavení pro [model hostování v rámci procesu](xref:host-and-deploy/aspnet-core-module#in-process-hosting-model) v ASP.NET Core 3,0 nebo novějším. Případně můžete odebrat `<AspNetCoreHostingModel>` vlastnost v souboru projektu, pokud je `InProcess`její hodnota.

## <a name="kestrel"></a>Kestrel

### <a name="configuration"></a>Konfigurace

Migruje konfiguraci Kestrel do Tvůrce webového hostitele, který `ConfigureWebHostDefaults` poskytuje (*program.cs*):

```csharp
public static IHostBuilder CreateHostBuilder(string[] args) =>
    Host.CreateDefaultBuilder(args)
        .ConfigureWebHostDefaults(webBuilder =>
        {
            webBuilder.ConfigureKestrel(serverOptions =>
            {
                // Set properties and call methods on options
            })
            .UseStartup<Startup>();
        });
```

Pokud aplikace vytvoří hostitele ručně pomocí `HostBuilder`, zavolejte `UseKestrel` na tvůrce webového hostitele v `ConfigureWebHostDefaults`:

```csharp
public static void Main(string[] args)
{
    var host = new HostBuilder()
        .UseContentRoot(Directory.GetCurrentDirectory())
        .ConfigureWebHostDefaults(webBuilder =>
        {
            webBuilder.UseKestrel(serverOptions =>
            {
                // Set properties and call methods on options
            })
            .UseIISIntegration()
            .UseStartup<Startup>();
        })
        .Build();

    host.Run();
}
```

### <a name="connection-middleware-replaces-connection-adapters"></a>Middleware připojení nahrazuje adaptéry připojení

Připojovací adaptéry (<xref:Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.IConnectionAdapter>) byly odebrány z Kestrel. Nahraďte připojovací adaptéry pomocí middleware připojení. Middleware připojení se podobá middlewaru protokolu HTTP v kanálu ASP.NET Core, ale pro připojení nižší úrovně. Protokol HTTPS a protokolování připojení:

* Byly přesunuty z připojovacích adaptérů na middleware připojení.
* Tyto metody rozšíření fungují jako v předchozích verzích ASP.NET Core. 

Další informace najdete v [příkladu TlsFilterConnectionHandler v části ListenOptions. Protocols článku Kestrel](/aspnet/core/fundamentals/servers/kestrel?view=aspnetcore-3.0#listenoptionsprotocols).

### <a name="transport-abstractions-moved-and-made-public"></a>Přemístění a zpřístupnění abstrakcí přenosu

Přenosová vrstva Kestrel byla vystavena jako veřejné rozhraní v `Connections.Abstractions`. Jako součást těchto aktualizací:

* `Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions`a přidružené typy byly odebrány.
* <xref:Microsoft.AspNetCore.Server.Kestrel.KestrelServerOptions.NoDelay>byl přesunut z <xref:Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions> na možnosti přenosu.
* <xref:Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions.Internal.SchedulingMode>bylo odebráno <xref:Microsoft.AspNetCore.Server.Kestrel.KestrelServerOptions>z.

Další informace najdete v následujících materiálech GitHubu:

* [Abstrakce sítě klienta/serveru (ASPNET/AspNetCore #10308)](https://github.com/aspnet/AspNetCore/issues/10308)
* [Implementujte nové abstrakce naslouchacího procesu Bedrock a Kestrel znovu platně (ASPNET/AspNetCore #10321)](https://github.com/aspnet/AspNetCore/pull/10321)

### <a name="kestrel-request-trailer-headers"></a>Hlavičky přípojných vozidel žádosti Kestrel

Pro aplikace, které cílí na starší verze ASP.NET Core:

* Kestrel přidá hlavičky přípojného bodu HTTP/1.1 do kolekce hlaviček požadavků.
* Po načtení textu žádosti na konec jsou k dispozici Přípojná místa.

To způsobuje některé obavy z nejednoznačnosti mezi hlavičkami a přípojnými vozidly, takže přípojná vozidla byla přesunuta do nové kolekce (`RequestTrailerExtensions`) v 3,0.

Přívěsy žádostí HTTP/2 jsou:

* Není k dispozici v ASP.NET Core 2,2.
* K dispozici v `RequestTrailerExtensions`3,0 jako.

Pro přístup k těmto přípojným vozidlům jsou k dispozici nové metody rozšíření žádosti. Stejně jako v případě protokolu HTTP/1.1 jsou po načtení textu žádosti na konec k dispozici Přípojná místa.

Pro vydání 3,0 jsou k dispozici `RequestTrailerExtensions` následující metody:

* `GetDeclaredTrailers`Načte hlavičku žádosti `Trailer` , která zobrazí seznam přípojných vozidel, která se mají po tělo očekávat. &ndash;
* `SupportsTrailers`&ndash; Určuje, zda požadavek podporuje příjem hlaviček přípojných vozidel.
* `CheckTrailersAvailable`&ndash; Kontroluje, zda požadavek podporuje Přípojná místa a zda jsou k dispozici pro čtení. Tato kontrolu nepředpokládá, že existuje přívěsy ke čtení. Není možné, aby bylo možné číst bez přípojných míst, i když `true` je tato metoda vrácena.
* `GetTrailer`&ndash; Získá požadovanou ukončovací hlavičku z odpovědi. Před voláním `GetTrailer` nebo<xref:System.NotSupportedException> se může vyskytnout, pokud požadavek nepodporuje koncové hlavičky. `SupportsTrailers`

Další informace najdete v tématu [o umístění přípojných vozidel v samostatné kolekci (ASPNET/AspNetCore #10410)](https://github.com/aspnet/AspNetCore/pull/10410).

### <a name="allowsynchronousio-disabled"></a>AllowSynchronousIO zakázané

`AllowSynchronousIO`povoluje nebo zakazuje synchronní rozhraní API pro `HttpRequest.Body.Read`vstupně-výstupní operace, například, `HttpResponse.Body.Write`a `Stream.Flush`. Tato rozhraní API jsou zdrojem vyčerpání vláken, který vede k selhání aplikace. V 3,0 `AllowSynchronousIO` je ve výchozím nastavení zakázáno. Další informace najdete [v části synchronní v/v v článku Kestrel](/aspnet/core/fundamentals/servers/kestrel?view=aspnetcore-3.0#synchronous-io).

Kromě toho, že `AllowSynchronousIO` je `ConfigureKestrel`možné povolit s možnostmi, je možné synchronní vstupně-výstupní operace v jednotlivých žádostech přepsat jako dočasné zmírnění:

```csharp
var syncIOFeature = HttpContext.Features.Get<IHttpBodyControlFeature>();

if (syncIOFeature != null)
{
    syncIOFeature.AllowSynchronousIO = true;
}
```

Pokud máte problémy s <xref:System.IO.TextWriter> implementacemi nebo jinými datovými proudy, které volají synchronní rozhraní API v <xref:System.IO.Stream.DisposeAsync*> [Dispose](/dotnet/standard/garbage-collection/implementing-dispose), zavolejte místo toho nové rozhraní API.

Další informace najdete v tématu [[oznámení] AllowSynchronousIO zakázáno na všech serverech (ASPNET/AspNetCore #7644)](https://github.com/aspnet/AspNetCore/issues/7644).

### <a name="microsoftaspnetcoreserverkestrelhttps-assembly-removed"></a>Bylo odebráno sestavení Microsoft. AspNetCore. Server. Kestrel. https.

V ASP.NET Core 2,1 se obsah souboru *Microsoft. AspNetCore. Server. Kestrel. https. dll* přesunul do souboru *Microsoft. AspNetCore. Server. Kestrel. Core. dll*. Toto byla neprůlomová aktualizace pomocí `TypeForwardedTo` atributů. Pro 3,0 byla odebrána prázdná sestavení *Microsoft. AspNetCore. Server. Kestrel. https. dll* (a balíček NuGet).

Knihovny odkazující na [Microsoft. AspNetCore. Server. Kestrel. https](https://www.nuget.org/packages/Microsoft.AspNetCore.Server.Kestrel.Https) by měly aktualizovat ASP.NET Core závislosti na 2,1 nebo novější.

Aplikace a knihovny cílené na ASP.NET Core 2,1 nebo novější by měly odebrat všechny přímé odkazy na balíček [Microsoft. AspNetCore. Server. Kestrel. https](https://www.nuget.org/packages/Microsoft.AspNetCore.Server.Kestrel.Https) .

## <a name="jsonnet-support"></a>Podpora Json.NET

Jako součást práce pro [zlepšení ASP.NET Core sdílené architektury](https://blogs.msdn.microsoft.com/webdev/2018/10/29/a-first-look-at-changes-coming-in-asp-net-core-3-0/)se [JSON.NET](https://www.newtonsoft.com/json/help/html/Introduction.htm) z ASP.NET Core sdílené architektury odebral.

Výchozí hodnota pro ASP.NET Core je Now [System. text. JSON](/dotnet/api/system.text.json?view=netcore-3.0), která je v .net Core 3,0 novinkou. Zvažte použití `System.Text.Json` , pokud je to možné. Je to vysoký výkon a nevyžaduje další závislost knihovny. Jelikož `System.Text.Json` je však novinkou, může v současnosti chybět funkce, které vaše aplikace potřebuje.

Vaše aplikace může vyžadovat `Netwtonsoft.Json` integraci, pokud používá `Newtonsoft.Json`funkci specifickou, jako je JsonPatch nebo převaděče, nebo pokud [formátují](xref:web-api/advanced/formatting) `Newtonsoft.Json`konkrétní typy.

Pokud chcete používat Json.NET v projektu nástroje ASP.NET Core 3,0, přečtěte si téma [Přepnutí na Newtonsoft. JSON](#switch-to-newtonsoftjson) v tomto dokumentu.

Použití Json.NET v projektu ASP.NET Core 3,0:

* Přidejte odkaz na balíček [Microsoft. AspNetCore. Mvc. NewtonsoftJson](https://nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson).
* Aktualizujte `Startup.ConfigureServices` volání `AddNewtonsoftJson`.

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson();
  ```

  `AddNewtonsoftJson`je kompatibilní s novými metodami registrace služby MVC:

  * `AddRazorPages`
  * `AddControllersWithViews`
  * `AddControllers`

  ```csharp
  services.AddControllers()
      .AddNewtonsoftJson();
  ```

  Nastavení Json.NET lze nastavit v volání `AddNewtonsoftJson`:

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson(options =>
             options.SerializerSettings.ContractResolver =
                new CamelCasePropertyNamesContractResolver());
  ```

## <a name="mvc-service-registration"></a>Registrace služby MVC

ASP.NET Core 3,0 přidává nové možnosti pro registraci scénářů MVC `Startup.ConfigureServices`v rámci.

K dispozici jsou tři nové metody rozšíření na `IServiceCollection` nejvyšší úrovni související s scénáři MVC. Šablony používají tyto nové metody místo `UseMvc`. Nicméně se `AddMvc` i nadále chová jako v předchozích verzích.

Následující příklad přidá podporu pro řadiče a funkce související s rozhraním API, ale ne zobrazení nebo stránky. Šablona rozhraní API používá tento kód:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllers();
}
```

Následující příklad přidá podporu pro řadiče, funkce související s rozhraním API a zobrazení, ale ne stránky. Šablona webové aplikace (MVC) používá tento kód:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews();
}
```

V následujícím příkladu se přidá podpora pro Razor Pages a minimální Podpora řadičů. Šablona webové aplikace používá tento kód:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddRazorPages();
}
```

Nové metody lze také kombinovat. Následující příklad je ekvivalentní volání `AddMvc` v ASP.NET Core 2,2:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews();
    services.AddRazorPages();
}
```

## <a name="routing-startup-code"></a>Spouštěcí kód směrování

Pokud je to aplikace `UseMvc` , `UseSignalR`nebo pokud je to možné, proveďte migraci aplikace do [Směrování koncových bodů](xref:fundamentals/routing) . Pro zlepšení kompatibility směrování koncových bodů s předchozími verzemi MVC jsme vrátili některé změny v adrese URL představené v ASP.NET Core 2,2. Pokud jste narazili na problémy s používáním směrování koncových bodů v 2,2, můžete očekávat vylepšení ASP.NET Core 3,0 s následujícími výjimkami:

* Pokud aplikace implementuje `IRouter` nebo dědí z `Route`, použijte jako náhradu [DynamicRouteValuesTransformer](https://github.com/aspnet/AspNetCore.Docs/issues/12997) .

* Pokud aplikace přímo přistupuje `RouteData.Routers` k analýze adres URL v rámci MVC, můžete to nahradit `LinkParser.ParsePathByEndpointName`použitím. 
 * Zadejte trasu s názvem trasy.
 * Použijte `LinkParser.ParsePathByEndpointName` a předejte název požadované trasy.

Směrování koncového bodu podporuje stejnou syntaxi vzorů směrování a funkce vytváření vzorů směrování jako `IRouter`. Směrování koncového `IRouteConstraint`bodu podporuje. Směrování koncového `[Route]`bodu `[HttpGet]`podporuje, a další atributy směrování MVC.

Pro většinu aplikací vyžaduje pouze `Startup` změny.

### <a name="migrate-startupconfigure"></a>Migrovat Startup. Configure

Obecné pokyny:

* Přidat `UseRouting`.
* Pokud je aplikace volána `UseStaticFiles`, umístěte `UseStaticFiles` **před** `UseRouting`.
* Pokud aplikace používá funkce `AuthorizePage` ověřování/autorizace `UseAuthentication` , jako je nebo `[Authorize]`, umístěte volání a `UseAuthorization` **After** `UseRouting` (a **po** `UseCors` použití middlewaru CORS).
* `UseMvc` Nahraďte `UseSignalR` nebo s `UseEndpoints`.
* Pokud aplikace používá scénáře [CORS](xref:security/cors) , například `[EnableCors]`, umístěte volání do `UseAuthentication` `UseCors` jakéhokoli jiného middlewaru, který používá CORS (například na místo `UseCors` před, `UseAuthorization`a `UseEndpoints`).
* Nahraďte `IHostingEnvironment` `using` výrazem a<xref:Microsoft.Extensions.Hosting?displayProperty=fullName>přidejte příkaz pro obor názvů. `IWebHostEnvironment`
* Nahraďte `IApplicationLifetime` (<xref:Microsoft.Extensions.Hosting?displayProperty=fullName>oboremnázvů). <xref:Microsoft.Extensions.Hosting.IHostApplicationLifetime>
* Nahraďte `EnvironmentName` (<xref:Microsoft.Extensions.Hosting?displayProperty=fullName>oboremnázvů). <xref:Microsoft.Extensions.Hosting.Environments>

Následující kód je příkladem `Startup.Configure` typické aplikace ASP.NET Core 2,2:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();

    app.UseAuthentication();

    app.UseSignalR(hubs =>
    {
        hubs.MapHub<ChatHub>("/chat");
    });

    app.UseMvc(routes =>
    {
        routes.MapRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

Po aktualizaci předchozího `Startup.Configure` kódu:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();

    app.UseRouting();

    app.UseCors();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>("/chat");
        endpoints.MapControllerRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

> [!WARNING]
> Pro většinu aplikací se volání `UseAuthentication`, `UseAuthorization`a `UseCors` musí objevit mezi voláními `UseRouting` a `UseEndpoints` , které jsou účinné.
### <a name="health-checks"></a>Kontroly stavu

Kontroly stavu používají směrování koncových bodů u obecného hostitele. V `Startup.Configure`nástroji zavolejte `MapHealthChecks` na tvůrce koncového bodu s adresou URL koncového bodu nebo relativní cestou:

```csharp
app.UseEndpoints(endpoints =>
{
    endpoints.MapHealthChecks("/health");
});
```

Koncové body kontrol stavu můžou:

* Zadejte minimálně jednoho povoleného hostitele nebo portů.
* Vyžadovat autorizaci.
* Vyžadovat CORS

Další informace naleznete v tématu <xref:host-and-deploy/health-checks>.

### <a name="security-middleware-guidance"></a>Doprovodné materiály k zabezpečení middlewaru

Podpora pro autorizaci a CORS je sjednocená v rámci přístupu [middlewaru](xref:fundamentals/middleware/index) . To umožňuje používat stejný middlewar a funkčnost v těchto scénářích. V této verzi je k dispozici aktualizovaný middleware autorizace a middleware CORS je vylepšený, aby bylo možné pochopit atributy používané řadiči MVC.

#### <a name="cors"></a>CORS

V minulosti mohlo být obtížné nakonfigurovat CORS. Middleware byl poskytnut pro použití v některých případech použití, ale filtry MVC byly určeny k použití **bez** middlewaru v jiných případech použití. U ASP.NET Core 3,0 doporučujeme, aby všechny aplikace, které vyžadují CORS, používaly middleware CORS v kombinaci s směrováním koncových bodů. `UseCors`dá se zadat s výchozí zásadou a `[EnableCors]` `[DisableCors]` pomocí atributů můžete v případě potřeby přepsat výchozí zásady.

V následujícím příkladu:

* U všech koncových bodů s `default` pojmenovanou zásadou je povolená CORS.
* Třída zakáže CORS `[DisableCors]` s atributem. `MyController`

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseCors("default");

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[DisableCors]
public class MyController : ControllerBase
{
    ...
}
```

#### <a name="authorization"></a>Autorizace

V dřívějších verzích ASP.NET Core byla poskytnuta podpora autorizace prostřednictvím `[Authorize]` atributu. Autorizační middleware není k dispozici. V ASP.NET Core 3,0 se vyžaduje middleware autorizace. Doporučujeme umístit middleware autorizace ASP.NET Core (`UseAuthorization`) hned po. `UseAuthentication` Middleware autorizace se dá nakonfigurovat taky s výchozími zásadami, které se dají přepsat.

V ASP.NET Core 3,0 nebo novějším `UseAuthorization` se volá v `Startup.Configure`a následující `HomeController` vyžaduje přihlášeného uživatele:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

public class HomeController : ControllerBase
{
    [Authorize]
    public IActionResult BuyWidgets()
    {
        ...
    }
}
```

Pokud aplikace používá `AuthorizeFilter` jako globální filtr v MVC, doporučujeme v `AddAuthorization`volání metody refaktoring kódu, aby poskytovala zásady.

`DefaultPolicy` Je zpočátku nakonfigurovaný tak, aby vyžadoval ověřování, takže se nevyžaduje žádná další konfigurace. V následujícím příkladu jsou koncové body MVC označeny jako `RequireAuthorization` tak, že všechny požadavky musí být autorizovány na základě. `DefaultPolicy` Povolit přístup bez přihlášení uživatele do aplikace je však `[AllowAnonymous]`z důvodu: `HomeController`

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute().RequireAuthorization();
    });
}

[AllowAnonymous]
public class HomeController : ControllerBase
{
    ...
}
```

Zásady je také možné přizpůsobit. Při sestavování v předchozím příkladu `DefaultPolicy` je nakonfigurována tak, aby vyžadovala ověřování a určitý rozsah:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    ...

    services.AddAuthorization(options =>
    {
        options.DefaultPolicy = new AuthorizationPolicyBuilder()
          .RequireAuthenticatedUser()
          .RequireScope("MyScope")
          .Build();
    });
}

public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute().RequireAuthorization();
    });
}

[AllowAnonymous]
public class HomeController : ControllerBase
{
    ...
}
```

Alternativně lze všechny koncové body nakonfigurovat tak, aby vyžadovaly `RequireAuthorization` autorizaci bez `FallbackPolicy` `[Authorize]` nebo konfigurací. `FallbackPolicy` Se liší `DefaultPolicy`od. `DefaultPolicy` Spustí`[Authorize]` se nebo ,`RequireAuthorization` Když`FallbackPolicy` se aktivuje, když nejsou nastavené žádné jiné zásady. `FallbackPolicy`je zpočátku nakonfigurovaný tak, aby povoloval požadavky bez autorizace.

Následující příklad je stejný jako předchozí `DefaultPolicy` příklad, ale používá, `FallbackPolicy` aby vždy vyžadoval ověřování u všech koncových bodů s výjimkou případů, kdy `[AllowAnonymous]` je zadána:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    ...

    services.AddAuthorization(options =>
    {
        options.FallbackPolicy = new AuthorizationPolicyBuilder()
          .RequireAuthenticatedUser()
          .RequireScope("MyScope")
          .Build();
    });
}

public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[AllowAnonymous]
public class HomeController : ControllerBase
{
    ...
}
```

Ověřování pomocí middlewaru funguje bez rozhraní, které má konkrétní znalosti o autorizaci. [Kontroly stavu](xref:host-and-deploy/health-checks) například nemají žádné konkrétní znalosti o autorizaci, ale kontroly stavu můžou mít konfigurovatelné zásady autorizace, které používá middleware.

Každý koncový bod navíc může přizpůsobit své autorizační požadavky. V následujícím příkladu `UseAuthorization` zpracovává autorizaci `DefaultPolicy`pomocí nástroje, ale `/healthz` koncový bod kontroly stavu vyžaduje `admin` uživatele:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints
            .MapHealthChecks("/healthz")
            .RequireAuthorization(new AuthorizeAttribute(){ Roles = "admin", });
    });
}
```

Ochrana je implementovaná pro některé scénáře. `UseEndpoint`middleware vyvolá výjimku, pokud je zásada autorizace nebo CORS vynechána z důvodu chybějícího middlewaru. Podpora analyzátoru, která poskytuje další názory na neplatnou konfiguraci.

### <a name="signalr"></a>SignalR

Mapování rozbočovačů signálu se teď provádí v rámci `UseEndpoints`.

Namapujte každé centrum `MapHub`pomocí. Stejně jako v předchozích verzích je každé centrum výslovně uvedené.

V následujícím příkladu se přidá podpora pro `ChatHub` centrum signalizace:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>();
    });
}
```

Pro řízení omezení velikosti zprávy od klientů je k dispozici nová možnost. Například v `Startup.ConfigureServices`:

```csharp
services.AddSignalR(hubOptions =>
{
    hubOptions.MaximumReceiveMessageSize = 32768;
});
```

V ASP.NET Core 2,2 můžete nastavit `TransportMaxBufferSize` a, které by účinně ovládají maximální velikost zprávy. V ASP.NET Core 3,0 Tato možnost nyní určuje pouze maximální velikost před nedodržením přítlaku.

### <a name="mvc-controllers"></a>Řadiče MVC

Mapování řadičů se teď provádí v rámci `UseEndpoints`.

Přidejte `MapControllers` , pokud aplikace používá směrování atributů. Vzhledem k tomu, že směrování zahrnuje podporu pro mnoho platforem v ASP.NET Core 3,0 nebo novějších, je přidání řadičů směrovaných k atributům výslovný souhlas.

Nahraďte následující:

* `MapRoute`řetězce`MapControllerRoute`
* `MapAreaRoute`řetězce`MapAreaControllerRoute`

Vzhledem k tomu, že směrování nyní zahrnuje podporu pro více než jen MVC, se terminologie změnila, aby tyto metody jasně zajistila, co dělají. Konvenční trasy, například `MapControllerRoute` / `MapAreaControllerRoute` ,jsouaplikoványvpořadí,vjakémbylypřidány.`MapDefaultControllerRoute` / Nejprve umístěte konkrétnější trasy (například trasy pro oblast).

V následujícím příkladu:

* `MapControllers`Přidá podporu pro řadiče směrované atributy.
* `MapAreaControllerRoute`Přidá konvenční trasu pro řadiče v oblasti.
* `MapControllerRoute`Přidá konvenční trasu pro řadiče.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapControllers();
        endpoints.MapAreaControllerRoute(
            "admin",
            "admin",
            "Admin/{controller=Home}/{action=Index}/{id?}");
        endpoints.MapControllerRoute(
            "default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

### <a name="razor-pages"></a>Razor Pages

Mapování Razor Pages nyní probíhá uvnitř `UseEndpoints`.

Přidejte `MapRazorPages` , pokud aplikace používá Razor Pages. Vzhledem k tomu, že směrování koncových bodů zahrnuje podporu pro spoustu platforem, přidání Razor Pages je nyní výslovným souhlasem.

V následujícím příkladu `MapRazorPages` přidá podporu pro Razor Pages:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapRazorPages();
    });
}
```

### <a name="use-mvc-without-endpoint-routing"></a>Použití MVC bez směrování koncových bodů

Použití MVC prostřednictvím `UseMvc` nebo `UseMvcWithDefaultRoute` v ASP.NET Core 3,0 vyžaduje explicitní výslovný souhlas v rámci `Startup.ConfigureServices`. To je nutné, protože MVC musí zjistit, jestli se může při inicializaci spoléhat na autorizaci a middleware CORS. K dispozici je analyzátor, který se upozorní, pokud se aplikace pokusí použít nepodporovanou konfiguraci.

Pokud aplikace vyžaduje starší `IRouter` verzi podpory, zakažte `EnableEndpointRouting` použití některého z následujících přístupů v `Startup.ConfigureServices`nástroji:

```csharp
services.AddMvc(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllers(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllersWithViews(options => options.EnableEndpointRouting = false);

```

```csharp
services.AddRazorPages().AddMvcOptions(options => options.EnableEndpointRouting = false);
```

### <a name="health-checks"></a>Kontroly stavu

Kontroly stavu lze použít jako *směrovač* s směrováním koncových bodů.

Přidejte `MapHealthChecks` k použití kontrol stavu pomocí směrování koncových bodů. Metoda přijímá argumenty `UseHealthChecks`podobné. `MapHealthChecks` Výhodou použití `MapHealthChecks` funkce Over `UseHealthChecks` je možnost použít autorizaci a mít větší jemně odstupňovanou kontrolu nad zásadami pro porovnání.

V následujícím příkladu `MapHealthChecks` je volána pro koncový bod kontroly stavu v `/healthz`:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHealthChecks("/healthz", new HealthCheckOptions() { });
    });
}
```

## <a name="hostbuilder-replaces-webhostbuilder"></a>HostBuilder nahrazuje WebHostBuilder

Šablony ASP.NET Core 3,0 používají [obecného hostitele](xref:fundamentals/host/generic-host). Předchozí verze používaly [webového hostitele](xref:fundamentals/host/web-host). Následující kód ukazuje třídu vygenerovanou `Program` šablonou ASP.NET Core 3,0:

[!code-csharp[](22-to-30/samples/Program.cs?name=snippet)]

Následující kód ukazuje třídu vygenerovanou `Program` šablonou ASP.NET Core 2,2:

[!code-csharp[](22-to-30/samples/Program2.2.cs?name=snippet)]

<xref:Microsoft.AspNetCore.Hosting.IWebHostBuilder>zůstává v 3,0 a je typ `webBuilder` zobrazený v předchozí ukázce kódu. <xref:Microsoft.AspNetCore.Hosting.WebHostBuilder>bude zastaralá v budoucí verzi a nahrazena nástrojem `HostBuilder`.

Nejvýznamnější změna z `WebHostBuilder` na `HostBuilder` je v [vkládání závislostí (di)](xref:fundamentals/dependency-injection). Při použití `HostBuilder`nástroje lze <xref:Microsoft.Extensions.Configuration.IConfiguration> <xref:Microsoft.AspNetCore.Hosting.IHostingEnvironment> vložit`Startup`pouze konstruktor. Omezení `HostBuilder` di:

* Povolí sestavení kontejneru DI jenom jednou.
* Předejde výsledným problémům životního cyklu objektů, jako je například řešení více instancí singleton.

## <a name="addauthorization-moved-to-a-different-assembly"></a>AddAuthorization přesunuté do jiného sestavení

ASP.NET Core 2,2 a nižší `AddAuthorization` metody v souboru *Microsoft. AspNetCore. Authorization. dll*:

* Bylo přejmenováno `AddAuthorizationCore`.
* Byly přesunuty do souboru *Microsoft. AspNetCore. Authorization. Policy. dll*.

Aplikace používající *Microsoft. AspNetCore. Authorization. dll* a *Microsoft. AspNetCore. Authorization. Policy. dll* nejsou ovlivněny.

Aplikace, které nepoužívají *Microsoft. AspNetCore. Authorization. Policy. dll* , by měly provádět jednu z následujících akcí:

* Přepnout na použití`AddAuthorizationCore`
* Přidejte odkaz na *Microsoft. AspNetCore. Authorization. Policy. dll*.

Další informace naleznete v tématu zásadní [Změna v `AddAuthorization(o =>`) přetížení života v jiném sestavení #386](https://github.com/aspnet/Announcements/issues/386).

## <a name="signalr-code"></a>Kód signálu

Klient pro signalizaci jazyka JavaScript se změnil `@aspnet/signalr` z `@microsoft/signalr`na. Pro reakci na tuto změnu změňte odkazy v souborech *Package. JSON* , vyžadovat příkazy a příkazy importu ECMAScript.

### <a name="systemtextjson-is-the-default-protocol"></a>System. text. JSON je výchozí protokol.

`System.Text.Json`je teď výchozím protokolem rozbočovače používaným klientem i serverem.

V `Startup.ConfigureServices`nástroji zavolejte `AddJsonProtocol` na nastavit možnosti serializátoru.

**WebServer**

```csharp
services.AddSignalR(...)
        .AddJsonProtocol(options =>
        {
            options.WriteIndented = false;
        })
```

**Služba**

```csharp
new HubConnectionBuilder()
    .WithUrl("/chatHub")
    .AddJsonProtocol(options =>
    {
        options.WriteIndented = false;
    })
    .Build();
```

### <a name="switch-to-newtonsoftjson"></a>Přepnout na Newtonsoft. JSON

Pokud používáte funkce `Newtonsoft.Json` nástroje, které nejsou podporované v `System.Text.Json`, můžete přejít zpátky na `Newtonsoft.Json`:

1. Nainstalujte balíček NuGet [Microsoft. AspNetCore. signaler. Protocols. NewtonsoftJson](https://www.nuget.org/packages/Microsoft.AspNetCore.SignalR.Protocols.NewtonsoftJson) .
1. Na straně klienta řetězit `AddNewtonsoftJsonProtocol` volání metody `HubConnectionBuilder` do instance:

    ```csharp
    new HubConnectionBuilder()
        .WithUrl("/chatHub")
        .AddNewtonsoftJsonProtocol(...)
        .Build();
    ```

1. Na serveru řetězit `AddNewtonsoftJsonProtocol` volání `AddSignalR` metody volání `Startup.ConfigureServices`metody:

    ```csharp
    services.AddSignalR()
        .AddNewtonsoftJsonProtocol(...);
    ```

## <a name="opt-in-to-runtime-compilation"></a>Přihlásit se ke kompilaci za běhu

V 3,0 je kompilace za běhu v případě výslovného souhlasu. Chcete-li povolit kompilaci za <xref:mvc/views/view-compilation#runtime-compilation>běhu, přečtěte si téma.

## <a name="migrating-libraries-via-multi-targeting"></a>Migrace knihoven přes cílení na více platforem

Knihovny často potřebují podporovat více verzí ASP.NET Core. Většina knihoven kompilovaných pro předchozí verze ASP.NET Core by měla pokračovat bez problémů. Následující podmínky vyžadují, aby byla aplikace sestavena mezi více:

* Knihovna se spoléhá na funkci, která má binární zásadní [změnu](#breaking-api-changes).
* Knihovna chce využívat nové funkce v ASP.NET Core 3,0. 

Příklad:

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFrameworks>netcoreapp3.0;netstandard2.0</TargetFrameworks>
  </PropertyGroup>

  <ItemGroup Condition="'$(TargetFramework)' == 'netcoreapp3.0'">
    <FrameworkReference Include="Microsoft.AspNetCore.App" />
  </ItemGroup>

  <ItemGroup Condition="'$(TargetFramework)' == 'netstandard2.0'">
    <PackageReference Include="Microsoft.AspNetCore" Version="2.1.0" />
  </ItemGroup>
</Project>
```

Použijte `#ifdefs` k vysvětlení ASP.NET Core 3,0 specifických rozhraní API:

```csharp
var webRootFileProvider =
#if NETCOREAPP3_0
    GetRequiredService<IWebHostEnvironment>().WebRootFileProvider;
#else if NETSTANDARD2_0
    GetRequiredService<IHostingEnvironment>().WebRootFileProvider;
#else
#error unknown target framework
#endif
```

## <a name="breaking-api-changes"></a>Přerušení změn rozhraní API

* [Úplný seznam nejnovějších změn v ASP.NET Core vydání 3,0](https://github.com/aspnet/Announcements/issues?page=2&q=is%3Aissue+is%3Aopen+label%3A%22Breaking+change%22+label%3A3.0.0)
* [Rušení změn rozhraní API v antipadělání, CORS, diagnostice, MVC a směrování](https://github.com/aspnet/Announcements/issues/387). Tento seznam obsahuje zásadní změny pro přepínače kompatibility.
* Shrnutí 2,2-až 3,0 přerušující změny v rámci .NET Core, ASP.NET Core a Entity Framework Core najdete v tématu [přerušující změny migrace z verze 2,2 na 3,0](/dotnet/core/compatibility/2.2-3.0).


## <a name="aspnet-core-30-not-currently-available-for-azure-app-service"></a>ASP.NET Core 3,0 není aktuálně k dispozici pro Azure App Service. 

Doufáme, že to bude brzy k dispozici. Až ASP.NET Core 3,0 k dispozici v Azure App Service, postupujte podle pokynů v části [nasazení ASP.NET Core vydání verze Preview do Azure App Service](xref:host-and-deploy/azure-apps/index#deploy-aspnet-core-preview-release-to-azure-app-service).
