---
title: Migrace z ASP.NET Core 2,2 na 3,0
author: rick-anderson
description: Přečtěte si, jak migrovat projekt ASP.NET Core 2,2 do ASP.NET Core 3,0.
ms.author: riande
ms.custom: mvc
ms.date: 05/03/2020
no-loc:
- Blazor
- Blazor Server
- Blazor WebAssembly
- Identity
- Let's Encrypt
- Razor
- SignalR
uid: migration/22-to-30
ms.openlocfilehash: 6fe19b9e7969cee9bbef03c52830834c2b23912a
ms.sourcegitcommit: d65a027e78bf0b83727f975235a18863e685d902
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 06/26/2020
ms.locfileid: "85403323"
---
# <a name="migrate-from-aspnet-core-22-to-30"></a>Migrace z ASP.NET Core 2,2 na 3,0

[Scottem Addie](https://github.com/scottaddie) a [Rick Anderson](https://twitter.com/RickAndMSFT)

Tento článek vysvětluje, jak aktualizovat existující projekt ASP.NET Core 2,2 na ASP.NET Core 3,0. Může být užitečné vytvořit nový projekt ASP.NET Core 3,0 pro:

* Porovnejte s kódem ASP.NET Core 2,2.
* Zkopírujte příslušné změny do projektu ASP.NET Core 3,0.

## <a name="prerequisites"></a>Požadavky

# <a name="visual-studio"></a>[Visual Studio](#tab/visual-studio)

[!INCLUDE[](~/includes/net-core-prereqs-vs-3.0.md)]

# <a name="visual-studio-code"></a>[Visual Studio Code](#tab/visual-studio-code)

[!INCLUDE[](~/includes/net-core-prereqs-vsc-3.0.md)]

# <a name="visual-studio-for-mac"></a>[Visual Studio pro Mac](#tab/visual-studio-mac)

[!INCLUDE[](~/includes/net-core-prereqs-mac-3.0.md)]

---

## <a name="update-net-core-sdk-version-in-globaljson"></a>Aktualizace verze .NET Core SDK v global.js

Pokud vaše řešení spoléhá na [global.js](/dotnet/core/tools/global-json) souboru, aby cílí na konkrétní .NET Core SDKou verzi, aktualizujte jeho `version` vlastnost na verzi 3,0 nainstalovanou na vašem počítači:

```json
{
  "sdk": {
    "version": "3.0.100"
  }
}
```

## <a name="update-the-project-file"></a>Aktualizovat soubor projektu

### <a name="update-the-target-framework"></a>Aktualizace cílového rozhraní .NET Framework

ASP.NET Core 3,0 a novější se spouští pouze v .NET Core. Nastavte [moniker cílového rozhraní .NET Framework (TFM)](/dotnet/standard/frameworks) na `netcoreapp3.0` :

[!code-xml[](22-to-30/samples/Web1.csproj?highlight=4)]

### <a name="remove-obsolete-package-references"></a>Odebrat zastaralé odkazy na balíčky

Pro ASP.NET Core 3,0 není vytvořený velký počet balíčků NuGet. Tyto odkazy na balíčky by měly být odebrány ze souboru projektu. Vezměte v úvahu následující soubor projektu pro webovou aplikaci ASP.NET Core 2,2:

```xml
<Project Sdk="Microsoft.NET.Sdk.Web">

  <PropertyGroup>
    <TargetFramework>netcoreapp2.2</TargetFramework>
    <AspNetCoreHostingModel>InProcess</AspNetCoreHostingModel>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.AspNetCore.App"/>
    <PackageReference Include="Microsoft.AspNetCore.Razor.Design" Version="2.2.0" PrivateAssets="All" />
  </ItemGroup>

</Project>
```

Aktualizovaný soubor projektu pro ASP.NET Core 3,0:

[!code-xml[](22-to-30/samples/Web1.csproj?highlight=4)]

Aktualizovaný soubor projektu ASP.NET Core 3,0:

* V `<PropertyGroup>` :
  * Aktualizuje TFM na.`netcoreapp3.0`
  * Odebere `<AspNetCoreHostingModel>` prvek. Další informace najdete v tématu [model hostování v procesu](#in-process-hosting-model) v tomto dokumentu.

* V `<ItemGroup>` :
  * `Microsoft.AspNetCore.App`je odebráno. Další informace najdete v tématu [Reference k rozhraní](#framework-reference) v tomto dokumentu.
  * `Microsoft.AspNetCore.Razor.Design`odebrána a v následujícím seznamu balíčků již nejsou vytvářeny.

Úplný seznam balíčků, které už nejsou vytvořené, zobrazíte tak, že vyberete následující seznam rozbalit:

<details>
    <summary>Kliknutím rozbalíte seznam balíčků, které už nejsou vyráběny.</summary>
    <ul>
        <li>Microsoft. AspNetCore</li>
        <li>Microsoft. AspNetCore. All</li>
        <li>Microsoft. AspNetCore. app</li>
        <li>Microsoft.AspNetCore.Antiforgery</li>
        <li>Microsoft.AspNetCore.Authentication</li>
        <li>Microsoft.AspNetCore.Authentication.Abstractions</li>
        <li>Microsoft.AspNetCore.Authentication.Cookies</li>
        <li>Microsoft.AspNetCore.Authentication.Core</li>
        <li>Microsoft.AspNetCore.Authentication.OAuth</li>
        <li>Microsoft.AspNetCore.Authorization.Policy</li>
        <li>Microsoft.AspNetCore.CookiePolicy</li>
        <li>Microsoft.AspNetCore.Cors</li>
        <li>Microsoft.AspNetCore.Diagnostics</li>
        <li>Microsoft.AspNetCore.Diagnostics.HealthChecks</li>
        <li>Microsoft. AspNetCore. HostFiltering</li>
        <li>Microsoft. AspNetCore. hosting</li>
        <li>Microsoft.AspNetCore.Hosting.Abstractions</li>
        <li>Microsoft.AspNetCore.Hosting.Server.Abstractions</li>
        <li>Microsoft.AspNetCore.Http</li>
        <li>Microsoft.AspNetCore.Http.Abstractions</li>
        <li>Microsoft.AspNetCore.Http.Connections</li>
        <li>Microsoft.AspNetCore.Http.Extensions</li>
        <li>Microsoft.AspNetCore.HttpOverrides</li>
        <li>Microsoft.AspNetCore.HttpsPolicy</li>
        <li>Microsoft. AspNetCore.Identity</li>
        <li>Microsoft.AspNetCore.Localization</li>
        <li>Microsoft.AspNetCore.Localization.Routing</li>
        <li>Microsoft. AspNetCore. Mvc</li>
        <li>Microsoft.AspNetCore.Mvc.Abstractions</li>
        <li>Microsoft.AspNetCore.Mvc.Analyzers</li>
        <li>Microsoft.AspNetCore.Mvc.ApiExplorer</li>
        <li>Microsoft.AspNetCore.Mvc.Api.Analyzers</li>
        <li>Microsoft.AspNetCore.Mvc.Core</li>
        <li>Microsoft.AspNetCore.Mvc.Cors</li>
        <li>Microsoft.AspNetCore.Mvc.DataAnnotations</li>
        <li>Microsoft.AspNetCore.Mvc.Formatters.Json</li>
        <li>Microsoft.AspNetCore.Mvc.Formatters.Xml</li>
        <li>Microsoft.AspNetCore.Mvc.Localization</li>
        <li>Microsoft. AspNetCore. Mvc.Razor</li>
        <li>Microsoft. AspNetCore. Mvc. Razor .. ViewCompilation</li>
        <li>Microsoft.AspNetCore.Mvc.RazorPages</li>
        <li>Microsoft.AspNetCore.Mvc.TagHelpers</li>
        <li>Microsoft.AspNetCore.Mvc.ViewFeatures</li>
        <li>Microsoft. AspNetCore.Razor</li>
        <li>Microsoft. AspNetCore. Razor . Runtime</li>
        <li>Microsoft. AspNetCore. Razor . Vytvořit</li>
        <li>Microsoft.AspNetCore.ResponseCaching</li>
        <li>Microsoft.AspNetCore.ResponseCaching.Abstractions</li>
        <li>Microsoft.AspNetCore.ResponseCompression</li>
        <li>Microsoft.AspNetCore.Rewrite</li>
        <li>Microsoft. AspNetCore. Routing</li>
        <li>Microsoft.AspNetCore.Routing.Abstractions</li>
        <li>Microsoft.AspNetCore.Server.HttpSys</li>
        <li>Microsoft.AspNetCore.Server.IIS</li>
        <li>Microsoft.AspNetCore.Server.IISIntegration</li>
        <li>Microsoft.AspNetCore.Server.Kestrel</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Core</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Https</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets</li>
        <li>Microsoft.AspNetCore.Session</li>
        <li>Microsoft. AspNetCore.SignalR</li>
        <li>Microsoft. AspNetCore. SignalR . Core</li>
        <li>Microsoft. AspNetCore. StaticFiles</li>
        <li>Microsoft.AspNetCore.WebSockets</li>
        <li>Microsoft.AspNetCore.WebUtilities</li>
        <li>Microsoft.Net.Http.Headers </li>
    </ul>
</details>

### <a name="review-breaking-changes"></a>Kontrola nejnovějších změn

[Kontrola nejnovějších změn](#break)

### <a name="framework-reference"></a>Odkaz na rozhraní

Funkce ASP.NET Core, které byly k dispozici prostřednictvím jednoho z výše uvedených balíčků, jsou k dispozici jako součást `Microsoft.AspNetCore.App` sdíleného rozhraní. *Sdílené rozhraní* je sada sestavení (soubory *. dll* ), které jsou nainstalovány na počítači a zahrnují komponentu modulu runtime a sadu targeting pack. Další informace najdete v tématu [sdílené rozhraní](https://natemcmaster.com/blog/2018/08/29/netcore-primitives-2/).

* Projekty, které cílí na `Microsoft.NET.Sdk.Web` sadu SDK, implicitně odkazují na `Microsoft.AspNetCore.App` rozhraní.

  Pro tyto projekty nejsou vyžadovány žádné další odkazy:

  ```xml
  <Project Sdk="Microsoft.NET.Sdk.Web">
    <PropertyGroup>
      <TargetFramework>netcoreapp3.0</TargetFramework>
    </PropertyGroup>
      ...
  </Project>
  ```

* Projekty, které cílí na `Microsoft.NET.Sdk` `Microsoft.NET.Sdk.Razor` sadu SDK, by měly přidat explicitní `FrameworkReference` pro `Microsoft.AspNetCore.App` :

  ```xml
  <Project Sdk="Microsoft.NET.Sdk.Razor">
    <PropertyGroup>
      <TargetFramework>netcoreapp3.0</TargetFramework>
    </PropertyGroup>

    <ItemGroup>
      <FrameworkReference Include="Microsoft.AspNetCore.App" />
    </ItemGroup>
      ...
  </Project>
  ```

#### <a name="framework-dependent-builds-using-docker"></a>Sestavení závislá na rozhraních pomocí Docker

Sestavení závislé na rozhraních konzolových aplikací, které používají balíček, který závisí na ASP.NET Core [sdílenému rozhraní](https://natemcmaster.com/blog/2018/08/29/netcore-primitives-2/) , mohou poskytnout následující chybu za běhu:

```console
It was not possible to find any compatible framework version
The specified framework 'Microsoft.AspNetCore.App', version '3.0.0' was not found.
  - No frameworks were found.
```

`Microsoft.AspNetCore.App`je sdílené rozhraní obsahující modul runtime ASP.NET Core a je k dispozici pouze v imagi [dotnet/Core/ASPNET](https://hub.docker.com/_/microsoft-dotnet-core-aspnet/) Docker. Sada SDK 3,0 omezuje velikost sestavení závislých na rozhraních pomocí ASP.NET Core nezahrnují duplicitní kopie knihoven, které jsou k dispozici ve sdíleném rozhraní. Jedná se o potenciální úspory až 18 MB, ale vyžaduje, aby se při spuštění aplikace spustil nebo nainstaloval modul runtime ASP.NET Core.

Pokud chcete zjistit, jestli má aplikace závislost (buď přímá, nebo nepřímá) na ASP.NET Core sdíleném rozhraním, Projděte si *runtimeconfig.jsv* souboru vygenerovaném při sestavování/publikování vaší aplikace. Následující soubor JSON ukazuje závislost na ASP.NET Core sdílené rozhraní:

```json
{
  "runtimeOptions": {
    "tfm": "netcoreapp3.0",
    "framework": {
      "name": "Microsoft.AspNetCore.App",
      "version": "3.0.0"
    },
    "configProperties": {
      "System.GC.Server": true
    }
  }
}
```

Pokud vaše aplikace používá Docker, použijte základní image, která zahrnuje ASP.NET Core 3,0. Například, `docker pull mcr.microsoft.com/dotnet/core/aspnet:3.0`.

### <a name="add-package-references-for-removed-assemblies"></a>Přidat odkazy na balíčky pro odebraná sestavení

ASP.NET Core 3,0 odstraní některá sestavení, která byla dříve součástí `Microsoft.AspNetCore.App` odkazu na balíček. Chcete-li vizualizovat, která sestavení byla odebrána, Porovnejte dvě sdílené složky rozhraní. Například porovnání verzí 2.2.7 a 3.0.0:

![porovnání sestavení sdílených rozhraní](22-to-30/_static/assembly-diff.png)

Chcete-li pokračovat v používání funkcí poskytovaných odebranými sestaveními, odkazujte na verze 3,0 odpovídajících balíčků:

* Webová aplikace vygenerovaná šablonou s **jednotlivými uživatelskými účty** vyžaduje přidání následujících balíčků:

  [!code-xml[](22-to-30/samples/WebFull.csproj?highlight=9-13)]

* [Microsoft. EntityFrameworkCore](https://www.nuget.org/packages/Microsoft.EntityFrameworkCore)

  Další informace o odkazování na balíček pro konkrétního poskytovatele databáze najdete v tématu [poskytovatelé databáze](/ef/core/providers/index).

* IdentityROZHRANÍ

  Podporu [ Identity uživatelského rozhraní](xref:security/authentication/identity) lze přidat odkazem na [Microsoft. AspNetCore. Identity Balíček uživatelského rozhraní](https://www.nuget.org/packages/Microsoft.AspNetCore.Identity.UI) .

* Služby SPA

  * [Microsoft. AspNetCore. SpaServices](https://www.nuget.org/packages/Microsoft.AspNetCore.SpaServices)
  * [Microsoft. AspNetCore. SpaServices. Extensions](https://www.nuget.org/packages/Microsoft.AspNetCore.SpaServices.Extensions)

* Ověřování: podpora toků ověřování třetích stran je k dispozici jako balíčky NuGet:

  * Facebook OAuth ([Microsoft. AspNetCore. Authentication. Facebook](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Facebook))
  * Google OAuth ([Microsoft. AspNetCore. Authentication. Google](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Google))
  * Ověřování účtu Microsoft ([Microsoft. AspNetCore. Authentication. MicrosoftAccount](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.MicrosoftAccount))
  * OpenID Connect Authentication ([Microsoft. AspNetCore. Authentication. OpenIdConnect](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.OpenIdConnect))
  * Token nosiče OpenID Connect ([Microsoft. AspNetCore. Authentication. JwtBearer](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.JwtBearer))
  * Twitter OAuth ([Microsoft. AspNetCore. Authentication. Twitter](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Twitter))
  * Ověřování WsFederation ([Microsoft. AspNetCore. Authentication. WsFederation](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.WsFederation))

* Podpora vyjednávání formátování a obsahu pro `System.Net.HttpClient` : balíček NuGet [Microsoft. ASPNET. WebApi. Client](https://www.nuget.org/packages/Microsoft.AspNet.WebApi.Client/) poskytuje užitečné rozšíření pro `System.Net.HttpClient` rozhraní API, jako jsou `ReadAsAsync` a `PostJsonAsync` .

* Razorkompilace za běhu: podpora pro kompilaci za běhu pro Razor zobrazení a stránky je teď součástí [Microsoft. AspNetCore. Mvc. Razor . RuntimeCompilation](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation).

* MVC `Newtonsoft.Json` (JSON.NET) – podpora pro použití MVC s `Newtonsoft.Json` je teď součástí [`Microsoft.AspNetCore.Mvc.NewtonsoftJson`](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson) .

## <a name="startup-changes"></a>Změny při spuštění

Na následujícím obrázku vidíte odstraněné a změněné řádky ve Razor webové aplikaci ASP.NET Core 2,2 Pages:

![odstraněné a změněné řádky ve Razor webové aplikaci ASP.NET Core 2,2](22-to-30/_static/startup2.2.png)

Na předchozím obrázku se odstraněný kód zobrazuje červeně. Odstraněný kód nezobrazuje kód možnosti souboru cookie, který byl odstraněn před porovnáním souborů.

Následující obrázek znázorňuje přidané a změněné řádky ve Razor webové aplikaci ASP.NET Core 3,0 Pages:

![přidané a změněné řádky ve webové aplikaci ASP.NET Core 3,0 Razor](22-to-30/_static/startup3.0.png)

Na předchozím obrázku se přidaný kód zobrazuje zeleně. Informace o následujících změnách:

* `services.AddMvc`do najdete `services.AddRazorPages` v tématu [Registrace služby MVC](#mvc-service-registration) v tomto dokumentu.
* `CompatibilityVersion`naleznete v tématu <xref:mvc/compatibility-version> .
* `IHostingEnvironment`na najdete `IWebHostEnvironment` [Toto oznámení GitHubu](https://github.com/dotnet/AspNetCore/issues/7749).
* `app.UseAuthorization`bylo přidáno do šablon, aby se zobrazila klauzule autorizačního rozhraní ORDER by se měla přidat. Pokud aplikace nepoužívá autorizaci, můžete volání bezpečně odebrat `app.UseAuthorization` .
* `app.UseEndpoints`, viz [ Razor stránky](#razor-pages) nebo [migrace Startup.Configurovat](#migrate-startupconfigure) v tomto dokumentu.

### <a name="analyzer-support"></a>Podpora analyzátoru

Projekty, které cílí `Microsoft.NET.Sdk.Web` na implicitně referenční analyzátory dříve dodávané jako součást balíčku [Microsoft. AspNetCore. Mvc. analyzers](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Analyzers/) . K povolení těchto kroků nejsou vyžadovány žádné další odkazy.

Pokud vaše aplikace používá [analyzátory rozhraní API](xref:web-api/advanced/analyzers) dříve dodávané pomocí balíčku [Microsoft. AspNetCore. Mvc. API. analyzers](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Api.Analyzers/) , upravte soubor projektu tak, aby odkazoval na analyzátory dodávané jako součást sady .NET Core web SDK:

```xml
<Project Sdk="Microsoft.NET.Sdk.Web">
    <PropertyGroup>
        <TargetFramework>netcoreapp3.0</TargetFramework>
        <IncludeOpenAPIAnalyzers>true</IncludeOpenAPIAnalyzers>
    </PropertyGroup>

    ...
</Project>
```

### <a name="razor-class-library"></a>RazorKnihovna tříd

RazorProjekty knihovny tříd, které poskytují komponenty uživatelského rozhraní pro MVC, musí nastavit `AddRazorSupportForMvc` vlastnost v souboru projektu:

```xml
<PropertyGroup>
  <AddRazorSupportForMvc>true</AddRazorSupportForMvc>
</PropertyGroup>
```

### <a name="in-process-hosting-model"></a>Model hostování v procesu

Projekty jsou ve výchozím nastavení pro [model hostování v rámci procesu](xref:host-and-deploy/aspnet-core-module#in-process-hosting-model) v ASP.NET Core 3,0 nebo novějším. Případně můžete odebrat `<AspNetCoreHostingModel>` vlastnost v souboru projektu, pokud je její hodnota `InProcess` .

## <a name="kestrel"></a>Kestrel

### <a name="configuration"></a>Konfigurace

Migruje konfiguraci Kestrel do [Tvůrce webového hostitele](#hostb) , který poskytuje `ConfigureWebHostDefaults` (*program.cs*):

```csharp
public static IHostBuilder CreateHostBuilder(string[] args) =>
    Host.CreateDefaultBuilder(args)
        .ConfigureWebHostDefaults(webBuilder =>
        {
            webBuilder.ConfigureKestrel(serverOptions =>
            {
                // Set properties and call methods on options
            })
            .UseStartup<Startup>();
        });
```

Pokud aplikace vytvoří hostitele ručně pomocí `HostBuilder` , zavolejte `UseKestrel` na tvůrce webového hostitele v `ConfigureWebHostDefaults` :

```csharp
public static void Main(string[] args)
{
    var host = new HostBuilder()
        .UseContentRoot(Directory.GetCurrentDirectory())
        .ConfigureWebHostDefaults(webBuilder =>
        {
            webBuilder.UseKestrel(serverOptions =>
            {
                // Set properties and call methods on options
            })
            .UseIISIntegration()
            .UseStartup<Startup>();
        })
        .Build();

    host.Run();
}
```

### <a name="connection-middleware-replaces-connection-adapters"></a>Middleware připojení nahrazuje adaptéry připojení

Připojovací adaptéry ( `Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.IConnectionAdapter` ) byly odebrány z Kestrel. Nahraďte připojovací adaptéry pomocí middleware připojení. Middleware připojení se podobá middlewaru protokolu HTTP v kanálu ASP.NET Core, ale pro připojení nižší úrovně. Protokol HTTPS a protokolování připojení:

* Byly přesunuty z připojovacích adaptérů na middleware připojení.
* Tyto metody rozšíření fungují jako v předchozích verzích ASP.NET Core. 

Další informace najdete v [příkladu TlsFilterConnectionHandler v části ListenOptions. Protocols článku Kestrel](/aspnet/core/fundamentals/servers/kestrel?view=aspnetcore-3.0#listenoptionsprotocols).

### <a name="transport-abstractions-moved-and-made-public"></a>Přemístění a zpřístupnění abstrakcí přenosu

Přenosová vrstva Kestrel byla vystavena jako veřejné rozhraní v `Connections.Abstractions` . Jako součást těchto aktualizací:

* `Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions`a přidružené typy byly odebrány.
* <xref:Microsoft.AspNetCore.Server.Kestrel.KestrelServerOptions.NoDelay>byl přesunut z <xref:Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions> na možnosti přenosu.
* `Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions.Internal.SchedulingMode`bylo odebráno z <xref:Microsoft.AspNetCore.Server.Kestrel.KestrelServerOptions> .

Další informace najdete v následujících materiálech GitHubu:

* [Abstrakce sítě klienta/serveru (dotnet/AspNetCore #10308)](https://github.com/dotnet/AspNetCore/issues/10308)
* [Implementujte nové abstrakce naslouchacího procesu Bedrock a Kestrel znovu platně (dotnet/AspNetCore #10321)](https://github.com/dotnet/AspNetCore/pull/10321)

### <a name="kestrel-request-trailer-headers"></a>Hlavičky přípojných vozidel žádosti Kestrel

Pro aplikace, které cílí na starší verze ASP.NET Core:

* Kestrel přidá hlavičky přípojného bodu HTTP/1.1 do kolekce hlaviček požadavků.
* Po načtení textu žádosti na konec jsou k dispozici Přípojná místa.

To způsobuje některé obavy z nejednoznačnosti mezi hlavičkami a přípojnými vozidly, takže přípojná vozidla byla přesunuta do nové kolekce ( `RequestTrailerExtensions` ) v 3,0.

Přívěsy žádostí HTTP/2 jsou:

* Není k dispozici v ASP.NET Core 2,2.
* K dispozici v 3,0 jako `RequestTrailerExtensions` .

Pro přístup k těmto přípojným vozidlům jsou k dispozici nové metody rozšíření žádosti. Stejně jako v případě protokolu HTTP/1.1 jsou po načtení textu žádosti na konec k dispozici Přípojná místa.

Pro vydání 3,0 `RequestTrailerExtensions` jsou k dispozici následující metody:

* `GetDeclaredTrailers`: Načte hlavičku žádosti `Trailer` , která obsahuje seznam přípojných vozidel, která se mají očekávat za textem.
* `SupportsTrailers`: Určuje, zda požadavek podporuje příjem hlaviček přípojných vozidel.
* `CheckTrailersAvailable`: Kontroluje, zda požadavek podporuje Přípojná místa, a pokud jsou k dispozici pro čtení. Tato kontrolu nepředpokládá, že existuje přívěsy ke čtení. Není možné, aby bylo možné číst bez přípojných míst, i když `true` je tato metoda vrácena.
* `GetTrailer`: Načte požadované koncové záhlaví z odpovědi. `SupportsTrailers`Před voláním `GetTrailer` nebo se <xref:System.NotSupportedException> může vyskytnout, pokud požadavek nepodporuje koncové hlavičky.

Další informace najdete v tématu [o umístění přípojných vozidel v samostatné kolekci (dotnet/AspNetCore #10410)](https://github.com/dotnet/AspNetCore/pull/10410).

### <a name="allowsynchronousio-disabled"></a>AllowSynchronousIO zakázané

`AllowSynchronousIO`povoluje nebo zakazuje synchronní vstupně-výstupní rozhraní API, například, `HttpRequest.Body.Read` `HttpResponse.Body.Write` a `Stream.Flush` . Tato rozhraní API jsou zdrojem vyčerpání vláken, který vede k selhání aplikace. V 3,0 `AllowSynchronousIO` je ve výchozím nastavení zakázáno. Další informace najdete v [části synchronní v/v v článku Kestrel](/aspnet/core/fundamentals/servers/kestrel?view=aspnetcore-3.0#synchronous-io).

Pokud je potřeba synchronní vstupně-výstupní operace, můžete ji povolit nakonfigurováním `AllowSynchronousIO` Možnosti na serveru, který se používá (například při volání `ConfigureKestrel` , pokud používáte Kestrel). Upozorňujeme, že servery (Kestrel, HttpSys, TestServer atd.) mají svou vlastní `AllowSynchronousIO` možnost, která nebude mít vliv na ostatní servery. Synchronní vstupně-výstupní operace lze povolit pro všechny servery na základě jednotlivých požadavků pomocí `IHttpBodyControlFeature.AllowSynchronousIO` Možnosti:

```csharp
var syncIOFeature = HttpContext.Features.Get<IHttpBodyControlFeature>();

if (syncIOFeature != null)
{
    syncIOFeature.AllowSynchronousIO = true;
}
```

Pokud máte problémy s <xref:System.IO.TextWriter> implementacemi nebo jinými datovými proudy, které volají synchronní rozhraní API v [Dispose](/dotnet/standard/garbage-collection/implementing-dispose), zavolejte <xref:System.IO.Stream.DisposeAsync*> místo toho nové rozhraní API.

Další informace najdete v tématu [[oznámení] AllowSynchronousIO zakázáno na všech serverech (dotnet/AspNetCore #7644)](https://github.com/dotnet/AspNetCore/issues/7644).

### <a name="output-formatter-buffering"></a>Výstupní vyrovnávací paměť formátovacího modulu

Výstupní formátovací moduly založené [na,Newtonsoft.Js](https://www.newtonsoft.com/json), <xref:System.Xml.Serialization.XmlSerializer> a <xref:System.Runtime.Serialization.DataContractSerializer> podporují pouze synchronní serializaci. Aby mohly tyto formátovací moduly fungovat s [AllowSynchronousIOmi](https://github.com/dotnet/aspnetcore/issues/7644) omezeními serveru, MVC před zápisem na disk uloží výstup těchto formátovacích modulů do vyrovnávací paměti. V důsledku ukládání do vyrovnávací paměti MVC zahrne záhlaví Content-Length při reagování na použití těchto formátovacích modulů.

<xref:System.Text.Json>podporuje asynchronní serializaci a v důsledku toho `System.Text.Json` formátování na bázi neukládá do vyrovnávací paměti. Zvažte použití tohoto formátovacího modulu pro zlepšení výkonu.

Pokud chcete zakázat ukládání do vyrovnávací paměti, můžou se aplikace konfigurovat <xref:Microsoft.AspNetCore.Mvc.MvcOptions.SuppressOutputFormatterBuffering> při spuštění:

```csharp
services.AddControllers(options => options.SuppressOutputFormatterBuffering = true)
```

Všimněte si, že to může způsobit, že aplikace vyvolává výjimku za běhu, pokud `AllowSynchronousIO` není nakonfigurována také.

### <a name="microsoftaspnetcoreserverkestrelhttps-assembly-removed"></a>Bylo odebráno sestavení Microsoft. AspNetCore. Server. Kestrel. https.

V ASP.NET Core 2,1 byl obsah *Microsoft.AspNetCore.Server.Kestrel.Https.dll* přesunut do *Microsoft.AspNetCore.Server.Kestrel.Core.dll*. Toto byla neprůlomová aktualizace pomocí `TypeForwardedTo` atributů. Pro 3,0 byla odebrána prázdná *Microsoft.AspNetCore.Server.Kestrel.Https.dll* sestavení a balíček NuGet.

Knihovny odkazující na [Microsoft. AspNetCore. Server. Kestrel. https](https://www.nuget.org/packages/Microsoft.AspNetCore.Server.Kestrel.Https) by měly aktualizovat ASP.NET Core závislosti na 2,1 nebo novější.

Aplikace a knihovny cílené na ASP.NET Core 2,1 nebo novější by měly odebrat všechny přímé odkazy na balíček [Microsoft. AspNetCore. Server. Kestrel. https](https://www.nuget.org/packages/Microsoft.AspNetCore.Server.Kestrel.Https) .

<a id="jsonnet-support"></a>

## <a name="newtonsoftjson-jsonnet-support"></a>Podpora Newtonsoft.Json (Json.NET)

Jako součást práce pro [zlepšení ASP.NET Core sdíleného rozhraní](https://blogs.msdn.microsoft.com/webdev/2018/10/29/a-first-look-at-changes-coming-in-asp-net-core-3-0/)se [Newtonsoft.Jsna (JSON.NET)](https://www.newtonsoft.com/json/help/html/Introduction.htm) odebrala ze ASP.NET Core sdílené architektury.

Výchozí serializátor JSON pro ASP.NET Core je teď <xref:System.Text.Json> , což je v .NET Core 3,0 nové. Zvažte použití `System.Text.Json` , pokud je to možné. Je to vysoký výkon a nevyžaduje další závislost knihovny. Jelikož je však `System.Text.Json` novinkou, může v současnosti chybět funkce, které vaše aplikace potřebuje. Další informace najdete v tématu [Postup migrace z Newtonsoft.Jsna do System.Text.Jsna](/dotnet/standard/serialization/system-text-json-migrate-from-newtonsoft-how-to).

### <a name="use-newtonsoftjson-in-an-aspnet-core-30-signalr-project"></a>Použití Newtonsoft.Jsv projektu ASP.NET Core 3,0 SignalR

* Nainstalujte [Microsoft. AspNetCore. SignalR . Balíček NuGet Protocols. NewtonsoftJson](https://www.nuget.org/packages/Microsoft.AspNetCore.SignalR.Protocols.NewtonsoftJson)

* Na straně klienta řetězit `AddNewtonsoftJsonProtocol` volání metody do `HubConnectionBuilder` instance:

  ```csharp
  new HubConnectionBuilder()
      .WithUrl("/chathub")
      .AddNewtonsoftJsonProtocol(...)
      .Build();
  ```

* Na serveru řetězit `AddNewtonsoftJsonProtocol` volání `AddSignalR` metody volání metody `Startup.ConfigureServices` :

  ```csharp
  services.AddSignalR()
      .AddNewtonsoftJsonProtocol(...);
  ```

### <a name="use-newtonsoftjson-in-an-aspnet-core-30-mvc-project"></a>Použití Newtonsoft.Jsv projektu ASP.NET Core 3,0 MVC

* Nainstalujte [`Microsoft.AspNetCore.Mvc.NewtonsoftJson`](https://nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson) balíček.

* Aktualizujte `Startup.ConfigureServices` volání `AddNewtonsoftJson` .

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson();
  ```

  `AddNewtonsoftJson`je kompatibilní s novými metodami registrace služby MVC:

  * `AddRazorPages`
  * `AddControllersWithViews`
  * `AddControllers`

  ```csharp
  services.AddControllers()
      .AddNewtonsoftJson();
  ```

  `Newtonsoft.Json`nastavení lze nastavit v volání `AddNewtonsoftJson` :

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson(options =>
             options.SerializerSettings.ContractResolver =
                new CamelCasePropertyNamesContractResolver());
  ```

**Poznámka:** Pokud tato `AddNewtonsoftJson` metoda není k dispozici, ujistěte se, že jste [`Microsoft.AspNetCore.Mvc.NewtonsoftJson`](https://nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson) balíček nainstalovali. Běžnou chybou je instalace [Newtonsoft.Jsdo](https://www.nuget.org/packages/Newtonsoft.Json/) balíčku namísto [`Microsoft.AspNetCore.Mvc.NewtonsoftJson`](https://nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson) balíčku.

## <a name="mvc-service-registration"></a>Registrace služby MVC

ASP.NET Core 3,0 přidává nové možnosti pro registraci scénářů MVC v rámci `Startup.ConfigureServices` .

K dispozici jsou tři nové metody rozšíření na nejvyšší úrovni související s scénáři MVC `IServiceCollection` . Šablony používají tyto nové metody místo `AddMvc` . Nicméně se `AddMvc` i nadále chová jako v předchozích verzích.

Následující příklad přidá podporu pro řadiče a funkce související s rozhraním API, ale ne zobrazení nebo stránky. Šablona rozhraní API používá tento kód:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllers();
}
```

Následující příklad přidá podporu pro řadiče, funkce související s rozhraním API a zobrazení, ale ne stránky. Šablona webové aplikace (MVC) používá tento kód:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews();
}
```

V následujícím příkladu je přidána podpora pro Razor stránky a minimální Podpora řadičů. Šablona webové aplikace používá tento kód:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddRazorPages();
}
```

Nové metody lze také kombinovat. Následující příklad je ekvivalentní volání `AddMvc` v ASP.NET Core 2,2:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews();
    services.AddRazorPages();
}
```

## <a name="routing-startup-code"></a>Spouštěcí kód směrování

Pokud je to aplikace `UseMvc` , nebo pokud je `UseSignalR` to možné, proveďte migraci aplikace do [Směrování koncových bodů](xref:fundamentals/routing) . Pro zlepšení kompatibility směrování koncových bodů s předchozími verzemi MVC jsme vrátili některé změny v adrese URL představené v ASP.NET Core 2,2. Pokud jste narazili na problémy s používáním směrování koncových bodů v 2,2, můžete očekávat vylepšení ASP.NET Core 3,0 s následujícími výjimkami:

* Pokud aplikace implementuje `IRouter` nebo dědí z `Route` , použijte jako náhradu [DynamicRouteValuesTransformer](https://github.com/dotnet/AspNetCore.Docs/issues/12997) .
* Pokud aplikace přímo přistupuje `RouteData.Routers` k analýze adres URL v rámci MVC, můžete ji nahradit použitím [LinkParser. ParsePathByEndpointName](xref:Microsoft.AspNetCore.Routing.LinkParserEndpointNameAddressExtensions.ParsePathByEndpointName*). 
  * Zadejte trasu s názvem trasy.
  * Použijte `LinkParser.ParsePathByEndpointName` a předejte název požadované trasy.

Směrování koncového bodu podporuje stejnou syntaxi vzorů směrování a funkce vytváření vzorů směrování jako `IRouter` . Směrování koncového bodu podporuje `IRouteConstraint` . Směrování koncového bodu podporuje `[Route]` , `[HttpGet]` a další atributy směrování MVC.

Pro většinu aplikací vyžaduje pouze `Startup` změny.

### <a name="migrate-startupconfigure"></a>Migrace Startup.Configurovat

Obecné pokyny:

* Přidat `UseRouting` .
* Pokud je aplikace volána `UseStaticFiles` , umístěte `UseStaticFiles` **před** `UseRouting` .
* Pokud aplikace používá funkce ověřování/autorizace, jako je `AuthorizePage` nebo `[Authorize]` , umístěte volání do `UseAuthentication` a `UseAuthorization` : **After**a `UseRouting` `UseCors` , ale před `UseEndpoints` :

  ```csharp
  public void Configure(IApplicationBuilder app)
  {
    ...

    app.UseStaticFiles();

    app.UseRouting();
    app.UseCors();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints => {
       endpoints.MapControllers();
    });
  ```

* Nahraďte `UseMvc` nebo `UseSignalR` s `UseEndpoints` .
* Pokud aplikace používá scénáře [CORS](xref:security/cors) , například `[EnableCors]` , umístěte volání do `UseCors` jakéhokoli jiného middlewaru, který používá CORS (například na místo `UseCors` před `UseAuthentication` , `UseAuthorization` a `UseEndpoints` ).
* Nahraďte `IHostingEnvironment` `IWebHostEnvironment` `using` výrazem a přidejte příkaz pro <xref:Microsoft.Extensions.Hosting?displayProperty=fullName> obor názvů.
* Nahraďte `IApplicationLifetime` <xref:Microsoft.Extensions.Hosting.IHostApplicationLifetime> ( <xref:Microsoft.Extensions.Hosting?displayProperty=fullName> oborem názvů).
* Nahraďte `EnvironmentName` <xref:Microsoft.Extensions.Hosting.Environments> ( <xref:Microsoft.Extensions.Hosting?displayProperty=fullName> oborem názvů).

Následující kód je příkladem `Startup.Configure` typické aplikace ASP.NET Core 2,2:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();

    app.UseAuthentication();

    app.UseSignalR(hubs =>
    {
        hubs.MapHub<ChatHub>("/chat");
    });

    app.UseMvc(routes =>
    {
        routes.MapRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

Po aktualizaci předchozího `Startup.Configure` kódu:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();

    app.UseRouting();

    app.UseCors();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>("/chat");
        endpoints.MapControllerRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

> [!WARNING]
> Pro většinu aplikací se volání `UseAuthentication` , `UseAuthorization` a `UseCors` musí objevit mezi voláními `UseRouting` a v `UseEndpoints` platnosti.

### <a name="health-checks"></a>Kontroly stavu

Kontroly stavu používají směrování koncových bodů u obecného hostitele. V `Startup.Configure` nástroji zavolejte `MapHealthChecks` na tvůrce koncového bodu s adresou URL koncového bodu nebo relativní cestou:

```csharp
app.UseEndpoints(endpoints =>
{
    endpoints.MapHealthChecks("/health");
});
```

Koncové body kontrol stavu můžou:

* Zadejte minimálně jednoho povoleného hostitele nebo portů.
* Vyžadovat autorizaci.
* Vyžadovat CORS

Další informace naleznete v tématu <xref:host-and-deploy/health-checks>.

### <a name="security-middleware-guidance"></a>Doprovodné materiály k zabezpečení middlewaru

Podpora pro autorizaci a CORS je sjednocená v rámci přístupu [middlewaru](xref:fundamentals/middleware/index) . To umožňuje používat stejný middlewar a funkčnost v těchto scénářích. V této verzi je k dispozici aktualizovaný middleware autorizace a middleware CORS je vylepšený, aby bylo možné pochopit atributy používané řadiči MVC.

#### <a name="cors"></a>CORS

V minulosti mohlo být obtížné nakonfigurovat CORS. Middleware byl poskytnut pro použití v některých případech použití, ale filtry MVC byly určeny k použití **bez** middlewaru v jiných případech použití. U ASP.NET Core 3,0 doporučujeme, aby všechny aplikace, které vyžadují CORS, používaly middleware CORS v kombinaci s směrováním koncových bodů. `UseCors`dá se zadat s výchozí zásadou a pomocí `[EnableCors]` `[DisableCors]` atributů můžete v případě potřeby přepsat výchozí zásady.

V následujícím příkladu:

* U všech koncových bodů s `default` pojmenovanou zásadou je povolená CORS.
* `MyController`Třída ZAKÁŽE CORS s `[DisableCors]` atributem.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseCors("default");

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[DisableCors]
public class MyController : ControllerBase
{
    ...
}
```

#### <a name="authorization"></a>Autorizace

V dřívějších verzích ASP.NET Core byla poskytnuta podpora autorizace prostřednictvím `[Authorize]` atributu. Autorizační middleware není k dispozici. V ASP.NET Core 3,0 se vyžaduje middleware autorizace. Doporučujeme umístit middleware autorizace ASP.NET Core ( `UseAuthorization` ) hned po `UseAuthentication` . Middleware autorizace se dá nakonfigurovat taky s výchozími zásadami, které se dají přepsat.

V ASP.NET Core 3,0 nebo novějším se `UseAuthorization` volá v `Startup.Configure` a následující `HomeController` vyžaduje přihlášeného uživatele:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

public class HomeController : Controller
{
    [Authorize]
    public IActionResult BuyWidgets()
    {
        ...
    }
}
```

Při použití směrování koncového bodu doporučujeme nakonfigurovat `<xref:Microsoft.AspNetCore.Mvc.Authorization.AuthorizeFilter>` a místo toho spoléhat na middleware autorizace.  Pokud aplikace používá `AuthorizeFilter` jako globální filtr v MVC, doporučujeme v volání metody refaktoring kódu, aby poskytovala zásady `AddAuthorization` .

`DefaultPolicy`Je zpočátku nakonfigurovaný tak, aby vyžadoval ověřování, takže se nevyžaduje žádná další konfigurace. V následujícím příkladu jsou koncové body MVC označeny jako `RequireAuthorization` tak, že všechny požadavky musí být autorizovány na základě `DefaultPolicy` . `HomeController`Povolit přístup bez přihlášení uživatele do aplikace je však z důvodu `[AllowAnonymous]` :

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute().RequireAuthorization();
    });
}

[AllowAnonymous]
public class HomeController : Controller
{
    ...
}
```

### <a name="authorization-for-specific-endpoints"></a>Autorizace pro konkrétní koncové body

Autorizaci lze také nakonfigurovat pro konkrétní třídy koncových bodů. Následující kód je příkladem převodu aplikace MVC, která nakonfigurovala globální `AuthorizeFilter` aplikaci na aplikaci s konkrétní zásadou, která vyžaduje autorizaci:

[!code-csharp[](22-to-30/samples/Startup.cs?name=snippet&highlight=8-9,21-22,26-27,53-54)]

Zásady je také možné přizpůsobit. `DefaultPolicy`Je nakonfigurován tak, aby vyžadoval ověřování:

[!code-csharp[](22-to-30/samples/Startup2.cs?name=snippet&highlight=21-26,52)]

[!code-csharp[](22-to-30/samples/HomeController.cs?name=snippet)]

Alternativně lze všechny koncové body nakonfigurovat tak, aby vyžadovaly autorizaci bez `[Authorize]` nebo `RequireAuthorization` konfigurací `FallbackPolicy` . Se `FallbackPolicy` liší od `DefaultPolicy` . `DefaultPolicy`Spustí se `[Authorize]` nebo `RequireAuthorization` , když se `FallbackPolicy` aktivuje, když nejsou nastavené žádné jiné zásady. `FallbackPolicy`je zpočátku nakonfigurovaný tak, aby povoloval požadavky bez autorizace.

Následující příklad je stejný jako předchozí `DefaultPolicy` příklad, ale používá, `FallbackPolicy` aby vždy vyžadoval ověřování u všech koncových bodů s výjimkou případů, kdy `[AllowAnonymous]` je zadána:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    ...

    services.AddAuthorization(options =>
    {
        options.FallbackPolicy = new AuthorizationPolicyBuilder()
          .RequireAuthenticatedUser()
          .Build();
    });
}

public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[AllowAnonymous]
public class HomeController : Controller
{
    ...
}
```

Ověřování pomocí middlewaru funguje bez rozhraní, které má konkrétní znalosti o autorizaci. [Kontroly stavu](xref:host-and-deploy/health-checks) například nemají žádné konkrétní znalosti o autorizaci, ale kontroly stavu můžou mít konfigurovatelné zásady autorizace, které používá middleware.

Každý koncový bod navíc může přizpůsobit své autorizační požadavky. V následujícím příkladu `UseAuthorization` zpracovává autorizaci pomocí nástroje `DefaultPolicy` , ale `/healthz` koncový bod kontroly stavu vyžaduje `admin` uživatele:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints
            .MapHealthChecks("/healthz")
            .RequireAuthorization(new AuthorizeAttribute(){ Roles = "admin", });
    });
}
```

Ochrana je implementovaná pro některé scénáře. Middleware koncové body vyvolá výjimku, pokud se zásada autorizace nebo CORS z důvodu chybějícího middlewaru přeskočí. Podpora analyzátoru, která poskytuje další názory na neplatnou konfiguraci.

#### <a name="custom-authorization-handlers"></a>Vlastní obslužné rutiny autorizace

Pokud aplikace používá vlastní [obslužné rutiny autorizace](xref:security/authorization/policies#authorization-handlers), směrování koncového bodu předá obslužné rutině od MVC jiný typ prostředku. Obslužné rutiny, které očekávají, že prostředek kontextu obslužné rutiny autorizace mají typ <xref:Microsoft.AspNetCore.Mvc.Filters.AuthorizationFilterContext> (typ prostředku [poskytovaný filtry MVC](xref:security/authorization/policies#access-mvc-request-context-in-handlers)), se musí aktualizovat, aby se zpracovaly prostředky typu <xref:Microsoft.AspNetCore.Routing.RouteEndpoint> (typ prostředku, který se předala obslužným rutinám autorizace podle směrování koncových bodů).

MVC stále používá `AuthorizationFilterContext` prostředky, takže pokud aplikace používá autorizační filtry MVC spolu s autorizací směrování koncových bodů, může být nutné zpracovat oba typy prostředků.

### SignalR

Mapování SignalR Center se teď provádí v rámci `UseEndpoints` .

Namapujte každé centrum pomocí `MapHub` . Stejně jako v předchozích verzích je každé centrum výslovně uvedené.

V následujícím příkladu `ChatHub` SignalR se přidá podpora centra:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>();
    });
}
```

Pro řízení omezení velikosti zprávy od klientů je k dispozici nová možnost. Například v `Startup.ConfigureServices` :

```csharp
services.AddSignalR(hubOptions =>
{
    hubOptions.MaximumReceiveMessageSize = 32768;
});
```

V ASP.NET Core 2,2 můžete nastavit `TransportMaxBufferSize` a, které by účinně ovládají maximální velikost zprávy. V ASP.NET Core 3,0 Tato možnost nyní určuje pouze maximální velikost před nedodržením přítlaku.

### <a name="mvc-controllers"></a>Řadiče MVC

Mapování řadičů se teď provádí v rámci `UseEndpoints` .

Přidejte, `MapControllers` Pokud aplikace používá směrování atributů. Vzhledem k tomu, že směrování zahrnuje podporu pro mnoho platforem v ASP.NET Core 3,0 nebo novějších, je přidání řadičů směrovaných k atributům výslovný souhlas.

Nahraďte následující:

* `MapRoute`řetězce`MapControllerRoute`
* `MapAreaRoute`řetězce`MapAreaControllerRoute`

Vzhledem k tomu, že směrování nyní zahrnuje podporu pro více než jen MVC, se terminologie změnila, aby tyto metody jasně zajistila, co dělají. Konvenční trasy, například `MapControllerRoute` / `MapAreaControllerRoute` / `MapDefaultControllerRoute` , jsou aplikovány v pořadí, v jakém byly přidány. Nejprve umístěte konkrétnější trasy (například trasy pro oblast).

V následujícím příkladu:

* `MapControllers`Přidá podporu pro řadiče směrované atributy.
* `MapAreaControllerRoute`Přidá konvenční trasu pro řadiče v oblasti.
* `MapControllerRoute`Přidá konvenční trasu pro řadiče.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapControllers();
        endpoints.MapAreaControllerRoute(
            "admin",
            "admin",
            "Admin/{controller=Home}/{action=Index}/{id?}");
        endpoints.MapControllerRoute(
            "default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

#### <a name="async-suffix-removal-from-controller-action-names"></a>Odebrání asynchronní přípony z názvů akcí kontroleru

V ASP.NET Core 3,0 ASP.NET Core MVC odstraní `Async` příponu z názvů akcí řadiče. Tato nová výchozí hodnota má vliv na generaci směrování i propojení. Například:

```csharp
public class ProductsController : Controller
{
    public async Task<IActionResult> ListAsync()
    {
        var model = await _dbContext.Products.ToListAsync();
        return View(model);
    }
}
```

Před ASP.NET Core 3,0:

* K předchozí akci může být přistup v trase *Products/ListAsync* .
* Vyžaduje se vytváření odkazů, které určuje `Async` příponu. Například:

    ```cshtml
    <a asp-controller="Products" asp-action="ListAsync">List</a>
    ```

V ASP.NET Core 3,0:

* Předchozí akce je k dispozici na trase *Products/List* .
* Generování propojení nevyžaduje zadání `Async` přípony. Například:

    ```cshtml
    <a asp-controller="Products" asp-action="List">List</a>
    ```

Tato změna nemá vliv na názvy zadané pomocí [`[ActionName]`](/dotnet/api/microsoft.aspnetcore.mvc.actionnameattribute) atributu. Výchozí chování lze zakázat pomocí následujícího kódu v `Startup.ConfigureServices` :

```csharp
services.AddMvc(options =>
    options.SuppressAsyncSuffixInActionNames = false);
```

#### <a name="changes-to-link-generation"></a>Změny při vytváření propojení

Jak je vysvětleno v dokumentaci k [rozdílům z dřívějších verzí směrování](xref:fundamentals/routing#differences-from-earlier-versions-of-routing), existují rozdíly v generování odkazů ( `Url.Link` například pomocí a podobných rozhraní API). Zde jsou některé z nich:

* Ve výchozím nastavení platí, že při použití směrování koncových bodů není velká a malá písmena parametrů trasy v generovaných identifikátorech URI nutně zachovaná. Toto chování lze řídit pomocí `IOutboundParameterTransformer` rozhraní.
* Generování identifikátoru URI pro neplatnou trasu (kontroler/akce nebo stránka, která neexistuje) vytvoří v rámci směrování koncového bodu prázdný řetězec místo vytvoření neplatného identifikátoru URI.
* Okolní hodnoty (parametry tras z aktuálního kontextu) se automaticky nepoužívají při vytváření odkazů s směrováním koncových bodů. Dříve při generování odkazu na jinou akci (nebo stránku) byly neurčené hodnoty tras odvozeny od hodnot okolí *aktuální* trasy. Při použití směrování koncového bodu musí být všechny parametry směrování explicitně zadané během generování propojení.

### <a name="razor-pages"></a>RazorStránky

RazorStránky mapování teď probíhá uvnitř `UseEndpoints` .

Přidejte `MapRazorPages` , pokud aplikace používá Razor stránky. Vzhledem k tomu, že směrování koncových bodů zahrnuje podporu pro spoustu platforem, je teď přihlášená možnost Přidat Razor stránky.

V následující `Startup.Configure` metodě `MapRazorPages` přidá podporu pro Razor stránky:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapRazorPages();
    });
}
```

### <a name="use-mvc-without-endpoint-routing"></a>Použití MVC bez směrování koncových bodů

Použití MVC prostřednictvím `UseMvc` nebo `UseMvcWithDefaultRoute` v ASP.NET Core 3,0 vyžaduje explicitní výslovný souhlas v rámci `Startup.ConfigureServices` . To je nutné, protože MVC musí zjistit, jestli se může při inicializaci spoléhat na autorizaci a middleware CORS. K dispozici je analyzátor, který se upozorní, pokud se aplikace pokusí použít nepodporovanou konfiguraci.

Pokud aplikace vyžaduje starší verzi `IRouter` podpory, zakažte `EnableEndpointRouting` použití některého z následujících přístupů v nástroji `Startup.ConfigureServices` :

```csharp
services.AddMvc(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllers(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllersWithViews(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddRazorPages().AddMvcOptions(options => options.EnableEndpointRouting = false);
```

### <a name="health-checks"></a>Kontroly stavu

Kontroly stavu lze použít jako *směrovač* s směrováním koncových bodů.

Přidejte `MapHealthChecks` k použití kontrol stavu pomocí směrování koncových bodů. `MapHealthChecks`Metoda přijímá argumenty podobné `UseHealthChecks` . Výhodou použití funkce `MapHealthChecks` over `UseHealthChecks` je možnost použít autorizaci a mít větší jemně odstupňovanou kontrolu nad zásadami pro porovnání.

V následujícím příkladu `MapHealthChecks` je volána pro koncový bod kontroly stavu v `/healthz` :

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHealthChecks("/healthz", new HealthCheckOptions() { });
    });
}
```

<a name="hostb"></a>

## <a name="hostbuilder-replaces-webhostbuilder"></a>HostBuilder nahrazuje WebHostBuilder

Šablony ASP.NET Core 3,0 používají [obecného hostitele](xref:fundamentals/host/generic-host). Předchozí verze používaly [webového hostitele](xref:fundamentals/host/web-host). Následující kód ukazuje třídu vygenerovanou šablonou ASP.NET Core 3,0 `Program` :

[!code-csharp[](22-to-30/samples/Program.cs?name=snippet)]

Následující kód ukazuje třídu vygenerovanou šablonou ASP.NET Core 2,2 `Program` :

[!code-csharp[](22-to-30/samples/Program2.2.cs?name=snippet)]

<xref:Microsoft.AspNetCore.Hosting.IWebHostBuilder>zůstává v 3,0 a je typ `webBuilder` zobrazený v předchozí ukázce kódu. <xref:Microsoft.AspNetCore.Hosting.WebHostBuilder>bude zastaralá v budoucí verzi a nahrazena nástrojem `HostBuilder` .

Nejvýznamnější změna z `WebHostBuilder` na `HostBuilder` je v [vkládání závislostí (di)](xref:fundamentals/dependency-injection). Při použití nástroje `HostBuilder` lze vložit do konstruktoru pouze následující `Startup` :

* <xref:Microsoft.Extensions.Configuration.IConfiguration>
* <xref:Microsoft.Extensions.Hosting.IHostEnvironment>
* <xref:Microsoft.AspNetCore.Hosting.IWebHostEnvironment>

`HostBuilder`Omezení di:

* Povolí sestavení kontejneru DI jenom jednou.
* Předejde výsledným problémům životního cyklu objektů, jako je například řešení více instancí singleton.

Další informace najdete v tématu [předcházení vkládání spouštěcích služeb v ASP.NET Core 3](https://andrewlock.net/avoiding-startup-service-injection-in-asp-net-core-3/).

## <a name="addauthorization-moved-to-a-different-assembly"></a>AddAuthorization přesunuté do jiného sestavení

ASP.NET Core 2,2 a nižší `AddAuthorization` metody v *Microsoft.AspNetCore.Authorization.dll*:

* Bylo přejmenováno `AddAuthorizationCore` .
* Byly přesunuty na *Microsoft.AspNetCore.Authorization.Policy.dll*.

Aplikace, které používají *Microsoft.AspNetCore.Authorization.dll* i *Microsoft.AspNetCore.Authorization.Policy.dll* , nejsou ovlivněné.

Aplikace, které nepoužívají *Microsoft.AspNetCore.Authorization.Policy.dll* by měly provádět jednu z následujících akcí:

* Přidejte odkaz na *Microsoft.AspNetCore.Authorization.Policy.dll*. Tento přístup je vhodný pro většinu aplikací a je nutný.
* Přepnout na použití`AddAuthorizationCore`

Další informace naleznete v tématu zásadní [Změna v `AddAuthorization(o =>` ) přetížení života v jiném sestavení #386](https://github.com/aspnet/Announcements/issues/386).

## <a name="identity-ui"></a>IdentityROZHRANÍ

IdentityAktualizace uživatelského rozhraní pro ASP.NET Core 3,0:

* Přidat odkaz na balíček do [Microsoft. AspNetCore. Identity . Uživatelské rozhraní](https://nuget.org/packages/Microsoft.AspNetCore.Identity.UI).
* Aplikace, které nepoužívají Razor stránky, musí volat `MapRazorPages` . Zobrazit [ Razor stránky](#razor-pages) v tomto dokumentu.
* Výchozí architektura uživatelského rozhraní je Bootstrap 4. Nastavte `IdentityUIFrameworkVersion` vlastnost projektu, aby se změnila výchozí hodnota. Další informace najdete v [tomto oznámení GitHubu](https://github.com/aspnet/Announcements/issues/380).

## SignalR

SignalRKlient jazyka JavaScript se změnil z `@aspnet/signalr` na `@microsoft/signalr` . Chcete-li reagovat na tuto změnu, změňte odkazy v *package.jsu* souborů, `require` příkazů a příkazů jazyka ECMAScript `import` .

### <a name="systemtextjson-is-the-default-protocol"></a>System.Text.Jsje výchozí protokol

`System.Text.Json`je teď výchozím protokolem rozbočovače používaným klientem i serverem.

V nástroji `Startup.ConfigureServices` zavolejte `AddJsonProtocol` na nastavit možnosti serializátoru.

**WebServer**

```csharp
services.AddSignalR(...)
        .AddJsonProtocol(options =>
        {
            options.PayloadSerializerOptions.WriteIndented = false;
        })
```

**Služba**

```csharp
new HubConnectionBuilder()
    .WithUrl("/chathub")
    .AddJsonProtocol(options =>
    {
        options.PayloadSerializerOptions.WriteIndented = false;
    })
    .Build();
```

### <a name="switch-to-newtonsoftjson"></a>Přepnout na Newtonsoft.Js

Pokud používáte [funkce Newtonsoft.Js, které nejsou podporované v System.Text.Jsna](/dotnet/standard/serialization/system-text-json-migrate-from-newtonsoft-how-to), můžete přejít zpátky na `Newtonsoft.Json` . Další informace najdete v tématu [použití Newtonsoft.Jsv v SignalR projektu ASP.NET Core 3,0](#use-newtonsoftjson-in-an-aspnet-core-30-signalr-project) výše v tomto článku.

## <a name="redis-distributed-caches"></a>Redis distribuované mezipaměti

Balíček [Microsoft. Extensions. Caching. Redis](https://www.nuget.org/packages/Microsoft.Extensions.Caching.Redis) není dostupný pro aplikace ASP.NET Core 3,0 nebo novější. Nahraďte odkaz na balíček příponou [Microsoft. Extensions. Caching. StackExchangeRedis](https://www.nuget.org/packages/Microsoft.Extensions.Caching.StackExchangeRedis). Další informace naleznete v tématu <xref:performance/caching/distributed>.

## <a name="opt-in-to-runtime-compilation"></a>Přihlásit se ke kompilaci za běhu

Před ASP.NET Core 3,0 byla kompilace zobrazení běhového prostředí implicitní funkcí rozhraní. Kompilace za běhu doplňuje kompilaci zobrazení v době sestavení. Umožňuje rozhraní kompilovat Razor zobrazení a stránky (soubory *. cshtml* ) při změně souborů, aniž by bylo nutné znovu sestavit celou aplikaci. Tato funkce podporuje scénář pro rychlé úpravy v integrovaném vývojovém prostředí (IDE) a aktualizaci prohlížeče pro zobrazení změn.

V ASP.NET Core 3,0 je kompilace modulu runtime v případě výslovného souhlasu. Kompilace při sestavení je jediným mechanismem pro zobrazení kompilace, která je ve výchozím nastavení povolená. Modul runtime spoléhá na aplikaci Visual Studio nebo [dotnet – Sledujte](xref:tutorials/dotnet-watch) v Visual Studio Code pro opětovné sestavení projektu, když detekuje změny souborů *. cshtml* . V aplikaci Visual Studio se změny v souborech *. cs*, *. cshtml*nebo *. Razor* v projektu spouštějí (<kbd>CTRL + F5</kbd>), ale ne laděné (<kbd>F5</kbd>), spusťte opětovnou kompilaci projektu.

Povolení kompilace za běhu v projektu ASP.NET Core 3,0:

1. Nainstalujte [Microsoft. AspNetCore. Mvc. Razor . ](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation)Balíček NuGet RuntimeCompilation
1. Aktualizovat `Startup.ConfigureServices` volání `AddRazorRuntimeCompilation` :

    Pro ASP.NET Core MVC použijte následující kód:

    ```csharp
    services.AddControllersWithViews()
        .AddRazorRuntimeCompilation(...);
    ```
 
    Pro ASP.NET Core Razor stránky použijte následující kód:
 
    ```csharp
    services.AddRazorPages()
        .AddRazorRuntimeCompilation(...);
    ```
 
Ukázka v https://github.com/aspnet/samples/tree/master/samples/aspnetcore/mvc/runtimecompilation ukazuje příklad povolení běhové kompilace podmíněně ve vývojových prostředích.

Další informace o Razor kompilaci souborů naleznete v tématu <xref:mvc/views/view-compilation> .

## <a name="migrate-libraries-via-multi-targeting"></a>Migrace knihoven přes cílení na více platforem

Knihovny často potřebují podporovat více verzí ASP.NET Core. Většina knihoven kompilovaných pro předchozí verze ASP.NET Core by měla pokračovat bez problémů. Následující podmínky vyžadují křížové kompilování aplikace:

* Knihovna se spoléhá na funkci, která má binární zásadní [změnu](#breaking-api-changes).
* Knihovna chce využívat nové funkce v ASP.NET Core 3,0. 

Například:

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFrameworks>netcoreapp3.0;netstandard2.0</TargetFrameworks>
  </PropertyGroup>

  <ItemGroup Condition="'$(TargetFramework)' == 'netcoreapp3.0'">
    <FrameworkReference Include="Microsoft.AspNetCore.App" />
  </ItemGroup>

  <ItemGroup Condition="'$(TargetFramework)' == 'netstandard2.0'">
    <PackageReference Include="Microsoft.AspNetCore" Version="2.1.0" />
  </ItemGroup>
</Project>
```

Použijte `#ifdefs` k povolení rozhraní API specifických pro ASP.NET Core 3,0:

```csharp
var webRootFileProvider =
#if NETCOREAPP3_0
    GetRequiredService<IWebHostEnvironment>().WebRootFileProvider;
#elif NETSTANDARD2_0
    GetRequiredService<IHostingEnvironment>().WebRootFileProvider;
#else
#error unknown target framework
#endif
```

Další informace o použití rozhraní API ASP.NET Core v knihovně tříd naleznete v tématu <xref:fundamentals/target-aspnetcore> .

## <a name="miscellaneous-changes"></a>Různé změny

Systém ověřování v .NET Core 3,0 a novějším zpracovává parametry bez hodnoty null nebo vázané vlastnosti, jako kdyby měl `[Required]` atribut. Další informace naleznete v tématu [[required] Attribute](xref:mvc/models/validation?view=aspnetcore-3.1#required-attribute).

### <a name="publish"></a>Publikování

Odstraňte složky *bin* a *obj* v adresáři projektu.

## <a name="testserver"></a>TestServer

U aplikací, které <xref:Microsoft.AspNetCore.TestHost.TestServer> se používají přímo u [obecného hostitele](xref:fundamentals/host/web-host), vytvořte v nástroji `TestServer` <xref:Microsoft.AspNetCore.Hosting.IWebHostBuilder> <xref:Microsoft.Extensions.Hosting.GenericHostWebHostBuilderExtensions.ConfigureWebHost%2A> :

```csharp
[Fact]
public async Task GenericCreateAndStartHost_GetTestServer()
{
    using var host = await new HostBuilder()
        .ConfigureWebHost(webBuilder =>
        {
            webBuilder
                .UseTestServer()
                .Configure(app => { });
        })
    .StartAsync();

    var response = await host.GetTestServer().CreateClient().GetAsync("/");

    Assert.Equal(HttpStatusCode.NotFound, response.StatusCode);
}
```

<a name="break"></a>

## <a name="breaking-api-changes"></a>Přerušení změn rozhraní API

Kontrola nejnovějších změn:

* [Úplný seznam nejnovějších změn v ASP.NET Core vydání 3,0](https://github.com/aspnet/Announcements/issues?page=1&q=is%3Aissue+is%3Aopen+label%3A%22Breaking+change%22+label%3A3.0.0)
* [Rušení změn rozhraní API v antipadělání, CORS, diagnostice, MVC a směrování](https://github.com/aspnet/Announcements/issues/387). Tento seznam obsahuje zásadní změny pro přepínače kompatibility.
* Shrnutí 2,2-až 3,0 přerušující změny v rámci .NET Core, ASP.NET Core a Entity Framework Core najdete v tématu [přerušující změny migrace z verze 2,2 na 3,0](/dotnet/core/compatibility/2.2-3.0).

## <a name="endpoint-routing-with-catch-all-parameter"></a>Směrování koncového bodu s parametrem catch-All

[!INCLUDE[](~/includes/catchall.md)]

## <a name="net-core-30-on-azure-app-service"></a>.NET Core 3,0 na Azure App Service

Zavedení .NET Core do Azure App Service je dokončené. .NET Core 3,0 je k dispozici ve všech datových centrech Azure App Service.
