---
title: Migrace z ASP.NET Core 2,2 na 3,0
author: rick-anderson
description: Přečtěte si, jak migrovat projekt ASP.NET Core 2,2 do ASP.NET Core 3,0.
ms.author: riande
ms.custom: mvc
ms.date: 10/08/2019
uid: migration/22-to-30
ms.openlocfilehash: 509f3d7be032bef0c993e8f3dfa5dad52629b114
ms.sourcegitcommit: fcdf9aaa6c45c1a926bd870ed8f893bdb4935152
ms.translationtype: HT
ms.contentlocale: cs-CZ
ms.lasthandoff: 10/09/2019
ms.locfileid: "72165425"
---
# <a name="migrate-from-aspnet-core-22-to-30"></a>Migrace z ASP.NET Core 2,2 na 3,0

[Scottem Addie](https://github.com/scottaddie) a [Rick Anderson](https://twitter.com/RickAndMSFT)

Tento článek vysvětluje, jak aktualizovat existující projekt ASP.NET Core 2,2 na ASP.NET Core 3,0.

## <a name="prerequisites"></a>Požadavky

# <a name="visual-studiotabvisual-studio"></a>[Visual Studio](#tab/visual-studio)

[!INCLUDE[](~/includes/net-core-prereqs-vs-3.0.md)]

# <a name="visual-studio-codetabvisual-studio-code"></a>[Visual Studio Code](#tab/visual-studio-code)

[!INCLUDE[](~/includes/net-core-prereqs-vsc-3.0.md)]

# <a name="visual-studio-for-mactabvisual-studio-mac"></a>[Visual Studio for Mac](#tab/visual-studio-mac)

[!INCLUDE[](~/includes/net-core-prereqs-mac-3.0.md)]

---

## <a name="update-net-core-sdk-version-in-globaljson"></a>Aktualizace verze .NET Core SDK v Global. JSON

Pokud vaše řešení využívá soubor [Global. JSON](/dotnet/core/tools/global-json) pro cílení na konkrétní verzi .NET Core SDK, aktualizujte jeho vlastnost `version` na verzi 3,0 nainstalovanou na vašem počítači:

```json
{
  "sdk": {
    "version": "3.0.100"
  }
}
```

## <a name="update-the-project-file"></a>Aktualizovat soubor projektu

### <a name="update-the-target-framework"></a>Aktualizace cílového rozhraní .NET Framework

ASP.NET Core 3,0 a novější se spouští pouze v .NET Core. Nastavte [moniker cílového Frameworku (TFM)](/dotnet/standard/frameworks) na `netcoreapp3.0`:

[!code-xml[](22-to-30/samples/Web1.csproj?highlight=4)]

### <a name="remove-obsolete-package-references"></a>Odebrat zastaralé odkazy na balíčky

ASP.NET Core už nevytváří velký počet funkcí balíčků NuGet. Tyto odkazy na balíčky by měly být odebrány ze souboru projektu. Například soubor projektu generovaný šablonou pro webovou aplikaci ASP.NET Core 2,2:

```xml
<Project Sdk="Microsoft.NET.Sdk.Web">

  <PropertyGroup>
    <TargetFramework>netcoreapp2.2</TargetFramework>
    <AspNetCoreHostingModel>InProcess</AspNetCoreHostingModel>
  </PropertyGroup>


  <ItemGroup>
    <PackageReference Include="Microsoft.AspNetCore.App"/>
    <PackageReference Include="Microsoft.AspNetCore.Razor.Design" Version="2.2.0" PrivateAssets="All" />
  </ItemGroup>

</Project>
```

Aktualizovaný soubor projektu ASP.NET Core 3,0:

[!code-xml[](22-to-30/samples/Web1.csproj?highlight=4)]

Aktualizovaný soubor projektu ASP.NET Core 3,0:

* V `<PropertyGroup>`:

  * Aktualizuje TFM na `netcoreapp3.0`.
  * Odebere prvek `<AspNetCoreHostingModel>`. Další informace najdete v tématu [model hostování v procesu](#in-process-hosting-model) v tomto dokumentu.

* V `<ItemGroup>`:

  * @no__t – 0 se odebere. Další informace najdete v tématu [Reference k rozhraní](#framework-reference) v tomto dokumentu.
  * `Microsoft.AspNetCore.Razor.Design` se odebere a v následujícím seznamu se už neprodukují balíčky.

Úplný seznam balíčků, které už nejsou vytvořené, zobrazíte tak, že vyberete následující seznam rozbalit:

<details>
    <summary>Kliknutím sem rozbalíte seznam balíčků, které už nejsou vyráběny.</summary>
    <ul>
        <li>Microsoft.AspNetCore</li>
        <li>Microsoft.AspNetCore.All</li>
        <li>Microsoft.AspNetCore.App</li>
        <li>Microsoft.AspNetCore.Antiforgery</li>
        <li>Microsoft.AspNetCore.Authentication</li>
        <li>Microsoft.AspNetCore.Authentication.Abstractions</li>
        <li>Microsoft.AspNetCore.Authentication.Cookies</li>
        <li>Microsoft.AspNetCore.Authentication.Core</li>
        <li>Microsoft.AspNetCore.Authentication.JwtBearer</li>
        <li>Microsoft.AspNetCore.Authentication.OAuth</li>
        <li>Microsoft.AspNetCore.Authentication.OpenIdConnect</li>
        <li>Microsoft.AspNetCore.Authorization</li>
        <li>Microsoft.AspNetCore.Authorization.Policy</li>
        <li>Microsoft.AspNetCore.CookiePolicy</li>
        <li>Microsoft.AspNetCore.Cors</li>
        <li>Microsoft.AspNetCore.Cryptography.Internal</li>
        <li>Microsoft.AspNetCore.Cryptography.KeyDerivation</li>
        <li>Microsoft.AspNetCore.DataProtection</li>
        <li>Microsoft.AspNetCore.DataProtection.Abstractions</li>
        <li>Microsoft.AspNetCore.DataProtection.Extensions</li>
        <li>Microsoft.AspNetCore.Diagnostics</li>
        <li>Microsoft.AspNetCore.Diagnostics.HealthChecks</li>
        <li>Microsoft.AspNetCore.HostFiltering</li>
        <li>Microsoft.AspNetCore.Hosting</li>
        <li>Microsoft.AspNetCore.Hosting.Abstractions</li>
        <li>Microsoft.AspNetCore.Hosting.Server.Abstractions</li>
        <li>Microsoft.AspNetCore.Http</li>
        <li>Microsoft.AspNetCore.Http.Abstractions</li>
        <li>Microsoft.AspNetCore.Http.Connections</li>
        <li>Microsoft.AspNetCore.Http.Extensions</li>
        <li>Microsoft.AspNetCore.Http.Features</li>
        <li>Microsoft.AspNetCore.HttpOverrides</li>
        <li>Microsoft.AspNetCore.HttpsPolicy</li>
        <li>Microsoft.AspNetCore.Identity</li>
        <li>Microsoft.AspNetCore.Localization</li>
        <li>Microsoft.AspNetCore.Localization.Routing</li>
        <li>Microsoft.AspNetCore.MiddlewareAnalysis</li>
        <li>Microsoft.AspNetCore.Mvc</li>
        <li>Microsoft.AspNetCore.Mvc.Abstractions</li>
        <li>Microsoft.AspNetCore.Mvc.Analyzers</li>
        <li>Microsoft.AspNetCore.Mvc.ApiExplorer</li>
        <li>Microsoft.AspNetCore.Mvc.Api.Analyzers</li>
        <li>Microsoft.AspNetCore.Mvc.Core</li>
        <li>Microsoft.AspNetCore.Mvc.Cors</li>
        <li>Microsoft.AspNetCore.Mvc.DataAnnotations</li>
        <li>Microsoft.AspNetCore.Mvc.Formatters.Json</li>
        <li>Microsoft.AspNetCore.Mvc.Formatters.Xml</li>
        <li>Microsoft.AspNetCore.Mvc.Localization</li>
        <li>Microsoft.AspNetCore.Mvc.Razor</li>
        <li>Microsoft.AspNetCore.Mvc.Razor.Extensions</li>
        <li>Microsoft.AspNetCore.Mvc.Razor.ViewCompilation</li>
        <li>Microsoft.AspNetCore.Mvc.RazorPages</li>
        <li>Microsoft.AspNetCore.Mvc.TagHelpers</li>
        <li>Microsoft.AspNetCore.Mvc.ViewFeatures</li>
        <li>Microsoft.AspNetCore.Razor</li>
        <li>Microsoft.AspNetCore.Razor.Runtime</li>
        <li>Microsoft.AspNetCore.Razor.Design</li>
        <li>Microsoft.AspNetCore.ResponseCaching</li>
        <li>Microsoft.AspNetCore.ResponseCaching.Abstractions</li>
        <li>Microsoft.AspNetCore.ResponseCompression</li>
        <li>Microsoft.AspNetCore.Rewrite</li>
        <li>Microsoft.AspNetCore.Routing</li>
        <li>Microsoft.AspNetCore.Routing.Abstractions</li>
        <li>Microsoft.AspNetCore.Server.HttpSys</li>
        <li>Microsoft.AspNetCore.Server.IIS</li>
        <li>Microsoft.AspNetCore.Server.IISIntegration</li>
        <li>Microsoft.AspNetCore.Server.Kestrel</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Core</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Https</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets</li>
        <li>Microsoft.AspNetCore.Session</li>
        <li>Microsoft.AspNetCore.SignalR</li>
        <li>Microsoft.AspNetCore.SignalR.Core</li>
        <li>Microsoft.AspNetCore.StaticFiles</li>
        <li>Microsoft.AspNetCore.WebSockets</li>
        <li>Microsoft.AspNetCore.WebUtilities</li>
        <li>Microsoft.Net. http. Headers</li>
    </ul>
</details>

### <a name="review-breaking-changes"></a>Kontrola nejnovějších změn

[Kontrola nejnovějších změn](#break)

### <a name="framework-reference"></a>Odkaz na rozhraní

Funkce ASP.NET Core, které byly k dispozici prostřednictvím jednoho z výše uvedených balíčků, jsou k dispozici jako součást sdíleného rozhraní `Microsoft.AspNetCore.App`. *Sdílené rozhraní* je sada sestavení (soubory *. dll* ), které jsou nainstalovány na počítači a zahrnují komponentu modulu runtime a sadu targeting pack. Další informace najdete v tématu [sdílené rozhraní](https://natemcmaster.com/blog/2018/08/29/netcore-primitives-2/).

* Projekty, které cílí na sadu SDK `Microsoft.NET.Sdk.Web` implicitně odkazují na rozhraní `Microsoft.AspNetCore.App`.

Pro tyto projekty nejsou vyžadovány žádné další odkazy:

```xml
<Project Sdk="Microsoft.NET.Sdk.Web">
  <PropertyGroup>
    <TargetFramework>netcoreapp3.0</TargetFramework>
  </PropertyGroup>
    ...
</Project>
```

* Projekty, které cílí na `Microsoft.NET.Sdk` nebo `Microsoft.NET.Sdk.Razor` SDK, by měly přidat explicitní `FrameworkReference` do `Microsoft.AspNetCore.App`:

```xml
<Project Sdk="Microsoft.NET.Sdk.Razor">
  <PropertyGroup>
    <TargetFramework>netcoreapp3.0</TargetFramework>
  </PropertyGroup>

  <ItemGroup>
    <FrameworkReference Include="Microsoft.AspNetCore.App" />
  </ItemGroup>
    ...
</Project>
```

#### <a name="framework-dependent-builds-using-docker"></a>Sestavení závislá na rozhraních pomocí Docker

Sestavení závislé na rozhraních konzolových aplikací, které používají balíček, který závisí na ASP.NET Core [sdílenému rozhraní](https://natemcmaster.com/blog/2018/08/29/netcore-primitives-2/) , mohou poskytnout následující chybu za běhu:

```console
It was not possible to find any compatible framework version
The specified framework 'Microsoft.AspNetCore.App', version '3.0.0' was not found.
  - No frameworks were found.
```

`Microsoft.AspNetCore.App` je sdílené rozhraní obsahující ASP.NET Core Runtime a je přítomno pouze v imagi [dotnet/Core/ASPNET](https://hub.docker.com/_/microsoft-dotnet-core-aspnet/) Docker.  Sada SDK 3,0 omezuje velikost závislých sestavení pomocí asp.net jádra, protože nezahrnuje duplicitní kopie knihoven, které jsou k dispozici ve sdíleném rozhraní.  Jedná se o potenciální úspory až 18 MB, ale vyžaduje, aby se při spuštění aplikace mohl spustit modul runtime ASP.NET Core nebo musí být nainstalovaný.

Pokud chcete zjistit, jestli má aplikace závislost (buď přímá, nebo nepřímá) na ASP.NET Core sdíleném rozhraním, Projděte si soubor *runtimeconfig. JSON* vygenerovaný během sestavování/publikování vaší aplikace. Následující soubor JSON ukazuje závislost na ASP.NET Core sdílené rozhraní:

```json
{
  "runtimeOptions": {
    "tfm": "netcoreapp3.0",
    "framework": {
      "name": "Microsoft.AspNetCore.App",
      "version": "3.0.0"
    },
    "configProperties": {
      "System.GC.Server": true
    }
  }
}
```

Pokud vaše aplikace používá Docker, použijte základní image, která zahrnuje ASP.NET Core 3,0. Například, `docker pull mcr.microsoft.com/dotnet/core/aspnet:3.0`.

### <a name="add-package-references-for-removed-assemblies"></a>Přidat odkazy na balíčky pro odebraná sestavení

ASP.NET Core 3,0 odstraní některá sestavení, která byla dříve součástí odkazu na balíček `Microsoft.AspNetCore.App`. Chcete-li pokračovat v používání funkcí poskytovaných těmito sestaveními, odkazujte na verze 3,0 odpovídajících balíčků:

* Webová aplikace vygenerovaná šablonou s **jednotlivými uživatelskými účty** vyžaduje přidání následujících balíčků:

  [!code-xml[](22-to-30/samples/WebFull.csproj?highlight=9-13)]

* [Microsoft. EntityFrameworkCore](https://www.nuget.org/packages/Microsoft.EntityFrameworkCore)

  Další informace o odkazování na balíček pro konkrétního poskytovatele databáze najdete v tématu [poskytovatelé databáze](/ef/core/providers/index).

* Uživatelské rozhraní identity

  Podporu [uživatelského rozhraní identity](xref:security/authentication/identity) lze přidat odkazem na balíček [Microsoft. AspNetCore. identity. UI](https://www.nuget.org/packages/Microsoft.AspNetCore.Identity.UI) .

* Služby SPA

  * [Microsoft. AspNetCore. SpaServices](https://www.nuget.org/packages/Microsoft.AspNetCore.SpaServices)
  * [Microsoft. AspNetCore. SpaServices. Extensions](https://www.nuget.org/packages/Microsoft.AspNetCore.SpaServices.Extensions)

* Ověřování &ndash;: podpora toků ověřování třetích stran je k dispozici jako balíčky NuGet:

  * Facebook OAuth ([Microsoft. AspNetCore. Authentication. Facebook](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Facebook))
  * Google OAuth ([Microsoft. AspNetCore. Authentication. Google](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Google))
  * Token nosiče OpenID Connect ([Microsoft. AspNetCore. Authentication. JwtBearer](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.JwtBearer))
  * Ověřování účtu Microsoft ([Microsoft. AspNetCore. Authentication. MicrosoftAccount](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.MicrosoftAccount))
  * OpenID Connect Authentication ([Microsoft. AspNetCore. Authentication. OpenIdConnect](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.OpenIdConnect))
  * Twitter OAuth ([Microsoft. AspNetCore. Authentication. Twitter](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Twitter))
  * Ověřování WsFederation ([Microsoft. AspNetCore. Authentication. WsFederation](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.WsFederation))

* Podpora vyjednávání formátování a obsahu pro `System.Net.HttpClient` &ndash; balíček NuGet [Microsoft. ASPNET. WebApi. Client](https://www.nuget.org/packages/Microsoft.AspNet.WebApi.Client/) poskytuje užitečnou rozšiřitelnost pro `System.Net.HttpClient` s rozhraními API, jako je například `ReadAsAsync`, `PostJsonAsync` atd.

* Běhová kompilace Razor &ndash; Podpora pro kompilaci za běhu zobrazení Razor a stránek je teď součástí [Microsoft. AspNetCore. Mvc. Razor. RuntimeCompilation](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation).

* MVC `Newtonsoft.Json` Podpora &ndash; Podpora pro použití MVC s `Newtonsoft.Json` je teď součástí [Microsoft. AspNetCore. Mvc. NewtonsoftJson](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson).

## <a name="startup-changes"></a>Změny při spuštění

Na následujícím obrázku vidíte odstraněný a změněný řádek ve webové aplikaci ASP.NET Core 2,2 Razor Pages:

![odstraněné a změněné řádky ve webové aplikaci ASP.NET Core 2,2 Razor](22-to-30/_static/startup2.2.png)

Na předchozím obrázku se odstraněný kód zobrazuje červeně. Odstraněný kód nezobrazuje kód možnosti souboru cookie, který byl odstraněn před porovnáním souborů.

Na následujícím obrázku vidíte přidané a změněné řádky ve webové aplikaci ASP.NET Core 3,0 Razor Pages:

![přidané a změněné řádky ve webové aplikaci ASP.NET Core 3,0 Razor](22-to-30/_static/startup3.0.png)

Na předchozím obrázku se přidaný kód zobrazuje zeleně. Informace o následujících změnách:

* `services.AddMvc` do `services.AddRazorPages` viz [Registrace služby MVC](#mvc-service-registration) v tomto dokumentu.
* `CompatibilityVersion`, viz <xref:mvc/compatibility-version>.
* `IHostingEnvironment` do `IWebHostEnvironment` se podívejte na [Toto oznámení GitHubu](https://github.com/aspnet/AspNetCore/issues/7749).
* do šablon se přidala hodnota `app.UseAuthorization`, aby se zobrazilo, že se musí přidat middleware pro autorizaci. Pokud aplikace nepoužívá autorizaci, můžete hovor bezpečně odebrat `app.UseAuthorization`.
* `app.UseEndpoints`, přečtěte si téma [Razor Pages](#razor-pages) nebo [migruje Startup. Configure](#migrate-startupconfigure) v tomto dokumentu.

### <a name="analyzer-support"></a>Podpora analyzátoru

Projekty, které cílí na `Microsoft.NET.Sdk.Web` implicitně odkazují na analyzátory dříve dodávané jako součást balíčku [Microsoft. AspNetCore. Mvc. analyzers](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Analyzers/) . K povolení těchto kroků nejsou vyžadovány žádné další odkazy.

Pokud vaše aplikace používá [analyzátory rozhraní API](xref:web-api/advanced/analyzers) dříve dodávané pomocí balíčku [Microsoft. AspNetCore. Mvc. API. analyzers](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Api.Analyzers/) , upravte soubor projektu tak, aby odkazoval na analyzátory dodávané jako součást sady .NET Core web SDK:

```xml
<Project Sdk="Microsoft.NET.Sdk.Web">
    <PropertyGroup>
        <TargetFramework>netcoreapp3.0</TargetFramework>
        <IncludeOpenAPIAnalyzers>true</IncludeOpenAPIAnalyzers>
    </PropertyGroup>

    ...
</Project>
```

### <a name="razor-class-library"></a>Knihovna tříd Razor

Projekty knihovny tříd Razor, které poskytují komponenty uživatelského rozhraní pro MVC musí nastavit vlastnost `AddRazorSupportForMvc` v souboru projektu:

```xml
<PropertyGroup>
  <AddRazorSupportForMvc>true</AddRazorSupportForMvc>
</PropertyGroup>
```

### <a name="in-process-hosting-model"></a>Model hostování v procesu

Projekty jsou ve výchozím nastavení pro [model hostování v rámci procesu](xref:host-and-deploy/aspnet-core-module#in-process-hosting-model) v ASP.NET Core 3,0 nebo novějším. Případně můžete odebrat vlastnost `<AspNetCoreHostingModel>` v souboru projektu, pokud je její hodnota `InProcess`.

## <a name="kestrel"></a>Kestrel

### <a name="configuration"></a>Konfiguraci

Migrujte konfiguraci Kestrel do Tvůrce webového hostitele, který poskytuje `ConfigureWebHostDefaults` (*program.cs*):

```csharp
public static IHostBuilder CreateHostBuilder(string[] args) =>
    Host.CreateDefaultBuilder(args)
        .ConfigureWebHostDefaults(webBuilder =>
        {
            webBuilder.ConfigureKestrel(serverOptions =>
            {
                // Set properties and call methods on options
            })
            .UseStartup<Startup>();
        });
```

Pokud aplikace vytvoří hostitele ručně pomocí `HostBuilder`, volejte `UseKestrel` na tvůrci webového hostitele v `ConfigureWebHostDefaults`:

```csharp
public static void Main(string[] args)
{
    var host = new HostBuilder()
        .UseContentRoot(Directory.GetCurrentDirectory())
        .ConfigureWebHostDefaults(webBuilder =>
        {
            webBuilder.UseKestrel(serverOptions =>
            {
                // Set properties and call methods on options
            })
            .UseIISIntegration()
            .UseStartup<Startup>();
        })
        .Build();

    host.Run();
}
```

### <a name="connection-middleware-replaces-connection-adapters"></a>Middleware připojení nahrazuje adaptéry připojení

Připojovací adaptéry (<xref:Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.IConnectionAdapter>) byly odebrány z Kestrel. Nahraďte připojovací adaptéry pomocí middleware připojení. Middleware připojení se podobá middlewaru protokolu HTTP v kanálu ASP.NET Core, ale pro připojení nižší úrovně. Protokol HTTPS a protokolování připojení:

* Byly přesunuty z připojovacích adaptérů na middleware připojení.
* Tyto metody rozšíření fungují jako v předchozích verzích ASP.NET Core. 

Další informace najdete v [příkladu TlsFilterConnectionHandler v části ListenOptions. Protocols článku Kestrel](/aspnet/core/fundamentals/servers/kestrel?view=aspnetcore-3.0#listenoptionsprotocols).

### <a name="transport-abstractions-moved-and-made-public"></a>Přemístění a zpřístupnění abstrakcí přenosu

Transportní vrstva Kestrel byla vystavena jako veřejné rozhraní v `Connections.Abstractions`. Jako součást těchto aktualizací:

* `Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions` a přidružené typy byly odebrány.
* <xref:Microsoft.AspNetCore.Server.Kestrel.KestrelServerOptions.NoDelay> se přesunul z <xref:Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions> na možnosti transportu.
* <xref:Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions.Internal.SchedulingMode> byl odebrán z <xref:Microsoft.AspNetCore.Server.Kestrel.KestrelServerOptions>.

Další informace najdete v následujících materiálech GitHubu:

* [Abstrakce sítě klienta/serveru (ASPNET/AspNetCore #10308)](https://github.com/aspnet/AspNetCore/issues/10308)
* [Implementujte nové abstrakce naslouchacího procesu Bedrock a Kestrel znovu platně (ASPNET/AspNetCore #10321)](https://github.com/aspnet/AspNetCore/pull/10321)

### <a name="kestrel-request-trailer-headers"></a>Hlavičky přípojných vozidel žádosti Kestrel

Pro aplikace, které cílí na starší verze ASP.NET Core:

* Kestrel přidá hlavičky přípojného bodu HTTP/1.1 do kolekce hlaviček požadavků.
* Po načtení textu žádosti na konec jsou k dispozici Přípojná místa.

To způsobuje některé obavy z nejednoznačnosti mezi hlavičkami a přípojnou čárkou, takže přípojná vozidla byla přesunuta do nové kolekce (`RequestTrailerExtensions`) v 3,0.

Přívěsy žádostí HTTP/2 jsou:

* Není k dispozici v ASP.NET Core 2,2.
* K dispozici v 3,0 jako `RequestTrailerExtensions`.

Pro přístup k těmto přípojným vozidlům jsou k dispozici nové metody rozšíření žádosti. Stejně jako v případě protokolu HTTP/1.1 jsou po načtení textu žádosti na konec k dispozici Přípojná místa.

Pro vydání 3,0 jsou k dispozici následující metody `RequestTrailerExtensions`:

* `GetDeclaredTrailers` &ndash; načte hlavičku Request `Trailer`, která uvádí, která přípojná vozidla se mají po tělo očekávat.
* `SupportsTrailers` &ndash; označuje, zda požadavek podporuje příjem hlaviček přípojných vozidel.
* `CheckTrailersAvailable` &ndash; kontroluje, zda požadavek podporuje Přípojná místa, a pokud jsou k dispozici pro čtení. Tato kontrolu nepředpokládá, že existuje přívěsy ke čtení. Není možné, aby bylo možné číst bez přípojných vozidel i v případě, že tato metoda vrací `true`.
* `GetTrailer` &ndash; načte požadované koncové záhlaví z odpovědi. @No__t-0 před voláním `GetTrailer` nebo <xref:System.NotSupportedException> může nastat, pokud požadavek nepodporuje koncové hlavičky.

Další informace najdete v tématu [o umístění přípojných vozidel v samostatné kolekci (ASPNET/AspNetCore #10410)](https://github.com/aspnet/AspNetCore/pull/10410).

### <a name="allowsynchronousio-disabled"></a>AllowSynchronousIO zakázané

`AllowSynchronousIO` povolí nebo zakáže synchronní rozhraní API pro vstupně-výstupní operace, například `HttpRequest.Body.Read`, `HttpResponse.Body.Write` a `Stream.Flush`. Tato rozhraní API jsou zdrojem vyčerpání vláken, který vede k selhání aplikace. V 3,0 je ve výchozím nastavení zakázáno `AllowSynchronousIO`. Další informace najdete [v části synchronní v/v v článku Kestrel](/aspnet/core/fundamentals/servers/kestrel?view=aspnetcore-3.0#synchronous-io).

Kromě povolení `AllowSynchronousIO` s možnostmi `ConfigureKestrel` lze synchronní vstupně-výstupní operace na základě jednotlivých požadavků přepsat také jako dočasné zmírnění:

```csharp
var syncIOFeature = HttpContext.Features.Get<IHttpBodyControlFeature>();

if (syncIOFeature != null)
{
    syncIOFeature.AllowSynchronousIO = true;
}
```

Pokud máte potíže s implementacemi <xref:System.IO.TextWriter> nebo jinými datovými proudy, které volají synchronní rozhraní API v [Dispose](/dotnet/standard/garbage-collection/implementing-dispose), zavolejte místo toho nové rozhraní API <xref:System.IO.Stream.DisposeAsync*>.

Další informace najdete v tématu [[oznámení] AllowSynchronousIO zakázáno na všech serverech (ASPNET/AspNetCore #7644)](https://github.com/aspnet/AspNetCore/issues/7644).

### <a name="microsoftaspnetcoreserverkestrelhttps-assembly-removed"></a>Bylo odebráno sestavení Microsoft. AspNetCore. Server. Kestrel. https.

V ASP.NET Core 2,1 se obsah souboru *Microsoft. AspNetCore. Server. Kestrel. https. dll* přesunul do souboru *Microsoft. AspNetCore. Server. Kestrel. Core. dll*. Toto byla neprůlomová aktualizace pomocí atributů `TypeForwardedTo`. Pro 3,0 byla odebrána prázdná sestavení *Microsoft. AspNetCore. Server. Kestrel. https. dll* a balíček NuGet.

Knihovny odkazující na [Microsoft. AspNetCore. Server. Kestrel. https](https://www.nuget.org/packages/Microsoft.AspNetCore.Server.Kestrel.Https) by měly aktualizovat ASP.NET Core závislosti na 2,1 nebo novější.

Aplikace a knihovny cílené na ASP.NET Core 2,1 nebo novější by měly odebrat všechny přímé odkazy na balíček [Microsoft. AspNetCore. Server. Kestrel. https](https://www.nuget.org/packages/Microsoft.AspNetCore.Server.Kestrel.Https) .

## <a name="jsonnet-support"></a>Podpora Json.NET

Jako součást práce pro [zlepšení ASP.NET Core sdílené architektury](https://blogs.msdn.microsoft.com/webdev/2018/10/29/a-first-look-at-changes-coming-in-asp-net-core-3-0/)se [JSON.NET](https://www.newtonsoft.com/json/help/html/Introduction.htm) z ASP.NET Core sdílené architektury odebral.

Výchozí hodnota pro ASP.NET Core je Now [System. text. JSON](/dotnet/api/system.text.json?view=netcore-3.0), která je v .net Core 3,0 novinkou. Pokud je to možné, zvažte použití `System.Text.Json`. Je to vysoký výkon a nevyžaduje další závislost knihovny. Vzhledem k tomu, že je `System.Text.Json` novinkou, může v současnosti chybět funkce, které vaše aplikace potřebuje.

Vaše aplikace může vyžadovat integraci `Newtonsoft.Json`, pokud používá @no__t funkce specifické pro -1, jako je JsonPatch nebo převaděče, nebo pokud [formátuje](xref:web-api/advanced/formatting) @no__t konkrétní typy -3.

Pokud chcete používat Json.NET v projektu nástroje ASP.NET Core 3,0, přečtěte si téma [Přepnutí na Newtonsoft. JSON](#switch-to-newtonsoftjson) v tomto dokumentu.

Použití Json.NET v projektu ASP.NET Core 3,0:

* Přidejte odkaz na balíček [Microsoft. AspNetCore. Mvc. NewtonsoftJson](https://nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson).
* Aktualizace `Startup.ConfigureServices` pro volání `AddNewtonsoftJson`.

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson();
  ```

  `AddNewtonsoftJson` je kompatibilní s novými metodami registrace služby MVC:

  * `AddRazorPages`
  * `AddControllersWithViews`
  * `AddControllers`

  ```csharp
  services.AddControllers()
      .AddNewtonsoftJson();
  ```

  Nastavení Json.NET lze nastavit při volání `AddNewtonsoftJson`:

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson(options =>
             options.SerializerSettings.ContractResolver =
                new CamelCasePropertyNamesContractResolver());
  ```

## <a name="mvc-service-registration"></a>Registrace služby MVC

ASP.NET Core 3,0 přidává nové možnosti pro registraci scénářů MVC v rámci `Startup.ConfigureServices`.

K dispozici jsou tři nové metody rozšíření na nejvyšší úrovni související se scénáři MVC na `IServiceCollection`. Šablony používají tyto nové metody místo `UseMvc`. @No__t-0 se však nadále chová stejně jako v předchozích verzích.

Následující příklad přidá podporu pro řadiče a funkce související s rozhraním API, ale ne zobrazení nebo stránky. Šablona rozhraní API používá tento kód:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllers();
}
```

Následující příklad přidá podporu pro řadiče, funkce související s rozhraním API a zobrazení, ale ne stránky. Šablona webové aplikace (MVC) používá tento kód:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews();
}
```

V následujícím příkladu se přidá podpora pro Razor Pages a minimální Podpora řadičů. Šablona webové aplikace používá tento kód:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddRazorPages();
}
```

Nové metody lze také kombinovat. Následující příklad je ekvivalentní volání `AddMvc` v ASP.NET Core 2,2:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews();
    services.AddRazorPages();
}
```

## <a name="routing-startup-code"></a>Spouštěcí kód směrování

Pokud aplikace volá `UseMvc` nebo `UseSignalR`, migrujte aplikaci do [Směrování koncových bodů](xref:fundamentals/routing) , pokud je to možné. Pro zlepšení kompatibility směrování koncových bodů s předchozími verzemi MVC jsme vrátili některé změny v adrese URL představené v ASP.NET Core 2,2. Pokud jste narazili na problémy s používáním směrování koncových bodů v 2,2, můžete očekávat vylepšení ASP.NET Core 3,0 s následujícími výjimkami:

* Pokud aplikace implementuje `IRouter` nebo se dědí z `Route`, použijte jako náhradu [DynamicRouteValuesTransformer](https://github.com/aspnet/AspNetCore.Docs/issues/12997) .

* Pokud aplikace přímo přistupuje k `RouteData.Routers` uvnitř MVC k analýze adres URL, můžete to nahradit použitím `LinkParser.ParsePathByEndpointName`. 
 * Zadejte trasu s názvem trasy.
 * Použijte `LinkParser.ParsePathByEndpointName` a předejte název požadované trasy.

Směrování koncového bodu podporuje stejnou syntaxi vzorů směrování a funkce vytváření vzorů směrování jako `IRouter`. Směrování koncového bodu podporuje `IRouteConstraint`. Směrování koncového bodu podporuje `[Route]`, `[HttpGet]` a další atributy směrování MVC.

U většiny aplikací vyžaduje pouze `Startup` změn.

### <a name="migrate-startupconfigure"></a>Migrovat Startup. Configure

Obecné pokyny:

* Přidejte `UseRouting`.
* Pokud aplikace zavolá `UseStaticFiles`, umístěte `UseStaticFiles` **před** `UseRouting`.
* Pokud aplikace používá funkce ověřování/autorizace, například `AuthorizePage` nebo `[Authorize]`, umístěte volání do `UseAuthentication` a `UseAuthorization`: **po**`UseRouting` a `UseCors`, ale před `UseEndpoints`:

  ```csharp
  public void Configure(IApplicationBuilder app)
  {
    ...

    app.UseStaticFiles();

    app.UseRouting();
    app.UseCors();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints => {
       endpoints.MapControllers();
    });
  ```

* Nahraďte `UseMvc` nebo `UseSignalR` s `UseEndpoints`.
* Pokud aplikace používá scénáře [CORS](xref:security/cors) , například `[EnableCors]`, umístěte volání `UseCors` před jakékoli jiné middlewary, které používají CORS (například na místě `UseCors` před `UseAuthentication`, `UseAuthorization` a `UseEndpoints`).
* Nahraďte `IHostingEnvironment` pomocí `IWebHostEnvironment` a přidejte příkaz `using` pro obor názvů <xref:Microsoft.Extensions.Hosting?displayProperty=fullName>.
* Nahraďte `IApplicationLifetime` řetězcem <xref:Microsoft.Extensions.Hosting.IHostApplicationLifetime> (obor názvů <xref:Microsoft.Extensions.Hosting?displayProperty=fullName>).
* Nahraďte `EnvironmentName` řetězcem <xref:Microsoft.Extensions.Hosting.Environments> (obor názvů <xref:Microsoft.Extensions.Hosting?displayProperty=fullName>).

Následující kód je příkladem `Startup.Configure` v typické aplikaci ASP.NET Core 2,2:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();

    app.UseAuthentication();

    app.UseSignalR(hubs =>
    {
        hubs.MapHub<ChatHub>("/chat");
    });

    app.UseMvc(routes =>
    {
        routes.MapRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

Po aktualizaci předchozího kódu `Startup.Configure`:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();

    app.UseRouting();

    app.UseCors();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>("/chat");
        endpoints.MapControllerRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

> [!WARNING]
> Pro většinu aplikací musí být volání `UseAuthentication`, `UseAuthorization` a `UseCors` mezi voláními `UseRouting` a `UseEndpoints` platná.

### <a name="health-checks"></a>Kontroly stavu

Kontroly stavu používají směrování koncových bodů u obecného hostitele. V `Startup.Configure` volejte `MapHealthChecks` na Tvůrci koncových bodů s adresou URL koncového bodu nebo relativní cestou:

```csharp
app.UseEndpoints(endpoints =>
{
    endpoints.MapHealthChecks("/health");
});
```

Koncové body kontrol stavu můžou:

* Zadejte minimálně jednoho povoleného hostitele nebo portů.
* Vyžadovat autorizaci.
* Vyžadovat CORS

Další informace naleznete v tématu <xref:host-and-deploy/health-checks>.

### <a name="security-middleware-guidance"></a>Doprovodné materiály k zabezpečení middlewaru

Podpora pro autorizaci a CORS je sjednocená v rámci přístupu [middlewaru](xref:fundamentals/middleware/index) . To umožňuje používat stejný middlewar a funkčnost v těchto scénářích. V této verzi je k dispozici aktualizovaný middleware autorizace a middleware CORS je vylepšený, aby bylo možné pochopit atributy používané řadiči MVC.

#### <a name="cors"></a>CORS

V minulosti mohlo být obtížné nakonfigurovat CORS. Middleware byl poskytnut pro použití v některých případech použití, ale filtry MVC byly určeny k použití **bez** middlewaru v jiných případech použití. U ASP.NET Core 3,0 doporučujeme, aby všechny aplikace, které vyžadují CORS, používaly middleware CORS v kombinaci s směrováním koncových bodů. `UseCors` se dá zadat s výchozí zásadou a atributy `[EnableCors]` a `[DisableCors]` se dají použít k přepsání výchozích zásad, pokud je to potřeba.

V následujícím příkladu:

* U všech koncových bodů s pojmenovanými zásadami `default` je povolena CORS.
* Třída `MyController` zakáže CORS s atributem `[DisableCors]`.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseCors("default");

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[DisableCors]
public class MyController : ControllerBase
{
    ...
}
```

#### <a name="authorization"></a>Authorization

V dřívějších verzích ASP.NET Core byla poskytnuta podpora autorizace prostřednictvím atributu `[Authorize]`. Autorizační middleware není k dispozici. V ASP.NET Core 3,0 se vyžaduje middleware autorizace. Doporučujeme umístit middleware autorizace ASP.NET Core (`UseAuthorization`) hned po `UseAuthentication`. Middleware autorizace se dá nakonfigurovat taky s výchozími zásadami, které se dají přepsat.

V ASP.NET Core 3,0 nebo novějším je v `Startup.Configure` volána `UseAuthorization` a následující `HomeController` vyžaduje přihlášeného uživatele:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

public class HomeController : ControllerBase
{
    [Authorize]
    public IActionResult BuyWidgets()
    {
        ...
    }
}
```

Pokud aplikace používá `AuthorizeFilter` jako globální filtr v MVC, doporučujeme, abyste kód refaktoringu poskytovali ve volání metody `AddAuthorization`.

@No__t-0 je zpočátku nakonfigurovaný tak, aby vyžadoval ověřování, takže se nevyžaduje žádná další konfigurace. V následujícím příkladu jsou koncové body MVC označeny jako `RequireAuthorization`, takže všechny požadavky musí být autorizovány na základě `DefaultPolicy`. @No__t-0 však umožňuje přístup bez přihlášení uživatele k aplikaci z důvodu `[AllowAnonymous]`:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute().RequireAuthorization();
    });
}

[AllowAnonymous]
public class HomeController : ControllerBase
{
    ...
}
```

Zásady je také možné přizpůsobit. V předchozím příkladu je `DefaultPolicy` nakonfigurovaná tak, aby vyžadovala ověřování a určitý rozsah:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    ...

    services.AddAuthorization(options =>
    {
        options.DefaultPolicy = new AuthorizationPolicyBuilder()
          .RequireAuthenticatedUser()
          .Build();
    });
}

public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute().RequireAuthorization();
    });
}

[AllowAnonymous]
public class HomeController : ControllerBase
{
    ...
}
```

Alternativně lze všechny koncové body nakonfigurovat tak, aby vyžadovaly autorizaci bez `[Authorize]` nebo `RequireAuthorization` konfigurací `FallbackPolicy`. @No__t-0 se liší od `DefaultPolicy`. @No__t-0 se spouští `[Authorize]` nebo `RequireAuthorization`, zatímco `FallbackPolicy` se aktivuje, když nejsou nastavené žádné jiné zásady. `FallbackPolicy` je zpočátku nakonfigurovaný tak, aby povoloval požadavky bez autorizace.

Následující příklad je stejný jako předchozí příklad `DefaultPolicy`, ale používá `FallbackPolicy` k vždy vyžadování ověřování u všech koncových bodů s výjimkou případů, kdy je zadána hodnota `[AllowAnonymous]`:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    ...

    services.AddAuthorization(options =>
    {
        options.FallbackPolicy = new AuthorizationPolicyBuilder()
          .RequireAuthenticatedUser()
          .Build();
    });
}

public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[AllowAnonymous]
public class HomeController : ControllerBase
{
    ...
}
```

Ověřování pomocí middlewaru funguje bez rozhraní, které má konkrétní znalosti o autorizaci. [Kontroly stavu](xref:host-and-deploy/health-checks) například nemají žádné konkrétní znalosti o autorizaci, ale kontroly stavu můžou mít konfigurovatelné zásady autorizace, které používá middleware.

Každý koncový bod navíc může přizpůsobit své autorizační požadavky. V následujícím příkladu `UseAuthorization` zpracovává autorizaci pomocí `DefaultPolicy`, ale koncový bod kontroly stavu `/healthz` vyžaduje uživatele `admin`:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints
            .MapHealthChecks("/healthz")
            .RequireAuthorization(new AuthorizeAttribute(){ Roles = "admin", });
    });
}
```

Ochrana je implementovaná pro některé scénáře. Middleware koncové body vyvolá výjimku, pokud se zásada autorizace nebo CORS z důvodu chybějícího middlewaru přeskočí. Podpora analyzátoru, která poskytuje další názory na neplatnou konfiguraci.

### <a name="signalr"></a>SignalR

Mapování rozbočovačů signálu se teď provádí v `UseEndpoints`.

Namapujte všechna centra pomocí `MapHub`. Stejně jako v předchozích verzích je každé centrum výslovně uvedené.

V následujícím příkladu se přidá podpora pro centrum signalizace `ChatHub`:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>();
    });
}
```

Pro řízení omezení velikosti zprávy od klientů je k dispozici nová možnost. Například v `Startup.ConfigureServices`:

```csharp
services.AddSignalR(hubOptions =>
{
    hubOptions.MaximumReceiveMessageSize = 32768;
});
```

V ASP.NET Core 2,2 jste mohli nastavit `TransportMaxBufferSize` a efektivně tak řídit maximální velikost zprávy. V ASP.NET Core 3,0 Tato možnost nyní určuje pouze maximální velikost před nedodržením přítlaku.

### <a name="mvc-controllers"></a>Řadiče MVC

Mapování řadičů se teď provádí v rámci `UseEndpoints`.

Pokud aplikace používá směrování atributů, přidejte `MapControllers`. Vzhledem k tomu, že směrování zahrnuje podporu pro mnoho platforem v ASP.NET Core 3,0 nebo novějších, je přidání řadičů směrovaných k atributům výslovný souhlas.

Nahraďte následující:

* `MapRoute` s `MapControllerRoute`
* `MapAreaRoute` s `MapAreaControllerRoute`

Vzhledem k tomu, že směrování nyní zahrnuje podporu pro více než jen MVC, se terminologie změnila, aby tyto metody jasně zajistila, co dělají. Konvenční trasy, například `MapControllerRoute` @ no__t-1 @ no__t-2 @ no__t-3 @ no__t-4, jsou aplikovány v pořadí, v jakém byly přidány. Nejprve umístěte konkrétnější trasy (například trasy pro oblast).

V následujícím příkladu:

* `MapControllers` přidá podporu pro řadiče směrované atributy.
* `MapAreaControllerRoute` přidá konvenční trasu pro řadiče v oblasti.
* `MapControllerRoute` přidá konvenční trasu pro řadiče.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapControllers();
        endpoints.MapAreaControllerRoute(
            "admin",
            "admin",
            "Admin/{controller=Home}/{action=Index}/{id?}");
        endpoints.MapControllerRoute(
            "default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

#### <a name="async-suffix-removal-from-controller-action-names"></a>Odebrání asynchronní přípony z názvů akcí kontroleru

V ASP.NET Core 3,0 ASP.NET Core MVC odebere příponu `Async` z názvů akcí řadiče. Tato nová výchozí hodnota má vliv na generaci směrování i propojení. Příklad:

```csharp
public class ProductsController : Controller
{
    public async Task<IActionResult> ListAsync()
    {
        var model = await _dbContext.Products.ToListAsync();
        return View(model);
    }
}
```

Před ASP.NET Core 3,0:

* K předchozí akci může být přistup v trase *Products/ListAsync* .
* Vytváření odkazů vyžaduje určení přípony `Async`. Příklad:

    ```cshtml
    <a asp-controller="Products" asp-action="ListAsync">List</a>
    ```

V ASP.NET Core 3,0:

* Předchozí akce je k dispozici na trase *Products/List* .
* Generování odkazu nevyžaduje zadání přípony `Async`. Příklad:

    ```cshtml
    <a asp-controller="Products" asp-action="List">List</a>
    ```

Tato změna nemá vliv na názvy zadané pomocí atributu [[Action]](/dotnet/api/microsoft.aspnetcore.mvc.actionnameattribute) . Výchozí chování lze zakázat pomocí následujícího kódu v `Startup.ConfigureServices`:

```csharp
services.AddMvc(options =>
    options.SuppressAsyncSuffixInActionNames = false);
```

### <a name="razor-pages"></a>Razor Pages

Mapování Razor Pages nyní probíhá uvnitř `UseEndpoints`.

Pokud aplikace používá Razor Pages, přidejte `MapRazorPages`. Vzhledem k tomu, že směrování koncových bodů zahrnuje podporu pro spoustu platforem, přidání Razor Pages je nyní výslovným souhlasem.

V následující metodě `Startup.Configure` přidá `MapRazorPages` podporu pro Razor Pages:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapRazorPages();
    });
}
```

### <a name="use-mvc-without-endpoint-routing"></a>Použití MVC bez směrování koncových bodů

Použití MVC prostřednictvím `UseMvc` nebo `UseMvcWithDefaultRoute` v ASP.NET Core 3,0 vyžaduje explicitní výslovný souhlas uvnitř `Startup.ConfigureServices`. To je nutné, protože MVC musí zjistit, jestli se může při inicializaci spoléhat na autorizaci a middleware CORS. K dispozici je analyzátor, který se upozorní, pokud se aplikace pokusí použít nepodporovanou konfiguraci.

Pokud aplikace vyžaduje starší verzi `IRouter`, zakažte `EnableEndpointRouting` pomocí kterékoli z následujících přístupů v `Startup.ConfigureServices`:

```csharp
services.AddMvc(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllers(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllersWithViews(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddRazorPages().AddMvcOptions(options => options.EnableEndpointRouting = false);
```

### <a name="health-checks"></a>Kontroly stavu

Kontroly stavu lze použít jako *směrovač* s směrováním koncových bodů.

Přidejte `MapHealthChecks` pro použití kontrol stavu s směrováním koncových bodů. Metoda `MapHealthChecks` přijímá argumenty podobné `UseHealthChecks`. Výhodou použití `MapHealthChecks` nad `UseHealthChecks` je schopnost použít autorizaci a mít větší jemně odstupňovanou kontrolu nad zásadami pro porovnání.

V následujícím příkladu je pro koncový bod kontroly stavu v `/healthz` volána hodnota `MapHealthChecks`:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHealthChecks("/healthz", new HealthCheckOptions() { });
    });
}
```

## <a name="hostbuilder-replaces-webhostbuilder"></a>HostBuilder nahrazuje WebHostBuilder

Šablony ASP.NET Core 3,0 používají [obecného hostitele](xref:fundamentals/host/generic-host). Předchozí verze používaly [webového hostitele](xref:fundamentals/host/web-host). Následující kód ukazuje ASP.NET Core 3,0 vygenerované šablonou `Program`:

[!code-csharp[](22-to-30/samples/Program.cs?name=snippet)]

Následující kód ukazuje ASP.NET Core třídy `Program` generované šablonou 2,2:

[!code-csharp[](22-to-30/samples/Program2.2.cs?name=snippet)]

<xref:Microsoft.AspNetCore.Hosting.IWebHostBuilder> zůstává v 3,0 a je typ `webBuilder`, který se zobrazuje v předchozí ukázce kódu. <xref:Microsoft.AspNetCore.Hosting.WebHostBuilder> bude v budoucí verzi zastaralá a bude nahrazena `HostBuilder`.

Nejvýznamnější změnou z `WebHostBuilder` na `HostBuilder` je v [vkládání závislostí (di)](xref:fundamentals/dependency-injection). Při použití `HostBuilder` lze do konstruktoru `Startup` vložit pouze <xref:Microsoft.Extensions.Configuration.IConfiguration> a <xref:Microsoft.AspNetCore.Hosting.IHostingEnvironment>. @No__t-0 DI omezení:

* Povolí sestavení kontejneru DI jenom jednou.
* Předejde výsledným problémům životního cyklu objektů, jako je například řešení více instancí singleton.

## <a name="addauthorization-moved-to-a-different-assembly"></a>AddAuthorization přesunuté do jiného sestavení

ASP.NET Core 2,2 a nižší metody `AddAuthorization` v souboru *Microsoft. AspNetCore. Authorization. dll*:

* Bylo přejmenováno `AddAuthorizationCore`.
* Byly přesunuty do souboru *Microsoft. AspNetCore. Authorization. Policy. dll*.

Aplikace používající *Microsoft. AspNetCore. Authorization. dll* a *Microsoft. AspNetCore. Authorization. Policy. dll* nejsou ovlivněny.

Aplikace, které nepoužívají *Microsoft. AspNetCore. Authorization. Policy. dll* , by měly provádět jednu z následujících akcí:

* Přepnutí na použití `AddAuthorizationCore`
* Přidejte odkaz na *Microsoft. AspNetCore. Authorization. Policy. dll*.

Další informace naleznete v tématu zásadní [Změna v `AddAuthorization(o =>`) přetížení v jiném sestavení #386](https://github.com/aspnet/Announcements/issues/386).

## <a name="signalr"></a>SignalR

Klient nástroje Signal JavaScript se změnil z `@aspnet/signalr` na `@microsoft/signalr`. Pro reakci na tuto změnu změňte odkazy v souborech *Package. JSON* , `require` a příkazech ECMAScript `import`.

### <a name="systemtextjson-is-the-default-protocol"></a>System. text. JSON je výchozí protokol.

`System.Text.Json` je teď výchozím protokolem rozbočovače používaným klientem i serverem.

V `Startup.ConfigureServices` zavolejte `AddJsonProtocol` a nastavte možnosti serializátoru.

**WebServer**

```csharp
services.AddSignalR(...)
        .AddJsonProtocol(options =>
        {
            options.WriteIndented = false;
        })
```

**Služba**

```csharp
new HubConnectionBuilder()
    .WithUrl("/chatHub")
    .AddJsonProtocol(options =>
    {
        options.WriteIndented = false;
    })
    .Build();
```

### <a name="switch-to-newtonsoftjson"></a>Přepnout na Newtonsoft. JSON

Pokud používáte funkce `Newtonsoft.Json`, které nejsou podporované v `System.Text.Json`, můžete přejít zpět na `Newtonsoft.Json`:

1. Nainstalujte balíček NuGet [Microsoft. AspNetCore. signaler. Protocols. NewtonsoftJson](https://www.nuget.org/packages/Microsoft.AspNetCore.SignalR.Protocols.NewtonsoftJson) .
1. V klientovi řetězit volání metody `AddNewtonsoftJsonProtocol` do instance `HubConnectionBuilder`:

    ```csharp
    new HubConnectionBuilder()
        .WithUrl("/chatHub")
        .AddNewtonsoftJsonProtocol(...)
        .Build();
    ```

1. Na serveru řetězit metodu `AddNewtonsoftJsonProtocol` volání metody `AddSignalR` v `Startup.ConfigureServices`:

    ```csharp
    services.AddSignalR()
        .AddNewtonsoftJsonProtocol(...);
    ```

## <a name="opt-in-to-runtime-compilation"></a>Přihlásit se ke kompilaci za běhu

Před ASP.NET Core 3,0 byla kompilace zobrazení běhového prostředí implicitní funkcí rozhraní. Kompilace za běhu doplňuje kompilaci zobrazení v době sestavení. Umožňuje rozhraní kompilovat zobrazení a stránky Razor (soubory *. cshtml* ) při změně souborů, aniž by bylo nutné znovu sestavit celou aplikaci. Tato funkce podporuje scénář pro rychlé úpravy v integrovaném vývojovém prostředí (IDE) a aktualizaci prohlížeče pro zobrazení změn.

V ASP.NET Core 3,0 je kompilace modulu runtime v případě výslovného souhlasu. Kompilace při sestavení je jediným mechanismem pro zobrazení kompilace, která je ve výchozím nastavení povolená. Modul runtime spoléhá na aplikaci Visual Studio nebo [dotnet – Sledujte](xref:tutorials/dotnet-watch) v Visual Studio Code pro opětovné sestavení projektu, když detekuje změny souborů *. cshtml* . V aplikaci Visual Studio se změny v souborech *. cs*, *. cshtml*nebo *. Razor* v projektu spouštějí (<kbd>CTRL + F5</kbd>), ale ne laděné (<kbd>F5</kbd>), spusťte opětovnou kompilaci projektu.

Povolení kompilace za běhu v projektu ASP.NET Core 3,0:

1. Nainstalujte balíček NuGet [Microsoft. AspNetCore. Mvc. Razor. RuntimeCompilation](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation) .
1. Aktualizace `Startup.ConfigureServices` pro volání `AddRazorRuntimeCompilation`:

    Pro ASP.NET Core MVC použijte následující kód:

    ```csharp
    services.AddControllersWithViews()
        .AddRazorRuntimeCompilation(...);
    ```
 
    Pro ASP.NET Core Razor Pages použijte následující kód:
 
    ```csharp
    services.AddRazorPages()
        .AddRazorRuntimeCompilation(...);
    ```
 
Ukázka na https://github.com/aspnet/samples/tree/master/samples/aspnetcore/mvc/runtimecompilation ukazuje příklad povolení podmíněné kompilace za běhu ve vývojových prostředích.

Další informace o kompilaci souborů Razor naleznete v tématu <xref:mvc/views/view-compilation>.

## <a name="migrate-libraries-via-multi-targeting"></a>Migrace knihoven přes cílení na více platforem

Knihovny často potřebují podporovat více verzí ASP.NET Core. Většina knihoven kompilovaných pro předchozí verze ASP.NET Core by měla pokračovat bez problémů. Následující podmínky vyžadují křížové kompilování aplikace:

* Knihovna se spoléhá na funkci, která má binární zásadní [změnu](#breaking-api-changes).
* Knihovna chce využívat nové funkce v ASP.NET Core 3,0. 

Příklad:

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFrameworks>netcoreapp3.0;netstandard2.0</TargetFrameworks>
  </PropertyGroup>

  <ItemGroup Condition="'$(TargetFramework)' == 'netcoreapp3.0'">
    <FrameworkReference Include="Microsoft.AspNetCore.App" />
  </ItemGroup>

  <ItemGroup Condition="'$(TargetFramework)' == 'netstandard2.0'">
    <PackageReference Include="Microsoft.AspNetCore" Version="2.1.0" />
  </ItemGroup>
</Project>
```

Pomocí `#ifdefs` povolte rozhraní API pro ASP.NET Core 3,0:

```csharp
var webRootFileProvider =
#if NETCOREAPP3_0
    GetRequiredService<IWebHostEnvironment>().WebRootFileProvider;
#elif NETSTANDARD2_0
    GetRequiredService<IHostingEnvironment>().WebRootFileProvider;
#else
#error unknown target framework
#endif
```

### <a name="publish"></a>Publikování

Odstraňte složky *bin* a *obj* v adresáři projektu.

<a name="break"></a>

## <a name="breaking-api-changes"></a>Přerušení změn rozhraní API

Kontrola nejnovějších změn:

* [Úplný seznam nejnovějších změn v ASP.NET Core vydání 3,0](https://github.com/aspnet/Announcements/issues?page=2&q=is%3Aissue+is%3Aopen+label%3A%22Breaking+change%22+label%3A3.0.0)
* [Rušení změn rozhraní API v antipadělání, CORS, diagnostice, MVC a směrování](https://github.com/aspnet/Announcements/issues/387). Tento seznam obsahuje zásadní změny pro přepínače kompatibility.
* Shrnutí 2,2-až 3,0 přerušující změny v rámci .NET Core, ASP.NET Core a Entity Framework Core najdete v tématu [přerušující změny migrace z verze 2,2 na 3,0](/dotnet/core/compatibility/2.2-3.0).

## <a name="aspnet-core-30-not-currently-available-for-azure-app-service"></a>ASP.NET Core 3,0 není aktuálně k dispozici pro Azure App Service

Doufáme, že to bude brzy k dispozici. Až ASP.NET Core 3,0 k dispozici v Azure App Service, postupujte podle pokynů v části [nasazení ASP.NET Core vydání verze Preview do Azure App Service](xref:host-and-deploy/azure-apps/index#deploy-aspnet-core-preview-release-to-azure-app-service).

## <a name="mysqldataentityframeworkcore-not-currently-supported-on-aspnet-core-30"></a>MySql. data. EntityFrameworkCore není aktuálně podporován v ASP.NET Core 3,0

Další informace najdete v tématu [tento problém Githubu](https://github.com/aspnet/EntityFrameworkCore/issues/17788).
