---
title: Migrace z ASP.NET jádra 2.2 do 3.0
author: rick-anderson
description: Přečtěte si, jak migrovat projekt ASP.NET Core 2.2 do ASP.NET Core 3.0.
ms.author: riande
ms.custom: mvc
ms.date: 01/21/2020
no-loc:
- SignalR
uid: migration/22-to-30
ms.openlocfilehash: 46223011e82c7115147f59ee03e20d8033103b98
ms.sourcegitcommit: f0aeeab6ab6e09db713bb9b7862c45f4d447771b
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 04/08/2020
ms.locfileid: "80977233"
---
# <a name="migrate-from-aspnet-core-22-to-30"></a>Migrace z ASP.NET jádra 2.2 do 3.0

Scott [Addie](https://github.com/scottaddie) a [Rick Anderson](https://twitter.com/RickAndMSFT)

Tento článek vysvětluje, jak aktualizovat existující projekt ASP.NET Core 2.2 do ASP.NET Core 3.0.

## <a name="prerequisites"></a>Požadavky

# <a name="visual-studio"></a>[Visual Studio](#tab/visual-studio)

[!INCLUDE[](~/includes/net-core-prereqs-vs-3.0.md)]

# <a name="visual-studio-code"></a>[Visual Studio Code](#tab/visual-studio-code)

[!INCLUDE[](~/includes/net-core-prereqs-vsc-3.0.md)]

# <a name="visual-studio-for-mac"></a>[Visual Studio pro Mac](#tab/visual-studio-mac)

[!INCLUDE[](~/includes/net-core-prereqs-mac-3.0.md)]

---

## <a name="update-net-core-sdk-version-in-globaljson"></a>Aktualizace verze sady .NET Core SDK v souboru global.json

Pokud vaše řešení závisí na souboru [global.json,](/dotnet/core/tools/global-json) aby se zaměřilo `version` na konkrétní verzi sady .NET Core SDK, aktualizujte jeho vlastnost na verzi 3.0 nainstalovanou v počítači:

```json
{
  "sdk": {
    "version": "3.0.100"
  }
}
```

## <a name="update-the-project-file"></a>Aktualizace souboru projektu

### <a name="update-the-target-framework"></a>Aktualizace cílového rámce

ASP.NET Core 3.0 a později spustit pouze na .NET Core. Nastavte zástupný [název cílového rámce (TFM)](/dotnet/standard/frameworks) na: `netcoreapp3.0`

[!code-xml[](22-to-30/samples/Web1.csproj?highlight=4)]

### <a name="remove-obsolete-package-references"></a>Odebrání zastaralých odkazů na balíky

Velký počet balíčků NuGet nejsou vyráběny pro ASP.NET Core 3.0. Tyto odkazy na balíček by měly být odebrány ze souboru projektu. Zvažte následující soubor projektu pro ASP.NET webovou aplikaci Core 2.2:

```xml
<Project Sdk="Microsoft.NET.Sdk.Web">

  <PropertyGroup>
    <TargetFramework>netcoreapp2.2</TargetFramework>
    <AspNetCoreHostingModel>InProcess</AspNetCoreHostingModel>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.AspNetCore.App"/>
    <PackageReference Include="Microsoft.AspNetCore.Razor.Design" Version="2.2.0" PrivateAssets="All" />
  </ItemGroup>

</Project>
```

Aktualizovaný soubor projektu pro ASP.NET core 3.0:

[!code-xml[](22-to-30/samples/Web1.csproj?highlight=4)]

Aktualizovaný soubor projektu Core 3.0 ASP.NET:

* V `<PropertyGroup>`:
  * Aktualizuje TFM na`netcoreapp3.0`
  * Odebere `<AspNetCoreHostingModel>` prvek. Další informace naleznete [v tématu In-process hosting model](#in-process-hosting-model) v tomto dokumentu.

* V `<ItemGroup>`:
  * `Microsoft.AspNetCore.App`je odstraněn. Další informace naleznete v [tématu Framework odkaz](#framework-reference) v tomto dokumentu.
  * `Microsoft.AspNetCore.Razor.Design`a v následujícím seznamu již nevyráběná balení.

Chcete-li zobrazit úplný seznam balíčků, které již nejsou vyráběny, vyberte následující rozbalit seznam:

<details>
    <summary>Klepnutím rozbalíte seznam balíků, které se již nevyrábějí.</summary>
    <ul>
        <li>Microsoft.AspNetCore</li>
        <li>Microsoft.AspNetCore.All</li>
        <li>Microsoft.AspNetCore.App</li>
        <li>Microsoft.AspNetCore.Antiforgery</li>
        <li>Microsoft.AspNetCore.Authentication</li>
        <li>Microsoft.AspNetCore.Authentication.Abstractions</li>
        <li>Microsoft.AspNetCore.Authentication.Cookies</li>
        <li>Microsoft.AspNetCore.Authentication.Core</li>
        <li>Microsoft.AspNetCore.Authentication.OAuth</li>
        <li>Microsoft.AspNetCore.Authorization.Policy</li>
        <li>Microsoft.AspNetCore.CookiePolicy</li>
        <li>Microsoft.AspNetCore.Cors</li>
        <li>Microsoft.AspNetCore.Diagnostics</li>
        <li>Microsoft.AspNetCore.Diagnostics.HealthChecks</li>
        <li>Filtrování Microsoft.AspNetCore.HostFiltering</li>
        <li>Microsoft.AspNetCore.Hosting</li>
        <li>Microsoft.AspNetCore.Hosting.Abstractions</li>
        <li>Microsoft.AspNetCore.Hosting.Server.Abstractions</li>
        <li>Microsoft.AspNetCore.Http</li>
        <li>Microsoft.AspNetCore.Http.Abstractions</li>
        <li>Microsoft.AspNetCore.Http.Connections</li>
        <li>Microsoft.AspNetCore.Http.Extensions</li>
        <li>Microsoft.AspNetCore.HttpOverrides</li>
        <li>Microsoft.AspNetCore.HttpsPolicy</li>
        <li>Microsoft.AspNetCore.Identity</li>
        <li>Microsoft.AspNetCore.Localization</li>
        <li>Microsoft.AspNetCore.Localization.Routing</li>
        <li>Microsoft.AspNetCore.Mvc</li>
        <li>Microsoft.AspNetCore.Mvc.Abstractions</li>
        <li>Microsoft.AspNetCore.Mvc.Analyzers</li>
        <li>Microsoft.AspNetCore.Mvc.ApiExplorer</li>
        <li>Microsoft.AspNetCore.Mvc.Api.Analyzers</li>
        <li>Microsoft.AspNetCore.Mvc.Core</li>
        <li>Microsoft.AspNetCore.Mvc.Cors</li>
        <li>Microsoft.AspNetCore.Mvc.DataAnnotations</li>
        <li>Microsoft.AspNetCore.Mvc.Formatters.Json</li>
        <li>Microsoft.AspNetCore.Mvc.Formatters.Xml</li>
        <li>Microsoft.AspNetCore.Mvc.Localization</li>
        <li>Microsoft.AspNetCore.Mvc.Razor</li>
        <li>Microsoft.AspNetCore.Mvc.Razor.ViewCompilation</li>
        <li>Microsoft.AspNetCore.Mvc.RazorPages</li>
        <li>Microsoft.AspNetCore.Mvc.TagHelpers</li>
        <li>Microsoft.AspNetCore.Mvc.ViewFeatures</li>
        <li>Microsoft.AspNetCore.Razor</li>
        <li>Microsoft.AspNetCore.Razor.Runtime</li>
        <li>Microsoft.AspNetCore.Razor.Design</li>
        <li>Microsoft.AspNetCore.ResponseCaching</li>
        <li>Microsoft.AspNetCore.ResponseCaching.Abstractions</li>
        <li>Microsoft.AspNetCore.ResponseCompression</li>
        <li>Microsoft.AspNetCore.Rewrite</li>
        <li>Microsoft.AspNetCore.Routing</li>
        <li>Microsoft.AspNetCore.Routing.Abstractions</li>
        <li>Microsoft.AspNetCore.Server.HttpSys</li>
        <li>Microsoft.AspNetCore.Server.IIS</li>
        <li>Microsoft.AspNetCore.Server.IISIntegration</li>
        <li>Microsoft.AspNetCore.Server.Kestrel</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Core</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Https</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets</li>
        <li>Microsoft.AspNetCore.Session</li>
        <li>Microsoft.AspNetCore.SignalR</li>
        <li>Microsoft.AspNetCore. SignalR. Core</li>
        <li>Soubory Microsoft.AspNetCore.StaticFiles</li>
        <li>Microsoft.AspNetCore.WebSockets</li>
        <li>Microsoft.AspNetCore.WebUtilities</li>
        <li>Microsoft.Net.Http.Headers </li>
    </ul>
</details>

### <a name="review-breaking-changes"></a>Kontrola nejnovějších změn

[Kontrola nejnovějších změn](#break)

### <a name="framework-reference"></a>Odkaz na rámec

Funkce ASP.NET Core, které byly k dispozici prostřednictvím jednoho `Microsoft.AspNetCore.App` z výše uvedených balíčků jsou k dispozici jako součást sdíleného rozhraní. *Sdílená architektura* je sada sestavení (*soubory DLL),* které jsou nainstalovány v počítači a obsahují součást runtime a balíček cílení. Další informace naleznete [v tématu sdílený rámec](https://natemcmaster.com/blog/2018/08/29/netcore-primitives-2/).

* Projekty, `Microsoft.NET.Sdk.Web` které se zaměřují na `Microsoft.AspNetCore.App` sdk implicitně odkazovat na rozhraní.

  Pro tyto projekty nejsou vyžadovány žádné další odkazy:

  ```xml
  <Project Sdk="Microsoft.NET.Sdk.Web">
    <PropertyGroup>
      <TargetFramework>netcoreapp3.0</TargetFramework>
    </PropertyGroup>
      ...
  </Project>
  ```

* Projekty, `Microsoft.NET.Sdk` `Microsoft.NET.Sdk.Razor` které cílí nebo SDK, by měly přidat explicitní `FrameworkReference` : `Microsoft.AspNetCore.App`

  ```xml
  <Project Sdk="Microsoft.NET.Sdk.Razor">
    <PropertyGroup>
      <TargetFramework>netcoreapp3.0</TargetFramework>
    </PropertyGroup>

    <ItemGroup>
      <FrameworkReference Include="Microsoft.AspNetCore.App" />
    </ItemGroup>
      ...
  </Project>
  ```

#### <a name="framework-dependent-builds-using-docker"></a>Sestavení závislá na architektury pomocí Dockeru

Sestavení aplikací v rámci závislých na rozhraní, která používají balíček, který závisí na [sdíleném rámci](https://natemcmaster.com/blog/2018/08/29/netcore-primitives-2/) ASP.NET, může přivodit následující chybu za běhu:

```console
It was not possible to find any compatible framework version
The specified framework 'Microsoft.AspNetCore.App', version '3.0.0' was not found.
  - No frameworks were found.
```

`Microsoft.AspNetCore.App`je sdílené rozhraní obsahující ASP.NET core runtime a je k dispozici pouze [na dotnet/core/aspnet](https://hub.docker.com/_/microsoft-dotnet-core-aspnet/) Docker image. Sada 3.0 SDK snižuje velikost sestavení závislých na rozhraní pomocí ASP.NET Core tím, že nezahrnuje duplicitní kopie knihoven, které jsou k dispozici ve sdíleném rámci. Jedná se o potenciální úsporu až 18 MB, ale vyžaduje, aby byl přítomen / nainstalován ASP.NET core runtime pro spuštění aplikace.

Chcete-li zjistit, zda má aplikace závislost (přímou nebo nepřímou) na sdíleném rámci ASP.NET Core, zkontrolujte soubor *runtimeconfig.json* generovaný během sestavení nebo publikování vaší aplikace. Následující soubor JSON zobrazuje závislost na sdíleném rámci ASP.NET Core:

```json
{
  "runtimeOptions": {
    "tfm": "netcoreapp3.0",
    "framework": {
      "name": "Microsoft.AspNetCore.App",
      "version": "3.0.0"
    },
    "configProperties": {
      "System.GC.Server": true
    }
  }
}
```

Pokud vaše aplikace používá Docker, použijte základní bitovou kopii, která obsahuje ASP.NET Core 3.0. Například, `docker pull mcr.microsoft.com/dotnet/core/aspnet:3.0`.

### <a name="add-package-references-for-removed-assemblies"></a>Přidání odkazů na balíčky pro odebraná sestavení

ASP.NET Core 3.0 odebere některá sestavení, `Microsoft.AspNetCore.App` která byla dříve součástí odkazu na balíček. Chcete-li vizualizovat, která sestavení byla odebrána, porovnejte dvě sdílené složky architektury. Například porovnání verzí 2.2.7 a 3.0.0:

![porovnání sestavení sdílených rámců](22-to-30/_static/assembly-diff.png)

Chcete-li pokračovat v používání funkcí poskytovaných odstraněnými sestaveními, odkazněte na verze 3.0 odpovídajících balíčků:

* Webová aplikace vytvořená šablonou s **jednotlivými uživatelskými účty** vyžaduje přidání následujících balíčků:

  [!code-xml[](22-to-30/samples/WebFull.csproj?highlight=9-13)]

* [Microsoft.EntityFrameworkCore](https://www.nuget.org/packages/Microsoft.EntityFrameworkCore)

  Další informace o odkazování na balíček specifický pro zprostředkovatele databáze naleznete v [tématu Zprostředkovatelé databáze](/ef/core/providers/index).

* Identity UI

  Podporu pro [rozhraní identity](xref:security/authentication/identity) lze přidat odkazem na balíček [Microsoft.AspNetCore.Identity.UI.](https://www.nuget.org/packages/Microsoft.AspNetCore.Identity.UI)

* SPA služby

  * [Služby Microsoft.AspNetCore.SpaServices](https://www.nuget.org/packages/Microsoft.AspNetCore.SpaServices)
  * [Rozšíření Microsoft.AspNetCore.SpaServices.Extensions](https://www.nuget.org/packages/Microsoft.AspNetCore.SpaServices.Extensions)

* Podpora &ndash; ověřování pro toky ověřování třetích stran jsou k dispozici jako balíčky NuGet:

  * Facebook OAuth ([Microsoft.AspNetCore.Authentication.Facebook](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Facebook))
  * Google OAuth ([Microsoft.AspNetCore.Authentication.Google](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Google))
  * Ověření účtu Microsoft ([Microsoft.AspNetCore.Authentication.MicrosoftAccount](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.MicrosoftAccount))
  * Ověřování OpenID Connect ([Microsoft.AspNetCore.Authentication.OpenIdConnect](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.OpenIdConnect))
  * OpenID Connect nosný token ([Microsoft.AspNetCore.Authentication.JwtBearer](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.JwtBearer))
  * Twitter OAuth ([Microsoft.AspNetCore.Authentication.Twitter](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Twitter))
  * Ověřování WsFederation ([Microsoft.AspNetCore.Authentication.WsFederation](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.WsFederation))

* Podpora vyjednávání formátování a `System.Net.HttpClient` &ndash; obsahu pro balíček [Microsoft.AspNet.WebApi.Client](https://www.nuget.org/packages/Microsoft.AspNet.WebApi.Client/) NuGet `System.Net.HttpClient` poskytuje užitečnou `ReadAsAsync` rozšiřitelnost pomocí rozhraní API, jako jsou například a `PostJsonAsync`.

* Kompilace &ndash; razor runtime Podpora pro kompilaci zobrazení razor a stránek za běhu je nyní součástí [microsoft.aspNetCore.Mvc.Razor.RuntimeCompilation](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation).

* Podpora mvc `Newtonsoft.Json` (Json.NET) Podpora pro `Newtonsoft.Json` používání MVC s je nyní součástí [Microsoft.AspNetCore.Mvc.NewtonsoftJson](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson). &ndash;

## <a name="startup-changes"></a>Změny při spuštění

Následující obrázek znázorňuje odstraněné a změněné řádky ve webové aplikaci ASP.NET Core 2.2 Razor Pages:

![odstraněné a změněné řádky ve webové aplikaci Core 2.2 ASP.NET](22-to-30/_static/startup2.2.png)

Na předchozím obrázku je odstraněný kód zobrazen červeně. Odstraněný kód nezobrazuje kód možností souboru cookie, který byl odstraněn před porovnáním souborů.

Následující obrázek znázorňuje přidané a změněné řádky ve webové aplikaci ASP.NET Core 3.0 Razor Pages:

![přidané a změněné řádky ve webové aplikaci ASP.NET Core 3.0 Core 3.0 Razor](22-to-30/_static/startup3.0.png)

Na předchozím obrázku je přidaný kód zobrazen zeleně. Informace o následujících změnách:

* `services.AddMvc`naleznete `services.AddRazorPages`v tomto dokumentu [v registraci služby MVC.](#mvc-service-registration)
* `CompatibilityVersion`, <xref:mvc/compatibility-version>viz .
* `IHostingEnvironment`naleznete `IWebHostEnvironment`v [tomto oznámení GitHubu](https://github.com/dotnet/AspNetCore/issues/7749).
* `app.UseAuthorization`byl přidán do šablon, aby se zobrazilo middleware autorizace objednávky. Pokud aplikace autorizaci nepoužívá, můžete hovor bezpečně `app.UseAuthorization`odebrat do aplikace .
* `app.UseEndpoints`, viz [Razor Pages](#razor-pages) nebo [Migrate Startup.Configure](#migrate-startupconfigure) v tomto dokumentu.

### <a name="analyzer-support"></a>Podpora pro Analyzer

Projekty, `Microsoft.NET.Sdk.Web` které se zaměřují implicitně odkazovat analyzátory dříve dodávány jako součást balíčku [Microsoft.AspNetCore.Mvc.Analyzers.](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Analyzers/) K jejich povolení nejsou vyžadovány žádné další odkazy.

Pokud vaše aplikace používá [analyzátory rozhraní API](xref:web-api/advanced/analyzers) dříve dodané pomocí balíčku [Microsoft.AspNetCore.Mvc.Api.Analyzers,](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Api.Analyzers/) upravte soubor projektu tak, aby odkazoval na analyzátory dodané jako součást sady .NET Core Web SDK:

```xml
<Project Sdk="Microsoft.NET.Sdk.Web">
    <PropertyGroup>
        <TargetFramework>netcoreapp3.0</TargetFramework>
        <IncludeOpenAPIAnalyzers>true</IncludeOpenAPIAnalyzers>
    </PropertyGroup>

    ...
</Project>
```

### <a name="razor-class-library"></a>Knihovna třídy Holicí strojek

Projekty knihovny tříd y razor, které poskytují `AddRazorSupportForMvc` komponenty ui pro MVC, musí nastavit vlastnost v souboru projektu:

```xml
<PropertyGroup>
  <AddRazorSupportForMvc>true</AddRazorSupportForMvc>
</PropertyGroup>
```

### <a name="in-process-hosting-model"></a>Model hostování v procesu

Projekty výchozí [v procesu hostování modelu](xref:host-and-deploy/aspnet-core-module#in-process-hosting-model) v ASP.NET Core 3.0 nebo novější. Volitelně `<AspNetCoreHostingModel>` můžete odebrat vlastnost v souboru `InProcess`projektu, pokud je její hodnota .

## <a name="kestrel"></a>Kestrel

### <a name="configuration"></a>Konfigurace

Migrace konfigurace Kestrel u tvůrce webových hostitelů poskytovaných společností `ConfigureWebHostDefaults` *(Program.cs*):

```csharp
public static IHostBuilder CreateHostBuilder(string[] args) =>
    Host.CreateDefaultBuilder(args)
        .ConfigureWebHostDefaults(webBuilder =>
        {
            webBuilder.ConfigureKestrel(serverOptions =>
            {
                // Set properties and call methods on options
            })
            .UseStartup<Startup>();
        });
```

Pokud aplikace vytvoří hostitele ručně `HostBuilder`pomocí `UseKestrel` , volejte na `ConfigureWebHostDefaults`tvůrce webových hostitelů v :

```csharp
public static void Main(string[] args)
{
    var host = new HostBuilder()
        .UseContentRoot(Directory.GetCurrentDirectory())
        .ConfigureWebHostDefaults(webBuilder =>
        {
            webBuilder.UseKestrel(serverOptions =>
            {
                // Set properties and call methods on options
            })
            .UseIISIntegration()
            .UseStartup<Startup>();
        })
        .Build();

    host.Run();
}
```

### <a name="connection-middleware-replaces-connection-adapters"></a>Připojení Middleware nahrazuje adaptéry připojení

Adaptéry připojení`Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.IConnectionAdapter`( ) byly odebrány ze společnosti Kestrel. Vyměňte adaptéry připojení za middleware připojení. Připojení Middleware je podobný HTTP Middleware v kanálu ASP.NET Core, ale pro připojení nižší úrovně. Protokolování https a připojení:

* Byly přesunuty z adaptérů připojení do programu Middleware pro připojení.
* Tyto metody rozšíření fungují stejně jako v předchozích verzích ASP.NET Core. 

Další informace naleznete [v příkladu TlsFilterConnectionHandler v části ListenOptions.Protocols v článku Kestrel](/aspnet/core/fundamentals/servers/kestrel?view=aspnetcore-3.0#listenoptionsprotocols).

### <a name="transport-abstractions-moved-and-made-public"></a>Transportní abstrakce přesunuty a zveřejněny

Transportní vrstva Kestrel byla vystavena `Connections.Abstractions`jako veřejné rozhraní v . V rámci těchto aktualizací:

* `Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions`a přidružené typy byly odebrány.
* <xref:Microsoft.AspNetCore.Server.Kestrel.KestrelServerOptions.NoDelay>byla přesunuta z <xref:Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions> možnosti dopravy.
* `Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions.Internal.SchedulingMode`byl odebrán <xref:Microsoft.AspNetCore.Server.Kestrel.KestrelServerOptions>z .

Další informace najdete v následujících prostředcích GitHubu:

* [Abstrakce sítí klient/server (dotnet/AspNetCore #10308)](https://github.com/dotnet/AspNetCore/issues/10308)
* [Implementujte nové abstrakce posluchače podloží a re-plat Kestrel na vrcholu (dotnet / AspNetCore #10321)](https://github.com/dotnet/AspNetCore/pull/10321)

### <a name="kestrel-request-trailer-headers"></a>Kestrel Request záhlaví přívěsu

Pro aplikace, které cílí na starší verze ASP.NET Core:

* Kestrel přidá http/1.1 chunked trailer záhlaví do kolekce hlavičky požadavku.
* Přívěsy jsou k dispozici po odečtení nástavby požadavku až do konce.

To způsobuje určité obavy z nejednoznačnosti mezi hlavičkami a přívěsy,`RequestTrailerExtensions`takže přívěsy byly přesunuty do nové kolekce ( ) v 3.0.

Přívěsy pro vyžádání HTTP/2 jsou:

* Není k dispozici v ASP.NET Core 2.2.
* K dispozici v `RequestTrailerExtensions`3.0 as .

Pro přístup k těmto přípojkovým vozidlům jsou k dispozici nové metody rozšíření požadavků. Stejně jako u PROTOKOLU HTTP/1.1 jsou přívěsy k dispozici po přečtení nástavby žádosti až do konce.

Pro verzi 3.0 jsou `RequestTrailerExtensions` k dispozici následující metody:

* `GetDeclaredTrailers`&ndash; Získá hlavičku požadavku, `Trailer` která uvádí, které přívěsy očekávat po těle.
* `SupportsTrailers`&ndash; Označuje, zda požadavek podporuje příjem záhlaví přípojného vozidla.
* `CheckTrailersAvailable`&ndash; Zkontroluje, zda žádost podporuje přípojné vozidlo a zda jsou k dispozici ke čtení. Tato kontrola nepředpokládá, že existují přívěsy ke čtení. Nemusí být žádné přívěsy číst, i když `true` je vrácena touto metodou.
* `GetTrailer`&ndash; Získá požadované koncové záhlaví z odpovědi. Zkontrolujte `SupportsTrailers` `GetTrailer`před voláním , nebo může dojít, <xref:System.NotSupportedException> pokud požadavek nepodporuje koncové hlavičky.

Další informace naleznete [v tématu Put request trailers in a separate collection (dotnet/AspNetCore #10410).](https://github.com/dotnet/AspNetCore/pull/10410)

### <a name="allowsynchronousio-disabled"></a>AllowSynchronousIO zakázáno

`AllowSynchronousIO`povolí nebo zakáže synchronní vstupně-va `HttpResponse.Body.Write`ová `Stream.Flush`api, například `HttpRequest.Body.Read`, a . Tato rozhraní API jsou zdrojem nedostatku podprocesu, což vede k selhání aplikace. V 3.0 `AllowSynchronousIO` je ve výchozím nastavení zakázán. Další informace naleznete [v části Synchronní vstupně-in/O v článku Kestrel](/aspnet/core/fundamentals/servers/kestrel?view=aspnetcore-3.0#synchronous-io).

Pokud je potřeba synchronní vstupně-in/O, může `AllowSynchronousIO` být povolena konfigurací `ConfigureKestrel`možnosti na použitém serveru (při volání , například při použití Kestrel). Všimněte si, že servery (Kestrel, HttpSys, `AllowSynchronousIO` TestServer, atd.) všechny mají své vlastní možnosti, které nebudou mít vliv na jiné servery. Synchronní vstupně-v/o lze povolit pro všechny servery na základě požadavku pomocí možnosti: `IHttpBodyControlFeature.AllowSynchronousIO`

```csharp
var syncIOFeature = HttpContext.Features.Get<IHttpBodyControlFeature>();

if (syncIOFeature != null)
{
    syncIOFeature.AllowSynchronousIO = true;
}
```

Pokud máte potíže <xref:System.IO.TextWriter> s implementacemi nebo jinými datovými proudy, které <xref:System.IO.Stream.DisposeAsync*> volají synchronní rozhraní API v [dispose](/dotnet/standard/garbage-collection/implementing-dispose), zavolejte místo toho nové rozhraní API.

Další informace naleznete v tématu [[Announcement] AllowSynchronousIO zakázáno na všech serverech (dotnet/AspNetCore #7644).](https://github.com/dotnet/AspNetCore/issues/7644)

### <a name="microsoftaspnetcoreserverkestrelhttps-assembly-removed"></a>Sestavení Microsoft.AspNetCore.Server.Kestrel.Https bylo odebráno

V ASP.NET jádra 2.1 byl obsah *souboru Microsoft.AspNetCore.Server.Kestrel.Https.dll* přesunut na *soubor Microsoft.AspNetCore.Server.Kestrel.Core.dll*. Jednalo se o nenarušující aktualizaci pomocí `TypeForwardedTo` atributů. Pro 3.0 byly odebrány prázdné sestavení *Microsoft.AspNetCore.Server.Kestrel.Https.dll* a balíček NuGet.

Knihovny odkazující na [Microsoft.AspNetCore.Server.Kestrel.Https](https://www.nuget.org/packages/Microsoft.AspNetCore.Server.Kestrel.Https) by měly aktualizovat ASP.NET základní závislosti na 2.1 nebo novější.

Aplikace a knihovny, které cílí na ASP.NET Core 2.1 nebo novějším, by měly odebrat všechny přímé odkazy na balíček [Microsoft.AspNetCore.Server.Kestrel.Https.](https://www.nuget.org/packages/Microsoft.AspNetCore.Server.Kestrel.Https)

<a id="jsonnet-support"></a>

## <a name="newtonsoftjson-jsonnet-support"></a>Podpora pro Newtonsoft.Json (Json.NET)

V rámci práce na [zlepšení ASP.NET společného rámce Core](https://blogs.msdn.microsoft.com/webdev/2018/10/29/a-first-look-at-changes-coming-in-asp-net-core-3-0/)byl [Newtonsoft.Json (Json.NET)](https://www.newtonsoft.com/json/help/html/Introduction.htm) odstraněn ze sdíleného rámce ASP.NET Core.

Výchozí serializátor JSON pro <xref:System.Text.Json>ASP.NET core je nyní , který je nový v rozhraní .NET Core 3.0. Zvažte `System.Text.Json` použití, pokud je to možné. Je to vysoký výkon a nevyžaduje další závislost knihovny. Vzhledem `System.Text.Json` k tomu, že je však nová, může v současné době chybět funkce, které vaše aplikace potřebuje. Další informace naleznete v tématu [Jak migrovat z Newtonsoft.Json na System.Text.Json](/dotnet/standard/serialization/system-text-json-migrate-from-newtonsoft-how-to).

### <a name="use-newtonsoftjson-in-an-aspnet-core-30-opno-locsignalr-project"></a>Použití Newtonsoft.Json v projektu ASP.NET SignalR Core 3.0

* Nainstalujte [SignalRmicrosoft.aspNetCore. . Protocols.NewtonsoftJson](https://www.nuget.org/packages/Microsoft.AspNetCore.SignalR.Protocols.NewtonsoftJson) NuGet balíček.

* Na straně klienta `AddNewtonsoftJsonProtocol` zřetězení volání metody `HubConnectionBuilder` instance:

  ```csharp
  new HubConnectionBuilder()
      .WithUrl("/chatHub")
      .AddNewtonsoftJsonProtocol(...)
      .Build();
  ```

* Na serveru zřetězení `AddNewtonsoftJsonProtocol` volání `AddSignalR` metody `Startup.ConfigureServices`volání metody v :

  ```csharp
  services.AddSignalR()
      .AddNewtonsoftJsonProtocol(...);
  ```

### <a name="use-newtonsoftjson-in-an-aspnet-core-30-mvc-project"></a>Použití Newtonsoft.Json v ASP.NET Core 3.0 MVC projektu

* Nainstalujte balíček [Microsoft.AspNetCore.Mvc.NewtonsoftJson.](https://nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson)

* Aktualizace `Startup.ConfigureServices` pro `AddNewtonsoftJson`volání .

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson();
  ```

  `AddNewtonsoftJson`je kompatibilní s novými metodami registrace služby MVC:

  * `AddRazorPages`
  * `AddControllersWithViews`
  * `AddControllers`

  ```csharp
  services.AddControllers()
      .AddNewtonsoftJson();
  ```

  `Newtonsoft.Json`nastavení lze nastavit ve `AddNewtonsoftJson`volání na :

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson(options =>
             options.SerializerSettings.ContractResolver =
                new CamelCasePropertyNamesContractResolver());
  ```

**Poznámka:** Pokud `AddNewtonsoftJson` metoda není k dispozici, ujistěte se, že jste nainstalovali balíček [Microsoft.AspNetCore.Mvc.NewtonsoftJson.](https://nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson) Běžnou chybou je instalace balíčku [Newtonsoft.Json](https://www.nuget.org/packages/Newtonsoft.Json/) namísto balíčku [Microsoft.AspNetCore.Mvc.NewtonsoftJson.](https://nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson)

## <a name="mvc-service-registration"></a>Registrace služby MVC

ASP.NET Core 3.0 přidává nové možnosti pro `Startup.ConfigureServices`registraci Scénářů MVC uvnitř .

K dispozici jsou tři nové metody rozšíření `IServiceCollection` nejvyšší úrovně související se scénáři MVC. Šablony používají tyto nové `AddMvc`metody namísto . Nicméně, `AddMvc` i nadále chovat, jak to má v předchozích verzích.

Následující příklad přidává podporu pro řadiče a funkce související s rozhraním API, ale ne zobrazení nebo stránky. Šablona rozhraní API používá tento kód:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllers();
}
```

Následující příklad přidává podporu pro řadiče, funkce související s rozhraním API a zobrazení, ale ne stránky. Šablona Webové aplikace (MVC) používá tento kód:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews();
}
```

Následující příklad přidává podporu pro Razor Pages a minimální podporu kontroleru. Šablona webové aplikace používá tento kód:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddRazorPages();
}
```

Nové metody lze také kombinovat. Následující příklad je ekvivalentní `AddMvc` volání v ASP.NET jádrem 2.2:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews();
    services.AddRazorPages();
}
```

## <a name="routing-startup-code"></a>Směrovací spouštěcí kód

Pokud aplikace `UseMvc` volá `UseSignalR`nebo , pokud je to možné, migruje ji do [směrování koncového bodu.](xref:fundamentals/routing) Abychom zlepšili kompatibilitu směrování koncových bodů s předchozími verzemi MVC, vrátili jsme některé změny ve generování adres URL zavedené v ASP.NET Core 2.2. Pokud jste v bodě 2.2 zaznamenali problémy s směrováním koncových bodů, očekávejte zlepšení ASP.NET jádra 3.0 s následujícími výjimkami:

* Pokud aplikace implementuje `IRouter` nebo `Route`dědí z , použijte [DynamicRouteValuesTransformer](https://github.com/dotnet/AspNetCore.Docs/issues/12997) jako náhradu.
* Pokud aplikace přímo `RouteData.Routers` přistupuje uvnitř MVC analyzovat adresy URL, můžete nahradit pomocí [LinkParser.ParsePathByEndpointName](xref:Microsoft.AspNetCore.Routing.LinkParserEndpointNameAddressExtensions.ParsePathByEndpointName*). 
  * Definujte trasu s názvem trasy.
  * Použijte `LinkParser.ParsePathByEndpointName` a předavte požadovaný název trasy.

Směrování koncových bodů podporuje stejnou syntaxi vzoru `IRouter`trasy a funkce vytváření vzorců trasy jako . Směrování koncových `IRouteConstraint`bodů podporuje . Směrování koncového `[Route]` `[HttpGet]`bodu podporuje , a další atributy směrování MVC.

U většiny aplikací `Startup` vyžaduje pouze změny.

### <a name="migrate-startupconfigure"></a>Migrace po spuštění.Konfigurace

Obecné rady:

* Přidat `UseRouting`.
* Pokud aplikace `UseStaticFiles`volá `UseStaticFiles` , umístěte **před .** `UseRouting`
* Pokud aplikace `AuthorizePage` používá funkce ověřování/autorizace, například nebo `[Authorize]`, `UseRouting` `UseCors`volání `UseAuthentication` : `UseEndpoints` **po** `UseAuthorization`, a , ale před :

  ```csharp
  public void Configure(IApplicationBuilder app)
  {
    ...

    app.UseStaticFiles();

    app.UseRouting();
    app.UseCors();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints => {
       endpoints.MapControllers();
    });
  ```

* Nahradit `UseMvc` `UseSignalR` nebo `UseEndpoints`s .
* Pokud aplikace používá scénáře [CORS,](xref:security/cors) `[EnableCors]`například `UseCors` , umístěte volání před jakýkoli jiný middleware, `UseAuthorization`které `UseEndpoints`používají CORS (například místo `UseCors` před `UseAuthentication`, a ).
* Nahraďte `IHostingEnvironment` `IWebHostEnvironment` a `using` přidejte <xref:Microsoft.Extensions.Hosting?displayProperty=fullName> příkaz pro obor názvů.
* Nahradit `IApplicationLifetime` <xref:Microsoft.Extensions.Hosting.IHostApplicationLifetime> (obor<xref:Microsoft.Extensions.Hosting?displayProperty=fullName> názvů).
* Nahradit `EnvironmentName` <xref:Microsoft.Extensions.Hosting.Environments> (obor<xref:Microsoft.Extensions.Hosting?displayProperty=fullName> názvů).

Následující kód je příkladem `Startup.Configure` v typické ASP.NET aplikace Core 2.2:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();

    app.UseAuthentication();

    app.UseSignalR(hubs =>
    {
        hubs.MapHub<ChatHub>("/chat");
    });

    app.UseMvc(routes =>
    {
        routes.MapRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

Po aktualizaci `Startup.Configure` předchozího kódu:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();

    app.UseRouting();

    app.UseCors();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>("/chat");
        endpoints.MapControllerRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

> [!WARNING]
> U většiny aplikací `UseAuthentication`musí `UseAuthorization`být `UseCors` mezi voláními `UseRouting` a `UseEndpoints` efektivními voláními volání a musí být zobrazena volání .

### <a name="health-checks"></a>Kontroly stavu

Kontroly stavu používají směrování koncových bodů s obecným hostitelem. V `Startup.Configure`aplikace `MapHealthChecks` volejte tvůrce koncového bodu s adresou URL koncového bodu nebo relativní cestou:

```csharp
app.UseEndpoints(endpoints =>
{
    endpoints.MapHealthChecks("/health");
});
```

Koncové body kontroly stavu mohou:

* Zadejte jeden nebo více povolených hostitelů/portů.
* Vyžadovat autorizaci.
* Vyžadovat CORS.

Další informace naleznete v tématu <xref:host-and-deploy/health-checks>.

### <a name="security-middleware-guidance"></a>Pokyny pro middlewar zabezpečení

Podpora autorizace a CORS je jednotná kolem [middlewarového přístupu.](xref:fundamentals/middleware/index) To umožňuje použití stejného middleware a funkce v těchto scénářích. V této verzi je k dispozici aktualizovaný middleware autorizace a cors middleware je vylepšentak, aby mohl porozumět atributům používaným řadiči MVC.

#### <a name="cors"></a>CORS

Dříve cors může být obtížné konfigurovat. Middleware byl určen pro použití v některých případech použití, ale MVC filtry byly určeny k použití **bez** middleware v jiných případech použití. S ASP.NET Core 3.0, doporučujeme, aby všechny aplikace, které vyžadují CORS používat CORS Middleware v tandemu s Koncovým bodem směrování. `UseCors`může být k dispozici s `[EnableCors]` výchozí `[DisableCors]` zásady a atributy lze přepsat výchozí zásady v případě potřeby.

V následujícím příkladu:

* CORS je povolena pro `default` všechny koncové body s pojmenovanou zásadou.
* Třída `MyController` zakáže CORS `[DisableCors]` s atributem.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseCors("default");

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[DisableCors]
public class MyController : ControllerBase
{
    ...
}
```

#### <a name="authorization"></a>Autorizace

V dřívějších verzích ASP.NET Core byla prostřednictvím atributu `[Authorize]` poskytována podpora autorizace. Autorizace middleware nebyla k dispozici. V ASP.NET Core 3.0 je vyžadován autorizační middleware. Doporučujeme umístit ASP.NET Core Authorization`UseAuthorization`Middleware `UseAuthentication`( ) ihned po . Middleware autorizace lze také nakonfigurovat s výchozí zásadou, kterou lze přepsat.

V ASP.NET je volána `UseAuthorization` `Startup.Configure`aplikace Core 3.0 `HomeController` nebo novější a následující vyžaduje přihlášeného uživatele:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

public class HomeController : Controller
{
    [Authorize]
    public IActionResult BuyWidgets()
    {
        ...
    }
}
```

Při použití směrování koncových bodů `<xref:Microsoft.AspNetCore.Mvc.Authorization.AuthorizeFilter>` doporučujeme nekonfigurovat a místo toho spoléhat na middleware autorizace.  Pokud aplikace používá `AuthorizeFilter` jako globální filtr v MVC, doporučujeme refaktoring kód poskytnout `AddAuthorization`zásady ve volání .

Původně `DefaultPolicy` je nakonfigurován tak, aby vyžadoval ověření, takže není vyžadována žádná další konfigurace. V následujícím příkladu jsou koncové body `RequireAuthorization` MVC označeny tak, aby `DefaultPolicy`všechny požadavky musí být autorizovány na základě . Nicméně, `HomeController` umožňuje přístup bez přihlášení uživatele do `[AllowAnonymous]`aplikace z důvodu :

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute().RequireAuthorization();
    });
}

[AllowAnonymous]
public class HomeController : Controller
{
    ...
}
```

### <a name="authorization-for-specific-endpoints"></a>Autorizace pro konkrétní koncové body

Autorizaci lze také nakonfigurovat pro konkrétní třídy koncových bodů. Následující kód je příkladem převodu aplikace MVC, `AuthorizeFilter` která nakonfigurovala globální aplikaci s konkrétní zásadou vyžadující autorizaci:

[!code-csharp[](22-to-30/samples/Startup.cs?name=snippet&highlight=8-9,21-22,26-27,53-54)]

Zásady lze také přizpůsobit. Je `DefaultPolicy` nakonfigurován tak, aby vyžadoval ověření:

[!code-csharp[](22-to-30/samples/Startup2.cs?name=snippet&highlight=21-26,52)]

[!code-csharp[](22-to-30/samples/HomeController.cs?name=snippet)]

Alternativně všechny koncové body lze nakonfigurovat `[Authorize]` `RequireAuthorization` tak, aby `FallbackPolicy`vyžadovaly autorizaci bez nebo konfigurací . Je `FallbackPolicy` odlišný od `DefaultPolicy`. Je `DefaultPolicy` spuštěn `[Authorize]` anebo `RequireAuthorization`, `FallbackPolicy` zatímco je aktivována, když není nastavena žádná jiná zásada. `FallbackPolicy`je zpočátku nakonfigurován tak, aby umožňoval požadavky bez autorizace.

Následující příklad je stejný jako `DefaultPolicy` předchozí příklad, `FallbackPolicy` ale používá chcete vždy vyžadovat `[AllowAnonymous]` ověření na všech koncových bodech s výjimkou případů, kdy je zadán:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    ...

    services.AddAuthorization(options =>
    {
        options.FallbackPolicy = new AuthorizationPolicyBuilder()
          .RequireAuthenticatedUser()
          .Build();
    });
}

public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[AllowAnonymous]
public class HomeController : Controller
{
    ...
}
```

Autorizace middleware funguje bez rámce, který má jakékoli specifické znalosti autorizace. Například [kontroly stavu](xref:host-and-deploy/health-checks) nemá žádné specifické znalosti autorizace, ale kontroly stavu může mít konfigurovatelné zásady autorizace použít middleware.

Kromě toho každý koncový bod můžete přizpůsobit své požadavky na autorizaci. V následujícím `UseAuthorization` příkladu zpracovává `DefaultPolicy`autorizaci `/healthz` pomocí koncového `admin` bodu , ale koncový bod kontroly stavu vyžaduje uživatele:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints
            .MapHealthChecks("/healthz")
            .RequireAuthorization(new AuthorizeAttribute(){ Roles = "admin", });
    });
}
```

Ochrana je implementována pro některé scénáře. Endpoints Middleware vyvolá výjimku, pokud je přeskočí autorizace nebo zásady CORS z důvodu chybějící middleware. Probíhá podpora analyzátoru, která poskytuje další zpětnou vazbu o chybné konfiguraci.

#### <a name="custom-authorization-handlers"></a>Vlastní obslužné rutiny autorizace

Pokud aplikace používá vlastní [obslužné rutiny autorizace](xref:security/authorization/policies#authorization-handlers), směrování koncových bodů předá obslužné rutiny jiný typ prostředku než MVC. Obslužné rutiny, které očekávají, že prostředek kontextu obslužné rutiny autorizace bude typu <xref:Microsoft.AspNetCore.Mvc.Filters.AuthorizationFilterContext> (typ prostředku [poskytované filtry MVC)](xref:security/authorization/policies#accessing-mvc-request-context-in-handlers)bude nutné aktualizovat, aby bylo možné zpracovávat prostředky typu <xref:Microsoft.AspNetCore.Routing.RouteEndpoint> (typ prostředku daný obslužným rutinám autorizace směrováním koncových bodů).

MVC stále `AuthorizationFilterContext` používá prostředky, takže pokud aplikace používá filtry autorizace MVC spolu s autorizací směrování koncového bodu, může být nutné zpracovat oba typy prostředků.

### SignalR

Mapování SignalR rozbočovačů `UseEndpoints`nyní probíhá uvnitř .

Namapujte `MapHub`každý rozbočovač pomocí . Stejně jako v předchozích verzích je každý rozbočovač explicitně uveden.

V následujícím příkladu je `ChatHub` SignalR přidána podpora pro rozbočovač:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>();
    });
}
```

Existuje nová možnost pro řízení omezení velikosti zprávy od klientů. Například v `Startup.ConfigureServices`:

```csharp
services.AddSignalR(hubOptions =>
{
    hubOptions.MaximumReceiveMessageSize = 32768;
});
```

V ASP.NET Jádrem 2.2 `TransportMaxBufferSize` můžete nastavit a to by efektivně řídilo maximální velikost zprávy. V ASP.NET Core 3.0, tato možnost nyní řídí pouze maximální velikost před dodržena protitlak.

### <a name="mvc-controllers"></a>Řídicí jednotky MVC

Mapování regulátorů nyní probíhá uvnitř `UseEndpoints`.

Pokud `MapControllers` aplikace používá směrování atributů, přidejte je. Vzhledem k tomu, že směrování zahrnuje podporu pro mnoho architektur v ASP.NET Core 3.0 nebo novější, přidání řadičů směrované atribut je opt-in.

Nahraďte následující:

* `MapRoute`S`MapControllerRoute`
* `MapAreaRoute`S`MapAreaControllerRoute`

Vzhledem k tomu, směrování nyní zahrnuje podporu pro více než jen MVC, terminologie se změnila, aby tyto metody jasně uvést, co dělají. Konvenční trasy, `MapControllerRoute` / `MapAreaControllerRoute` / `MapDefaultControllerRoute` například jsou použity v pořadí, ve které jsou přidány. Nejprve umístěte konkrétnější trasy (například trasy pro určitou oblast).

V následujícím příkladu:

* `MapControllers`přidá podporu pro řadiče směrované atributy.
* `MapAreaControllerRoute`přidá konvenční trasu pro regulátory v oblasti.
* `MapControllerRoute`přidává konvenční trasu pro regulátory.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapControllers();
        endpoints.MapAreaControllerRoute(
            "admin",
            "admin",
            "Admin/{controller=Home}/{action=Index}/{id?}");
        endpoints.MapControllerRoute(
            "default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

#### <a name="async-suffix-removal-from-controller-action-names"></a>Odebrání asynchronní přípony z názvů akcí kontroleru

V ASP.NET Core 3.0 ASP.NET Core MVC odebere `Async` příponu z názvů akcí řadiče. Toto nové výchozí nastavení ovlivňuje generování směrování i propojení. Příklad:

```csharp
public class ProductsController : Controller
{
    public async Task<IActionResult> ListAsync()
    {
        var model = await _dbContext.Products.ToListAsync();
        return View(model);
    }
}
```

Před ASP.NET Core 3.0:

* Předchozí akce lze přistupovat na *produkty/ListAsync* trasy.
* Generování propojení vyžaduje `Async` zadání přípony. Příklad:

    ```cshtml
    <a asp-controller="Products" asp-action="ListAsync">List</a>
    ```

V ASP.NET Jádrem 3.0:

* Předchozí akce je přístupná na cestě *Produkty/Seznam.*
* Generování propojení nevyžaduje zadání `Async` přípony. Příklad:

    ```cshtml
    <a asp-controller="Products" asp-action="List">List</a>
    ```

Tato změna nemá vliv na [`[ActionName]`](/dotnet/api/microsoft.aspnetcore.mvc.actionnameattribute) názvy zadané pomocí atributu. Výchozí chování lze zakázat s `Startup.ConfigureServices`následujícím kódem v :

```csharp
services.AddMvc(options =>
    options.SuppressAsyncSuffixInActionNames = false);
```

#### <a name="changes-to-link-generation"></a>Změny generování propojení

Jak je vysvětleno v dokumentaci o [rozdílech od předchozích verzí](xref:fundamentals/routing#differences-from-earlier-versions-of-routing) `Url.Link` směrování , existují určité rozdíly v generování propojení (použití a podobné api, například). Mezi ně patří:

* Ve výchozím nastavení není při použití směrování koncového bodu nutně zachováno caseing parametrů trasy v generovaných identifikátorech URI. Toto chování lze `IOutboundParameterTransformer` ovládat pomocí rozhraní.
* Generování identifikátoru URI pro neplatnou trasu (řadič/akce nebo stránka, která neexistuje) vytvoří prázdný řetězec pod směrováním koncového bodu namísto vytvoření neplatného identifikátoru URI.
* Okolní hodnoty (parametry trasy z aktuálního kontextu) se při generování propojení se směrováním koncových bodů automaticky nepoužívají. Dříve při generování odkazu na jinou akci (nebo stránku) by nespecifikované hodnoty trasy byly odvozeny z *aktuálních* hodnot okolí tras. Při použití směrování koncového bodu musí být všechny parametry trasy zadány explicitně během generování propojení.

### <a name="razor-pages"></a>Razor Pages

Mapování Razor Stránky nyní `UseEndpoints`probíhá uvnitř .

Přidejte, `MapRazorPages` pokud aplikace používá Razor Pages. Vzhledem k tomu, endpoint směrování zahrnuje podporu pro mnoho rámců, přidání Razor Pages je nyní opt-in.

V následující `Startup.Configure` metodě `MapRazorPages` přidává podporu pro Razor Pages:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapRazorPages();
    });
}
```

### <a name="use-mvc-without-endpoint-routing"></a>Použití MVC bez směrování koncových bodů

Použití MVC `UseMvc` `UseMvcWithDefaultRoute` přes nebo v ASP.NET Core 3.0 `Startup.ConfigureServices`vyžaduje explicitní opt-in uvnitř . To je nutné, protože MVC musí vědět, zda se může spolehnout na autorizaci a CORS Middleware během inicializace. Je k dispozici analyzátor, který varuje, pokud se aplikace pokusí použít nepodporovanou konfiguraci.

Pokud aplikace vyžaduje `IRouter` starší `EnableEndpointRouting` verzi podpory, zakažte pomocí některého z následujících přístupů v aplikaci `Startup.ConfigureServices`:

```csharp
services.AddMvc(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllers(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllersWithViews(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddRazorPages().AddMvcOptions(options => options.EnableEndpointRouting = false);
```

### <a name="health-checks"></a>Kontroly stavu

Kontroly stavu lze použít jako *router-ware* s Koncovým bodem Směrování.

Přidejte `MapHealthChecks` k použití kontrol stavu s směrováním koncových bodů. Metoda `MapHealthChecks` přijímá argumenty podobné `UseHealthChecks`. Výhodou použití `MapHealthChecks` přes `UseHealthChecks` je možnost použít autorizaci a mít větší jemně odstupňovanou kontrolu nad zásady párování.

V následujícím příkladu se `MapHealthChecks` volá pro koncový `/healthz`bod kontroly stavu na adrese :

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHealthChecks("/healthz", new HealthCheckOptions() { });
    });
}
```

## <a name="hostbuilder-replaces-webhostbuilder"></a>HostBuilder nahrazuje WebHostBuilder

Šablony ASP.NET Core 3.0 používají [obecný hostitel](xref:fundamentals/host/generic-host). Předchozí verze používaly [webhosting .](xref:fundamentals/host/web-host) Následující kód ukazuje ASP.NET třídu generovanou `Program` šablonou Core 3.0:

[!code-csharp[](22-to-30/samples/Program.cs?name=snippet)]

Následující kód ukazuje ASP.NET třídu generovanou `Program` šablonou Core 2.2:

[!code-csharp[](22-to-30/samples/Program2.2.cs?name=snippet)]

<xref:Microsoft.AspNetCore.Hosting.IWebHostBuilder>zůstává v 3.0 a je `webBuilder` typ vidět v předchozí ukázku kódu. <xref:Microsoft.AspNetCore.Hosting.WebHostBuilder>bude v budoucí verzi zastaralá a `HostBuilder`bude nahrazena písmenem .

Nejvýznamnější změnou `WebHostBuilder` od `HostBuilder` do je v [injektáž závislostí (DI)](xref:fundamentals/dependency-injection). Při `HostBuilder`použití můžete do konstruktoru `Startup`společnosti injektovat pouze následující:

* <xref:Microsoft.Extensions.Configuration.IConfiguration>
* <xref:Microsoft.Extensions.Hosting.IHostEnvironment>
* <xref:Microsoft.AspNetCore.Hosting.IWebHostEnvironment>

Omezení `HostBuilder` DI:

* Povolte kontejner DI, který má být sestaven pouze jednou.
* Zabraňuje výsledné problémy životnost objektu, jako je řešení více instancí singletons.

Další informace naleznete [v tématu Zabránění injektáži služby spuštění v ASP.NET jádru 3](https://andrewlock.net/avoiding-startup-service-injection-in-asp-net-core-3/).

## <a name="addauthorization-moved-to-a-different-assembly"></a>AddAuthorization přesunuta do jiného sestavení

Metoda ASP.NET Core 2.2 a nižší `AddAuthorization` metody v *souboru Microsoft.AspNetCore.Authorization.dll*:

* Byly přejmenovány `AddAuthorizationCore`.
* Byly přesunuty na *soubor Microsoft.AspNetCore.Authorization.Policy.dll*.

Aplikace, které používají *microsoft.aspNetCore.Authorization.dll* a *Microsoft.AspNetCore.Authorization.Policy.dll* nejsou ovlivněny.

Aplikace, které nepoužívají *microsoft.aspNetCore.Authorization.Policy.dll* by měl udělat jednu z následujících akcí:

* Přidejte odkaz na soubor *Microsoft.AspNetCore.Authorization.Policy.dll*. Tento přístup funguje pro většinu aplikací a je vše, co je potřeba.
* Přepnout na používání`AddAuthorizationCore`

Další informace naleznete [v `AddAuthorization(o =>`tématu Breaking change in ) overload lives in a different assembly #386](https://github.com/aspnet/Announcements/issues/386).

## <a name="identity-ui"></a>Identity UI

Aktualizace ui identity pro ASP.NET Jádra 3.0:

* Přidejte odkaz na odkaz na [microsoft.aspNetCore.Identity.UI](https://nuget.org/packages/Microsoft.AspNetCore.Identity.UI).
* Aplikace, které nepoužívají Razor `MapRazorPages`Pages, musí volat . Viz [Razor Pages](#razor-pages) v tomto dokumentu.
* Bootstrap 4 je výchozí rozhraní ui. Nastavte `IdentityUIFrameworkVersion` vlastnost projektu pro změnu výchozíhodnoty. Další informace naleznete v [tomto oznámení GitHubu](https://github.com/aspnet/Announcements/issues/380).

## SignalR

Klient SignalR Jazyka JavaScript `@aspnet/signalr` se `@microsoft/signalr`změnil z na . Chcete-li reagovat na tuto změnu, změňte `require` odkazy v *package.json* soubory, příkazy a ecmascript `import` příkazy.

### <a name="systemtextjson-is-the-default-protocol"></a>System.Text.Json je výchozí protokol

`System.Text.Json`je nyní výchozím protokolem Hub používaným klientem i serverem.

V `Startup.ConfigureServices`aplikaci volání `AddJsonProtocol` nastavte možnosti serializátoru.

**Server:**

```csharp
services.AddSignalR(...)
        .AddJsonProtocol(options =>
        {
            options.PayloadSerializerOptions.WriteIndented = false;
        })
```

**Klienta:**

```csharp
new HubConnectionBuilder()
    .WithUrl("/chatHub")
    .AddJsonProtocol(options =>
    {
        options.PayloadSerializerOptions.WriteIndented = false;
    })
    .Build();
```

### <a name="switch-to-newtonsoftjson"></a>Přejít na Newtonsoft.Json

Pokud používáte [funkce Newtonsoft.Json, které nejsou podporovány v System.Text.Json](/dotnet/standard/serialization/system-text-json-migrate-from-newtonsoft-how-to) `Newtonsoft.Json`, můžete přepnout zpět na . Viz [Použití Newtonsoft.Json v projektu SignalR ASP.NET Core 3.0](#use-newtonsoftjson-in-an-aspnet-core-30-signalr-project) dříve v tomto článku.

## <a name="redis-distributed-caches"></a>Distribuované mezipaměti Redis

Balíček [Microsoft.Extensions.Caching.Redis](https://www.nuget.org/packages/Microsoft.Extensions.Caching.Redis) není k dispozici pro aplikace ASP.NET Core 3.0 nebo novější. Nahraďte odkaz na balíček odkaz [microsoft.Extensions.Caching.StackExchangeRedis](https://www.nuget.org/packages/Microsoft.Extensions.Caching.StackExchangeRedis). Další informace naleznete v tématu <xref:performance/caching/distributed>.

## <a name="opt-in-to-runtime-compilation"></a>Přihlásit se k kompilaci runtime

Před ASP.NET Core 3.0, runtime kompilace zobrazení byla implicitní funkce rozhraní. Runtime kompilace doplňuje sestavení kompilace zobrazení. To umožňuje rámci kompilovat Razor zobrazení a stránky (*.cshtml* soubory), když jsou soubory změněny, aniž by bylo nutné znovu sestavit celou aplikaci. Tato funkce podporuje scénář provedení rychlých úprav v prostředí IDE a aktualizace prohlížeče pro zobrazení změn.

V ASP.NET Core 3.0 je kompilace za běhu scénářem pro přihlášení. Kompilace v době sestavení je jediným mechanismem pro kompilaci zobrazení, který je ve výchozím nastavení povolen. Modul runtime závisí na Visual Studio nebo [dotnet-watch](xref:tutorials/dotnet-watch) v kódu sady Visual Studio k opětovnému sestavení projektu při zjištění změn souborů *.cshtml.* V sadě Visual Studio změny *.cs*, *.cshtml*nebo *.razor* soubory v projektu běží (<kbd>Ctrl+F5</kbd>), ale není laděný (<kbd>F5</kbd>), vyvolat rekompilaci projektu.

Povolení kompilace za běhu v projektu ASP.NET Core 3.0:

1. Nainstalujte balíček [NuGet pro kompilaci Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation.](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation)
1. Aktualizace `Startup.ConfigureServices` pro `AddRazorRuntimeCompilation`volání :

    Pro ASP.NET Core MVC použijte následující kód:

    ```csharp
    services.AddControllersWithViews()
        .AddRazorRuntimeCompilation(...);
    ```
 
    Pro ASP.NET core razor stránky použijte následující kód:
 
    ```csharp
    services.AddRazorPages()
        .AddRazorRuntimeCompilation(...);
    ```
 
Ukázka https://github.com/aspnet/samples/tree/master/samples/aspnetcore/mvc/runtimecompilation na ukazuje příklad povolení runtime kompilace podmíněně ve vývojových prostředích.

Další informace o kompilaci <xref:mvc/views/view-compilation>souborů Razor naleznete v tématu .

## <a name="migrate-libraries-via-multi-targeting"></a>Migrace knihoven prostřednictvím vícenásobného cílení

Knihovny často potřebují podporovat více verzí ASP.NET Core. Většina knihoven, které byly zkompilovány proti předchozím verzím ASP.NET Core by měla pokračovat v práci bez problémů. Následující podmínky vyžadují, aby se aplikace křížově zkompilovala:

* Knihovna se spoléhá na funkci, která má binární [změna rozdělení](#breaking-api-changes).
* Knihovna chce využít nové funkce v ASP.NET Core 3.0. 

Příklad:

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFrameworks>netcoreapp3.0;netstandard2.0</TargetFrameworks>
  </PropertyGroup>

  <ItemGroup Condition="'$(TargetFramework)' == 'netcoreapp3.0'">
    <FrameworkReference Include="Microsoft.AspNetCore.App" />
  </ItemGroup>

  <ItemGroup Condition="'$(TargetFramework)' == 'netstandard2.0'">
    <PackageReference Include="Microsoft.AspNetCore" Version="2.1.0" />
  </ItemGroup>
</Project>
```

Slouží `#ifdefs` k povolení ASP.NET jádra 3.0 specifická api:

```csharp
var webRootFileProvider =
#if NETCOREAPP3_0
    GetRequiredService<IWebHostEnvironment>().WebRootFileProvider;
#elif NETSTANDARD2_0
    GetRequiredService<IHostingEnvironment>().WebRootFileProvider;
#else
#error unknown target framework
#endif
```

Další informace o použití ASP.NET jádrových api <xref:fundamentals/target-aspnetcore>v knihovně tříd naleznete v tématu .

## <a name="miscellaneous-changes"></a>Různé změny

Ověřovací systém v rozhraní .NET Core 3.0 a novější zachází s parametry `[Required]` s nenulovatelnými parametry nebo vázanými vlastnostmi, jako by měly atribut. Další informace naleznete v [tématu [Required] attribute](xref:mvc/models/validation?view=aspnetcore-3.1#required-attribute).

### <a name="publish"></a>Publikování

Odstraňte složky *bin* a *obj* v adresáři projektu.

## <a name="testserver"></a>Testovací server

Pro aplikace, <xref:Microsoft.AspNetCore.TestHost.TestServer> které používají přímo s `TestServer` [obecným hostitelem](xref:fundamentals/host/web-host), vytvořte <xref:Microsoft.AspNetCore.Hosting.IWebHostBuilder> na in <xref:Microsoft.Extensions.Hosting.GenericHostWebHostBuilderExtensions.ConfigureWebHost%2A>:

```csharp
[Fact]
public async Task GenericCreateAndStartHost_GetTestServer()
{
    using var host = await new HostBuilder()
        .ConfigureWebHost(webBuilder =>
        {
            webBuilder
                .UseTestServer()
                .Configure(app => { });
        })
    .StartAsync();

    var response = await host.GetTestServer().CreateClient().GetAsync("/");

    Assert.Equal(HttpStatusCode.NotFound, response.StatusCode);
}
```

<a name="break"></a>

## <a name="breaking-api-changes"></a>Rozdělení změn rozhraní API

Zkontrolujte nejnovější změny:

* [Kompletní seznam nejnovějších změn ve verzi ASP.NET Core 3.0](https://github.com/aspnet/Announcements/issues?page=1&q=is%3Aissue+is%3Aopen+label%3A%22Breaking+change%22+label%3A3.0.0)
* [Rozdělení změn rozhraní API v antiforgery, CORS, diagnostika, MVC a směrování](https://github.com/aspnet/Announcements/issues/387). Tento seznam obsahuje nejnovější změny pro přepínače kompatibility.
* Souhrn 2.2-to-3.0 nejnovější změny v rámci .NET Core, ASP.NET Core a entity framework core, naleznete [v tématu rozdělení změn pro migraci z verze 2.2 na 3.0](/dotnet/core/compatibility/2.2-3.0).

## <a name="net-core-30-on-azure-app-service"></a>.NET Core 3.0 ve službě Azure App Service

Postup při zavádění služby .NET Core do služby Azure App Service najdete na oficiálním webu [.NET Core on App Service.](https://aspnetcoreon.azurewebsites.net/) Dokud nebude ve službě Azure App Service k dispozici jádro .NET Core 3.0, postupujte podle pokynů na [webu Deploy ASP.NET Core Preview release to Azure App Service](xref:host-and-deploy/azure-apps/index#deploy-aspnet-core-preview-release-to-azure-app-service).
