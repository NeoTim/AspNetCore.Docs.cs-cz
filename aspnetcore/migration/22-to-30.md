---
title: Migrace z ASP.NET Core 2,2 na 3,0
author: rick-anderson
description: Přečtěte si, jak migrovat projekt ASP.NET Core 2,2 do ASP.NET Core 3,0.
ms.author: riande
ms.custom: mvc
ms.date: 11/12/2019
no-loc:
- SignalR
uid: migration/22-to-30
ms.openlocfilehash: e8f22c3e7b82b84afe513bf495ff5a46a527bb73
ms.sourcegitcommit: 231780c8d7848943e5e9fd55e93f437f7e5a371d
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 11/15/2019
ms.locfileid: "74116077"
---
# <a name="migrate-from-aspnet-core-22-to-30"></a>Migrace z ASP.NET Core 2,2 na 3,0

[Scottem Addie](https://github.com/scottaddie) a [Rick Anderson](https://twitter.com/RickAndMSFT)

Tento článek vysvětluje, jak aktualizovat existující projekt ASP.NET Core 2,2 na ASP.NET Core 3,0.

## <a name="prerequisites"></a>Požadavky

# <a name="visual-studiotabvisual-studio"></a>[Visual Studio](#tab/visual-studio)

[!INCLUDE[](~/includes/net-core-prereqs-vs-3.0.md)]

# <a name="visual-studio-codetabvisual-studio-code"></a>[Visual Studio Code](#tab/visual-studio-code)

[!INCLUDE[](~/includes/net-core-prereqs-vsc-3.0.md)]

# <a name="visual-studio-for-mactabvisual-studio-mac"></a>[Visual Studio pro Mac](#tab/visual-studio-mac)

[!INCLUDE[](~/includes/net-core-prereqs-mac-3.0.md)]

---

## <a name="update-net-core-sdk-version-in-globaljson"></a>Aktualizace verze .NET Core SDK v Global. JSON

Pokud vaše řešení využívá soubor [Global. JSON](/dotnet/core/tools/global-json) pro cílení na konkrétní verzi .NET Core SDK, aktualizujte jeho vlastnost `version` na verzi 3,0 nainstalovanou na vašem počítači:

```json
{
  "sdk": {
    "version": "3.0.100"
  }
}
```

## <a name="update-the-project-file"></a>Aktualizovat soubor projektu

### <a name="update-the-target-framework"></a>Aktualizace cílového rozhraní .NET Framework

ASP.NET Core 3,0 a novější se spouští pouze v .NET Core. Nastavte [moniker cílového rozhraní (TFM)](/dotnet/standard/frameworks) na `netcoreapp3.0`:

[!code-xml[](22-to-30/samples/Web1.csproj?highlight=4)]

### <a name="remove-obsolete-package-references"></a>Odebrat zastaralé odkazy na balíčky

ASP.NET Core už nevytváří velký počet funkcí balíčků NuGet. Tyto odkazy na balíčky by měly být odebrány ze souboru projektu. Například soubor projektu generovaný šablonou pro webovou aplikaci ASP.NET Core 2,2:

```xml
<Project Sdk="Microsoft.NET.Sdk.Web">

  <PropertyGroup>
    <TargetFramework>netcoreapp2.2</TargetFramework>
    <AspNetCoreHostingModel>InProcess</AspNetCoreHostingModel>
  </PropertyGroup>


  <ItemGroup>
    <PackageReference Include="Microsoft.AspNetCore.App"/>
    <PackageReference Include="Microsoft.AspNetCore.Razor.Design" Version="2.2.0" PrivateAssets="All" />
  </ItemGroup>

</Project>
```

Aktualizovaný soubor projektu ASP.NET Core 3,0:

[!code-xml[](22-to-30/samples/Web1.csproj?highlight=4)]

Aktualizovaný soubor projektu ASP.NET Core 3,0:

* V `<PropertyGroup>`:

  * Aktualizuje TFM na `netcoreapp3.0`
  * Odebere prvek `<AspNetCoreHostingModel>`. Další informace najdete v tématu [model hostování v procesu](#in-process-hosting-model) v tomto dokumentu.

* V `<ItemGroup>`:

  * `Microsoft.AspNetCore.App` se odebralo. Další informace najdete v tématu [Reference k rozhraní](#framework-reference) v tomto dokumentu.
  * `Microsoft.AspNetCore.Razor.Design` se odebere a v následujícím seznamu už se balíčky neprodukují.

Úplný seznam balíčků, které už nejsou vytvořené, zobrazíte tak, že vyberete následující seznam rozbalit:

<details>
    <summary>Kliknutím sem rozbalíte seznam balíčků, které už nejsou vyráběny.</summary>
    <ul>
        <li>Microsoft. AspNetCore</li>
        <li>Microsoft. AspNetCore. All</li>
        <li>Microsoft. AspNetCore. app</li>
        <li>Microsoft.AspNetCore.Antiforgery</li>
        <li>Microsoft.AspNetCore.Authentication</li>
        <li>Microsoft.AspNetCore.Authentication.Abstractions</li>
        <li>Microsoft.AspNetCore.Authentication.Cookies</li>
        <li>Microsoft.AspNetCore.Authentication.Core</li>
        <li>Microsoft.AspNetCore.Authentication.JwtBearer</li>
        <li>Microsoft.AspNetCore.Authentication.OAuth</li>
        <li>Microsoft.AspNetCore.Authentication.OpenIdConnect</li>
        <li>Microsoft.AspNetCore.Authorization</li>
        <li>Microsoft.AspNetCore.Authorization.Policy</li>
        <li>Microsoft.AspNetCore.CookiePolicy</li>
        <li>Microsoft.AspNetCore.Cors</li>
        <li>Microsoft.AspNetCore.Cryptography.Internal</li>
        <li>Microsoft.AspNetCore.Cryptography.KeyDerivation</li>
        <li>Microsoft. AspNetCore. DataProtection</li>
        <li>Microsoft.AspNetCore.DataProtection.Abstractions</li>
        <li>Microsoft.AspNetCore.DataProtection.Extensions</li>
        <li>Microsoft.AspNetCore.Diagnostics</li>
        <li>Microsoft.AspNetCore.Diagnostics.HealthChecks</li>
        <li>Microsoft. AspNetCore. HostFiltering</li>
        <li>Microsoft. AspNetCore. hosting</li>
        <li>Microsoft.AspNetCore.Hosting.Abstractions</li>
        <li>Microsoft.AspNetCore.Hosting.Server.Abstractions</li>
        <li>Microsoft.AspNetCore.Http</li>
        <li>Microsoft.AspNetCore.Http.Abstractions</li>
        <li>Microsoft.AspNetCore.Http.Connections</li>
        <li>Microsoft.AspNetCore.Http.Extensions</li>
        <li>Microsoft.AspNetCore.Http.Features</li>
        <li>Microsoft.AspNetCore.HttpOverrides</li>
        <li>Microsoft.AspNetCore.HttpsPolicy</li>
        <li>Microsoft.AspNetCore.Identity</li>
        <li>Microsoft.AspNetCore.Localization</li>
        <li>Microsoft.AspNetCore.Localization.Routing</li>
        <li>Microsoft.AspNetCore.MiddlewareAnalysis</li>
        <li>Microsoft. AspNetCore. Mvc</li>
        <li>Microsoft.AspNetCore.Mvc.Abstractions</li>
        <li>Microsoft.AspNetCore.Mvc.Analyzers</li>
        <li>Microsoft.AspNetCore.Mvc.ApiExplorer</li>
        <li>Microsoft.AspNetCore.Mvc.Api.Analyzers</li>
        <li>Microsoft.AspNetCore.Mvc.Core</li>
        <li>Microsoft.AspNetCore.Mvc.Cors</li>
        <li>Microsoft.AspNetCore.Mvc.DataAnnotations</li>
        <li>Microsoft.AspNetCore.Mvc.Formatters.Json</li>
        <li>Microsoft.AspNetCore.Mvc.Formatters.Xml</li>
        <li>Microsoft.AspNetCore.Mvc.Localization</li>
        <li>Microsoft. AspNetCore. Mvc. Razor</li>
        <li>Microsoft.AspNetCore.Mvc.Razor.Extensions</li>
        <li>Microsoft.AspNetCore.Mvc.Razor.ViewCompilation</li>
        <li>Microsoft.AspNetCore.Mvc.RazorPages</li>
        <li>Microsoft.AspNetCore.Mvc.TagHelpers</li>
        <li>Microsoft.AspNetCore.Mvc.ViewFeatures</li>
        <li>Microsoft.AspNetCore.Razor</li>
        <li>Microsoft.AspNetCore.Razor.Runtime</li>
        <li>Microsoft.AspNetCore.Razor.Design</li>
        <li>Microsoft.AspNetCore.ResponseCaching</li>
        <li>Microsoft.AspNetCore.ResponseCaching.Abstractions</li>
        <li>Microsoft.AspNetCore.ResponseCompression</li>
        <li>Microsoft.AspNetCore.Rewrite</li>
        <li>Microsoft. AspNetCore. Routing</li>
        <li>Microsoft.AspNetCore.Routing.Abstractions</li>
        <li>Microsoft.AspNetCore.Server.HttpSys</li>
        <li>Microsoft.AspNetCore.Server.IIS</li>
        <li>Microsoft.AspNetCore.Server.IISIntegration</li>
        <li>Microsoft.AspNetCore.Server.Kestrel</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Core</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Https</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets</li>
        <li>Microsoft.AspNetCore.Session</li>
        <li>Microsoft. AspNetCore.SignalR</li>
        <li>Microsoft. AspNetCore.SignalR. Core</li>
        <li>Microsoft. AspNetCore. StaticFiles</li>
        <li>Microsoft.AspNetCore.WebSockets</li>
        <li>Microsoft.AspNetCore.WebUtilities</li>
        <li>Microsoft.Net. http. Headers</li>
    </ul>
</details>

### <a name="review-breaking-changes"></a>Kontrola nejnovějších změn

[Kontrola nejnovějších změn](#break)

### <a name="framework-reference"></a>Odkaz na rozhraní

Funkce ASP.NET Core, které byly k dispozici prostřednictvím jednoho z výše uvedených balíčků, jsou k dispozici jako součást `Microsoft.AspNetCore.App` sdílené architektury. *Sdílené rozhraní* je sada sestavení (soubory *. dll* ), které jsou nainstalovány na počítači a zahrnují komponentu modulu runtime a sadu targeting pack. Další informace najdete v tématu [sdílené rozhraní](https://natemcmaster.com/blog/2018/08/29/netcore-primitives-2/).

* Projekty, které cílí na sadu SDK `Microsoft.NET.Sdk.Web` implicitně odkazují na `Microsoft.AspNetCore.App` Framework.

  Pro tyto projekty nejsou vyžadovány žádné další odkazy:

  ```xml
  <Project Sdk="Microsoft.NET.Sdk.Web">
    <PropertyGroup>
      <TargetFramework>netcoreapp3.0</TargetFramework>
    </PropertyGroup>
      ...
  </Project>
  ```

* Projekty, které cílí na `Microsoft.NET.Sdk` nebo `Microsoft.NET.Sdk.Razor` SDK, by měly přidat explicitní `FrameworkReference` do `Microsoft.AspNetCore.App`:

  ```xml
  <Project Sdk="Microsoft.NET.Sdk.Razor">
    <PropertyGroup>
      <TargetFramework>netcoreapp3.0</TargetFramework>
    </PropertyGroup>

    <ItemGroup>
      <FrameworkReference Include="Microsoft.AspNetCore.App" />
    </ItemGroup>
      ...
  </Project>
  ```

#### <a name="framework-dependent-builds-using-docker"></a>Sestavení závislá na rozhraních pomocí Docker

Sestavení závislé na rozhraních konzolových aplikací, které používají balíček, který závisí na ASP.NET Core [sdílenému rozhraní](https://natemcmaster.com/blog/2018/08/29/netcore-primitives-2/) , mohou poskytnout následující chybu za běhu:

```console
It was not possible to find any compatible framework version
The specified framework 'Microsoft.AspNetCore.App', version '3.0.0' was not found.
  - No frameworks were found.
```

`Microsoft.AspNetCore.App` je sdílené rozhraní obsahující ASP.NET Core Runtime a je přítomno pouze v imagi [dotnet/Core/ASPNET](https://hub.docker.com/_/microsoft-dotnet-core-aspnet/) Docker.  Sada SDK 3,0 omezuje velikost závislých sestavení pomocí asp.net jádra, protože nezahrnuje duplicitní kopie knihoven, které jsou k dispozici ve sdíleném rozhraní.  Jedná se o potenciální úspory až 18 MB, ale vyžaduje, aby se při spuštění aplikace mohl spustit modul runtime ASP.NET Core nebo musí být nainstalovaný.

Pokud chcete zjistit, jestli má aplikace závislost (buď přímá, nebo nepřímá) na ASP.NET Core sdíleném rozhraním, Projděte si soubor *runtimeconfig. JSON* vygenerovaný během sestavování/publikování vaší aplikace. Následující soubor JSON ukazuje závislost na ASP.NET Core sdílené rozhraní:

```json
{
  "runtimeOptions": {
    "tfm": "netcoreapp3.0",
    "framework": {
      "name": "Microsoft.AspNetCore.App",
      "version": "3.0.0"
    },
    "configProperties": {
      "System.GC.Server": true
    }
  }
}
```

Pokud vaše aplikace používá Docker, použijte základní image, která zahrnuje ASP.NET Core 3,0. Například `docker pull mcr.microsoft.com/dotnet/core/aspnet:3.0`.

### <a name="add-package-references-for-removed-assemblies"></a>Přidat odkazy na balíčky pro odebraná sestavení

ASP.NET Core 3,0 odstraní některá sestavení, která byla dříve součástí odkazu na balíček `Microsoft.AspNetCore.App`. Chcete-li pokračovat v používání funkcí poskytovaných těmito sestaveními, odkazujte na verze 3,0 odpovídajících balíčků:

* Webová aplikace vygenerovaná šablonou s **jednotlivými uživatelskými účty** vyžaduje přidání následujících balíčků:

  [!code-xml[](22-to-30/samples/WebFull.csproj?highlight=9-13)]

* [Microsoft. EntityFrameworkCore](https://www.nuget.org/packages/Microsoft.EntityFrameworkCore)

  Další informace o odkazování na balíček pro konkrétního poskytovatele databáze najdete v tématu [poskytovatelé databáze](/ef/core/providers/index).

* Uživatelské rozhraní identity

  Podporu [uživatelského rozhraní identity](xref:security/authentication/identity) lze přidat odkazem na balíček [Microsoft. AspNetCore. identity. UI](https://www.nuget.org/packages/Microsoft.AspNetCore.Identity.UI) .

* Služby SPA

  * [Microsoft. AspNetCore. SpaServices](https://www.nuget.org/packages/Microsoft.AspNetCore.SpaServices)
  * [Microsoft. AspNetCore. SpaServices. Extensions](https://www.nuget.org/packages/Microsoft.AspNetCore.SpaServices.Extensions)

* Podpora &ndash; ověřování pro toky ověřování třetích stran je k dispozici jako balíčky NuGet:

  * Facebook OAuth ([Microsoft. AspNetCore. Authentication. Facebook](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Facebook))
  * Google OAuth ([Microsoft. AspNetCore. Authentication. Google](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Google))
  * Token nosiče OpenID Connect ([Microsoft. AspNetCore. Authentication. JwtBearer](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.JwtBearer))
  * Ověřování účtu Microsoft ([Microsoft. AspNetCore. Authentication. MicrosoftAccount](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.MicrosoftAccount))
  * OpenID Connect Authentication ([Microsoft. AspNetCore. Authentication. OpenIdConnect](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.OpenIdConnect))
  * Twitter OAuth ([Microsoft. AspNetCore. Authentication. Twitter](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Twitter))
  * Ověřování WsFederation ([Microsoft. AspNetCore. Authentication. WsFederation](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.WsFederation))

* Podpora formátování a vyjednávání obsahu pro `System.Net.HttpClient` &ndash; balíček NuGet [Microsoft. ASPNET. WebApi. Client](https://www.nuget.org/packages/Microsoft.AspNet.WebApi.Client/) poskytuje užitečnou rozšiřitelnost pro `System.Net.HttpClient` s rozhraními API, jako jsou `ReadAsAsync`, `PostJsonAsync` atd.

* Běhová kompilace Razor &ndash; podporu pro kompilaci za běhu zobrazení Razor a stránek je teď součástí [Microsoft. AspNetCore. Mvc. Razor. RuntimeCompilation](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation).

* MVC `Newtonsoft.Json` podporují &ndash; podporu pro použití MVC s `Newtonsoft.Json` je teď součástí [Microsoft. AspNetCore. Mvc. NewtonsoftJson](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson).

## <a name="startup-changes"></a>Změny při spuštění

Na následujícím obrázku vidíte odstraněný a změněný řádek ve webové aplikaci ASP.NET Core 2,2 Razor Pages:

![odstraněné a změněné řádky ve webové aplikaci ASP.NET Core 2,2 Razor](22-to-30/_static/startup2.2.png)

Na předchozím obrázku se odstraněný kód zobrazuje červeně. Odstraněný kód nezobrazuje kód možnosti souboru cookie, který byl odstraněn před porovnáním souborů.

Na následujícím obrázku vidíte přidané a změněné řádky ve webové aplikaci ASP.NET Core 3,0 Razor Pages:

![přidané a změněné řádky ve webové aplikaci ASP.NET Core 3,0 Razor](22-to-30/_static/startup3.0.png)

Na předchozím obrázku se přidaný kód zobrazuje zeleně. Informace o následujících změnách:

* `services.AddMvc` k `services.AddRazorPages`najdete v tématu [Registrace služby MVC](#mvc-service-registration) v tomto dokumentu.
* `CompatibilityVersion`najdete v tématu <xref:mvc/compatibility-version>.
* `IHostingEnvironment` k `IWebHostEnvironment`najdete v [tomto oznámení GitHubu](https://github.com/aspnet/AspNetCore/issues/7749).
* do šablon se přidala `app.UseAuthorization`, aby se zobrazila služba autorizačního rozhraní pro autorizaci, kterou je třeba přidat. Pokud aplikace nepoužívá autorizaci, můžete hovor bezpečně odebrat `app.UseAuthorization`.
* `app.UseEndpoints`, přečtěte si téma [Razor Pages](#razor-pages) nebo [migruje Startup. Configure](#migrate-startupconfigure) v tomto dokumentu.

### <a name="analyzer-support"></a>Podpora analyzátoru

Projekty, které cílí na `Microsoft.NET.Sdk.Web` implicitně odkazovaly na analyzátory dříve dodávané jako součást balíčku [Microsoft. AspNetCore. Mvc. analyzers](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Analyzers/) . K povolení těchto kroků nejsou vyžadovány žádné další odkazy.

Pokud vaše aplikace používá [analyzátory rozhraní API](xref:web-api/advanced/analyzers) dříve dodávané pomocí balíčku [Microsoft. AspNetCore. Mvc. API. analyzers](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Api.Analyzers/) , upravte soubor projektu tak, aby odkazoval na analyzátory dodávané jako součást sady .NET Core web SDK:

```xml
<Project Sdk="Microsoft.NET.Sdk.Web">
    <PropertyGroup>
        <TargetFramework>netcoreapp3.0</TargetFramework>
        <IncludeOpenAPIAnalyzers>true</IncludeOpenAPIAnalyzers>
    </PropertyGroup>

    ...
</Project>
```

### <a name="razor-class-library"></a>Knihovna tříd Razor

Projekty knihovny tříd Razor, které poskytují komponenty uživatelského rozhraní pro MVC musí nastavit vlastnost `AddRazorSupportForMvc` v souboru projektu:

```xml
<PropertyGroup>
  <AddRazorSupportForMvc>true</AddRazorSupportForMvc>
</PropertyGroup>
```

### <a name="in-process-hosting-model"></a>Model hostování v procesu

Projekty jsou ve výchozím nastavení pro [model hostování v rámci procesu](xref:host-and-deploy/aspnet-core-module#in-process-hosting-model) v ASP.NET Core 3,0 nebo novějším. Případně můžete odebrat vlastnost `<AspNetCoreHostingModel>` v souboru projektu, pokud je její hodnota `InProcess`.

## <a name="kestrel"></a>Kestrel

### <a name="configuration"></a>Konfigurace

Migrujte konfiguraci Kestrel do Tvůrce webového hostitele, který poskytuje `ConfigureWebHostDefaults` (*program.cs*):

```csharp
public static IHostBuilder CreateHostBuilder(string[] args) =>
    Host.CreateDefaultBuilder(args)
        .ConfigureWebHostDefaults(webBuilder =>
        {
            webBuilder.ConfigureKestrel(serverOptions =>
            {
                // Set properties and call methods on options
            })
            .UseStartup<Startup>();
        });
```

Pokud aplikace vytvoří hostitele ručně pomocí `HostBuilder`, zavolejte `UseKestrel` na tvůrci webového hostitele v `ConfigureWebHostDefaults`:

```csharp
public static void Main(string[] args)
{
    var host = new HostBuilder()
        .UseContentRoot(Directory.GetCurrentDirectory())
        .ConfigureWebHostDefaults(webBuilder =>
        {
            webBuilder.UseKestrel(serverOptions =>
            {
                // Set properties and call methods on options
            })
            .UseIISIntegration()
            .UseStartup<Startup>();
        })
        .Build();

    host.Run();
}
```

### <a name="connection-middleware-replaces-connection-adapters"></a>Middleware připojení nahrazuje adaptéry připojení

Připojovací adaptéry (`Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.IConnectionAdapter`) byly odebrány z Kestrel. Nahraďte připojovací adaptéry pomocí middleware připojení. Middleware připojení se podobá middlewaru protokolu HTTP v kanálu ASP.NET Core, ale pro připojení nižší úrovně. Protokol HTTPS a protokolování připojení:

* Byly přesunuty z připojovacích adaptérů na middleware připojení.
* Tyto metody rozšíření fungují jako v předchozích verzích ASP.NET Core. 

Další informace najdete v [příkladu TlsFilterConnectionHandler v části ListenOptions. Protocols článku Kestrel](/aspnet/core/fundamentals/servers/kestrel?view=aspnetcore-3.0#listenoptionsprotocols).

### <a name="transport-abstractions-moved-and-made-public"></a>Přemístění a zpřístupnění abstrakcí přenosu

Transportní vrstva Kestrel byla vystavena jako veřejné rozhraní v `Connections.Abstractions`. Jako součást těchto aktualizací:

* byly odebrány `Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions` a přidružené typy.
* <xref:Microsoft.AspNetCore.Server.Kestrel.KestrelServerOptions.NoDelay> se přesunul z <xref:Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions> na možnosti přenosu.
* `Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions.Internal.SchedulingMode` byl odebrán z <xref:Microsoft.AspNetCore.Server.Kestrel.KestrelServerOptions>.

Další informace najdete v následujících materiálech GitHubu:

* [Abstrakce sítě klienta/serveru (ASPNET/AspNetCore #10308)](https://github.com/aspnet/AspNetCore/issues/10308)
* [Implementujte nové abstrakce naslouchacího procesu Bedrock a Kestrel znovu platně (ASPNET/AspNetCore #10321)](https://github.com/aspnet/AspNetCore/pull/10321)

### <a name="kestrel-request-trailer-headers"></a>Hlavičky přípojných vozidel žádosti Kestrel

Pro aplikace, které cílí na starší verze ASP.NET Core:

* Kestrel přidá hlavičky přípojného bodu HTTP/1.1 do kolekce hlaviček požadavků.
* Po načtení textu žádosti na konec jsou k dispozici Přípojná místa.

To způsobuje některé obavy z nejednoznačnosti mezi hlavičkami a přípojnými vozidly, takže přípojná vozidla byla přesunuta do nové kolekce (`RequestTrailerExtensions`) v 3,0.

Přívěsy žádostí HTTP/2 jsou:

* Není k dispozici v ASP.NET Core 2,2.
* K dispozici v 3,0 jako `RequestTrailerExtensions`.

Pro přístup k těmto přípojným vozidlům jsou k dispozici nové metody rozšíření žádosti. Stejně jako v případě protokolu HTTP/1.1 jsou po načtení textu žádosti na konec k dispozici Přípojná místa.

Pro vydání 3,0 jsou k dispozici následující metody `RequestTrailerExtensions`:

* `GetDeclaredTrailers` &ndash; získá hlavičku `Trailer` žádosti, která obsahuje seznam přípojných vozidel, která se mají po tělo očekávat.
* `SupportsTrailers` &ndash; určuje, zda požadavek podporuje příjem hlaviček přípojných vozidel.
* `CheckTrailersAvailable` &ndash; kontroluje, zda požadavek podporuje Přípojná místa a zda jsou k dispozici pro čtení. Tato kontrolu nepředpokládá, že existuje přívěsy ke čtení. Není možné, aby bylo možné číst bez přípojných vozidel, i když tato metoda vrací `true`.
* `GetTrailer` &ndash; Získá požadovanou ukončovací hlavičku z odpovědi. Před voláním `GetTrailer` ověřte `SupportsTrailers`, nebo se může vyskytnout <xref:System.NotSupportedException>, pokud požadavek nepodporuje koncové hlavičky.

Další informace najdete v tématu [o umístění přípojných vozidel v samostatné kolekci (ASPNET/AspNetCore #10410)](https://github.com/aspnet/AspNetCore/pull/10410).

### <a name="allowsynchronousio-disabled"></a>AllowSynchronousIO zakázané

`AllowSynchronousIO` povoluje nebo zakazuje synchronní rozhraní API pro vstupně-výstupní operace, jako jsou `HttpRequest.Body.Read`, `HttpResponse.Body.Write`a `Stream.Flush`. Tato rozhraní API jsou zdrojem vyčerpání vláken, který vede k selhání aplikace. V 3,0 je `AllowSynchronousIO` ve výchozím nastavení zakázaný. Další informace najdete [v části synchronní v/v v článku Kestrel](/aspnet/core/fundamentals/servers/kestrel?view=aspnetcore-3.0#synchronous-io).

Pokud je potřeba synchronní v/v, můžete ho povolit nakonfigurováním možnosti `AllowSynchronousIO` na používaném serveru (při volání `ConfigureKestrel`, například při použití Kestrel). Upozorňujeme, že servery (Kestrel, HttpSys, TestServer atd.) mají vlastní možnost `AllowSynchronousIO`, která neovlivní ostatní servery. Synchronní v/v se dá pro všechny servery na základě jednotlivých požadavků povolit pomocí možnosti `IHttpBodyControlFeature.AllowSynchronousIO`:

```csharp
var syncIOFeature = HttpContext.Features.Get<IHttpBodyControlFeature>();

if (syncIOFeature != null)
{
    syncIOFeature.AllowSynchronousIO = true;
}
```

Pokud máte potíže s <xref:System.IO.TextWriter> implementacemi nebo jinými datovými proudy, které volají synchronní rozhraní API v [Dispose](/dotnet/standard/garbage-collection/implementing-dispose), zavolejte místo toho nové rozhraní API <xref:System.IO.Stream.DisposeAsync*>.

Další informace najdete v tématu [[oznámení] AllowSynchronousIO zakázáno na všech serverech (ASPNET/AspNetCore #7644)](https://github.com/aspnet/AspNetCore/issues/7644).

### <a name="microsoftaspnetcoreserverkestrelhttps-assembly-removed"></a>Bylo odebráno sestavení Microsoft. AspNetCore. Server. Kestrel. https.

V ASP.NET Core 2,1 se obsah souboru *Microsoft. AspNetCore. Server. Kestrel. https. dll* přesunul do souboru *Microsoft. AspNetCore. Server. Kestrel. Core. dll*. Toto byla neprůlomová aktualizace pomocí atributů `TypeForwardedTo`. Pro 3,0 byla odebrána prázdná sestavení *Microsoft. AspNetCore. Server. Kestrel. https. dll* a balíček NuGet.

Knihovny odkazující na [Microsoft. AspNetCore. Server. Kestrel. https](https://www.nuget.org/packages/Microsoft.AspNetCore.Server.Kestrel.Https) by měly aktualizovat ASP.NET Core závislosti na 2,1 nebo novější.

Aplikace a knihovny cílené na ASP.NET Core 2,1 nebo novější by měly odebrat všechny přímé odkazy na balíček [Microsoft. AspNetCore. Server. Kestrel. https](https://www.nuget.org/packages/Microsoft.AspNetCore.Server.Kestrel.Https) .

## <a name="jsonnet-support"></a>Podpora Json.NET

Jako součást práce pro [zlepšení ASP.NET Core sdílené architektury](https://blogs.msdn.microsoft.com/webdev/2018/10/29/a-first-look-at-changes-coming-in-asp-net-core-3-0/)se [JSON.NET](https://www.newtonsoft.com/json/help/html/Introduction.htm) z ASP.NET Core sdílené architektury odebral.

Výchozí hodnota pro ASP.NET Core je Now [System. text. JSON](/dotnet/api/system.text.json?view=netcore-3.0), která je v .net Core 3,0 novinkou. Pokud je to možné, zvažte použití `System.Text.Json`. Je to vysoký výkon a nevyžaduje další závislost knihovny. Vzhledem k tomu, že `System.Text.Json` je nová, může v současnosti chybět funkce, které vaše aplikace potřebuje.

Vaše aplikace může vyžadovat `Newtonsoft.Json` integraci, pokud používá funkci `Newtonsoft.Json`, jako je JsonPatch nebo převaděče, nebo pokud [formátuje](xref:web-api/advanced/formatting) typy `Newtonsoft.Json` specifické.

Pokud chcete používat Json.NET v projektu SignalR ASP.NET Core 3,0, přečtěte si téma [Přepnutí na Newtonsoft. JSON](#switch-to-newtonsoftjson) v tomto dokumentu.

Použití Json.NET v projektu ASP.NET Core 3,0:

* Přidejte odkaz na balíček [Microsoft. AspNetCore. Mvc. NewtonsoftJson](https://nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson).
* Aktualizujte `Startup.ConfigureServices` pro volání `AddNewtonsoftJson`.

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson();
  ```

  `AddNewtonsoftJson` je kompatibilní s novými metodami registrace služby MVC:

  * `AddRazorPages`
  * `AddControllersWithViews`
  * `AddControllers`

  ```csharp
  services.AddControllers()
      .AddNewtonsoftJson();
  ```

  Nastavení Json.NET lze nastavit v volání `AddNewtonsoftJson`:

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson(options =>
             options.SerializerSettings.ContractResolver =
                new CamelCasePropertyNamesContractResolver());
  ```

## <a name="mvc-service-registration"></a>Registrace služby MVC

ASP.NET Core 3,0 přidává nové možnosti pro registraci scénářů MVC v rámci `Startup.ConfigureServices`.

K dispozici jsou tři nové rozšiřující metody nejvyšší úrovně související se scénáři MVC v `IServiceCollection`. Šablony používají tyto nové metody místo `AddMvc`. `AddMvc` se však nadále chovat stejně jako v předchozích verzích.

Následující příklad přidá podporu pro řadiče a funkce související s rozhraním API, ale ne zobrazení nebo stránky. Šablona rozhraní API používá tento kód:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllers();
}
```

Následující příklad přidá podporu pro řadiče, funkce související s rozhraním API a zobrazení, ale ne stránky. Šablona webové aplikace (MVC) používá tento kód:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews();
}
```

V následujícím příkladu se přidá podpora pro Razor Pages a minimální Podpora řadičů. Šablona webové aplikace používá tento kód:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddRazorPages();
}
```

Nové metody lze také kombinovat. Následující příklad je ekvivalentní volání `AddMvc` v ASP.NET Core 2,2:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews();
    services.AddRazorPages();
}
```

## <a name="routing-startup-code"></a>Spouštěcí kód směrování

Pokud aplikace volá `UseMvc` nebo `UseSignalR`, migrujte aplikaci do [Směrování koncových bodů](xref:fundamentals/routing) , pokud je to možné. Pro zlepšení kompatibility směrování koncových bodů s předchozími verzemi MVC jsme vrátili některé změny v adrese URL představené v ASP.NET Core 2,2. Pokud jste narazili na problémy s používáním směrování koncových bodů v 2,2, můžete očekávat vylepšení ASP.NET Core 3,0 s následujícími výjimkami:

* Pokud aplikace implementuje `IRouter` nebo dědí z `Route`, použijte jako náhradu [DynamicRouteValuesTransformer](https://github.com/aspnet/AspNetCore.Docs/issues/12997) .

* Pokud aplikace přímo přistupuje k `RouteData.Routers` v rámci MVC k analýze adres URL, můžete ji nahradit použitím `LinkParser.ParsePathByEndpointName`. 
 * Zadejte trasu s názvem trasy.
 * Použijte `LinkParser.ParsePathByEndpointName` a předejte název požadované trasy.

Směrování koncového bodu podporuje stejnou syntaxi vzorů směrování a funkce vytváření vzorů směrování jako `IRouter`. Směrování koncového bodu podporuje `IRouteConstraint`. Směrování koncového bodu podporuje `[Route]`, `[HttpGet]`a další atributy směrování MVC.

U většiny aplikací `Startup` vyžaduje pouze změny.

### <a name="migrate-startupconfigure"></a>Migrovat Startup. Configure

Obecné pokyny:

* Přidejte `UseRouting`.
* Pokud aplikace volá `UseStaticFiles`, umístěte `UseStaticFiles` **před** `UseRouting`.
* Pokud aplikace používá funkce pro ověřování a autorizaci, jako je `AuthorizePage` nebo `[Authorize]`, umístěte volání `UseAuthentication` a `UseAuthorization`: **po**`UseRouting` `UseCors`a `UseEndpoints`, ale před:

  ```csharp
  public void Configure(IApplicationBuilder app)
  {
    ...

    app.UseStaticFiles();

    app.UseRouting();
    app.UseCors();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints => {
       endpoints.MapControllers();
    });
  ```

* Nahraďte `UseMvc` nebo `UseSignalR` `UseEndpoints`.
* Pokud aplikace používá scénáře [CORS](xref:security/cors) , jako je například `[EnableCors]`, umístěte volání do `UseCors` před jakýmkoli jiným middlewarem, který používá CORS (třeba umístit `UseCors` před `UseAuthentication`, `UseAuthorization`a `UseEndpoints`).
* Nahraďte `IHostingEnvironment` `IWebHostEnvironment` a přidejte příkaz `using` pro obor názvů <xref:Microsoft.Extensions.Hosting?displayProperty=fullName>.
* Nahraďte `IApplicationLifetime` pomocí <xref:Microsoft.Extensions.Hosting.IHostApplicationLifetime> (<xref:Microsoft.Extensions.Hosting?displayProperty=fullName> obor názvů).
* Nahraďte `EnvironmentName` pomocí <xref:Microsoft.Extensions.Hosting.Environments> (<xref:Microsoft.Extensions.Hosting?displayProperty=fullName> obor názvů).

Následující kód je příkladem `Startup.Configure` v typické aplikaci ASP.NET Core 2,2:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();

    app.UseAuthentication();

    app.UseSignalR(hubs =>
    {
        hubs.MapHub<ChatHub>("/chat");
    });

    app.UseMvc(routes =>
    {
        routes.MapRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

Po aktualizaci předchozího kódu `Startup.Configure`:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();

    app.UseRouting();

    app.UseCors();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>("/chat");
        endpoints.MapControllerRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

> [!WARNING]
> Pro většinu aplikací se musí volat `UseAuthentication`, `UseAuthorization`a `UseCors` mezi voláními `UseRouting` a `UseEndpoints`, aby byly účinné.

### <a name="health-checks"></a>Kontroly stavu

Kontroly stavu používají směrování koncových bodů u obecného hostitele. V `Startup.Configure`volejte `MapHealthChecks` v Tvůrci koncových bodů s adresou URL koncového bodu nebo relativní cestou:

```csharp
app.UseEndpoints(endpoints =>
{
    endpoints.MapHealthChecks("/health");
});
```

Koncové body kontrol stavu můžou:

* Zadejte minimálně jednoho povoleného hostitele nebo portů.
* Vyžadovat autorizaci.
* Vyžadovat CORS

Další informace najdete v tématu <xref:host-and-deploy/health-checks>.

### <a name="security-middleware-guidance"></a>Doprovodné materiály k zabezpečení middlewaru

Podpora pro autorizaci a CORS je sjednocená v rámci přístupu [middlewaru](xref:fundamentals/middleware/index) . To umožňuje používat stejný middlewar a funkčnost v těchto scénářích. V této verzi je k dispozici aktualizovaný middleware autorizace a middleware CORS je vylepšený, aby bylo možné pochopit atributy používané řadiči MVC.

#### <a name="cors"></a>CORS

V minulosti mohlo být obtížné nakonfigurovat CORS. Middleware byl poskytnut pro použití v některých případech použití, ale filtry MVC byly určeny k použití **bez** middlewaru v jiných případech použití. U ASP.NET Core 3,0 doporučujeme, aby všechny aplikace, které vyžadují CORS, používaly middleware CORS v kombinaci s směrováním koncových bodů. `UseCors` lze zadat s výchozí zásadou a atributy `[EnableCors]` a `[DisableCors]` lze použít k přepsání výchozích zásad v případě potřeby.

V následujícím příkladu:

* CORS je povolená pro všechny koncové body s `default` pojmenovanými zásadami.
* Třída `MyController` zakáže CORS s atributem `[DisableCors]`.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseCors("default");

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[DisableCors]
public class MyController : ControllerBase
{
    ...
}
```

#### <a name="authorization"></a>Autorizace

V dřívějších verzích ASP.NET Core byla poskytnuta podpora autorizace prostřednictvím atributu `[Authorize]`. Autorizační middleware není k dispozici. V ASP.NET Core 3,0 se vyžaduje middleware autorizace. Doporučujeme, abyste ASP.NET Core autorizačního middlewaru (`UseAuthorization`) hned po `UseAuthentication`. Middleware autorizace se dá nakonfigurovat taky s výchozími zásadami, které se dají přepsat.

V ASP.NET Core 3,0 nebo novějším se `UseAuthorization` volá v `Startup.Configure`a následující `HomeController` vyžaduje přihlášeného uživatele:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

public class HomeController : ControllerBase
{
    [Authorize]
    public IActionResult BuyWidgets()
    {
        ...
    }
}
```

Pokud aplikace používá `AuthorizeFilter` jako globální filtr v MVC, doporučujeme, abyste kód refaktoringu poskytovali ve volání `AddAuthorization`.

`DefaultPolicy` je zpočátku nakonfigurovaný tak, aby vyžadoval ověřování, takže se nevyžaduje žádná další konfigurace. V následujícím příkladu jsou koncové body MVC označeny jako `RequireAuthorization`, takže všechny požadavky musí být autorizovány na základě `DefaultPolicy`. `HomeController` ale umožňuje přístup bez přihlášení uživatele k aplikaci z důvodu `[AllowAnonymous]`:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute().RequireAuthorization();
    });
}

[AllowAnonymous]
public class HomeController : ControllerBase
{
    ...
}
```

Zásady je také možné přizpůsobit. Při sestavování v předchozím příkladu je `DefaultPolicy` nakonfigurovaná tak, aby vyžadovala ověřování a určitý rozsah:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    ...

    services.AddAuthorization(options =>
    {
        options.DefaultPolicy = new AuthorizationPolicyBuilder()
          .RequireAuthenticatedUser()
          .Build();
    });
}

public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute().RequireAuthorization();
    });
}

[AllowAnonymous]
public class HomeController : ControllerBase
{
    ...
}
```

Alternativně lze všechny koncové body nakonfigurovat tak, aby vyžadovaly autorizaci bez `[Authorize]` nebo `RequireAuthorization` konfigurací `FallbackPolicy`. `FallbackPolicy` se liší od `DefaultPolicy`. `DefaultPolicy` aktivuje `[Authorize]` nebo `RequireAuthorization`, zatímco `FallbackPolicy` se aktivuje, když nejsou nastavené žádné jiné zásady. `FallbackPolicy` je zpočátku nakonfigurovaný tak, aby povoloval požadavky bez autorizace.

Následující příklad je stejný jako předchozí `DefaultPolicy` příklad, ale používá `FallbackPolicy`, aby vždy vyžadoval ověřování u všech koncových bodů s výjimkou případů, kdy je určena `[AllowAnonymous]`.

```csharp
public void ConfigureServices(IServiceCollection services)
{
    ...

    services.AddAuthorization(options =>
    {
        options.FallbackPolicy = new AuthorizationPolicyBuilder()
          .RequireAuthenticatedUser()
          .Build();
    });
}

public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[AllowAnonymous]
public class HomeController : ControllerBase
{
    ...
}
```

Ověřování pomocí middlewaru funguje bez rozhraní, které má konkrétní znalosti o autorizaci. [Kontroly stavu](xref:host-and-deploy/health-checks) například nemají žádné konkrétní znalosti o autorizaci, ale kontroly stavu můžou mít konfigurovatelné zásady autorizace, které používá middleware.

Každý koncový bod navíc může přizpůsobit své autorizační požadavky. V následujícím příkladu `UseAuthorization` zpracovává autorizaci pomocí `DefaultPolicy`, ale koncový bod kontroly stavu `/healthz` vyžaduje `admin` uživatele:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints
            .MapHealthChecks("/healthz")
            .RequireAuthorization(new AuthorizeAttribute(){ Roles = "admin", });
    });
}
```

Ochrana je implementovaná pro některé scénáře. Middleware koncové body vyvolá výjimku, pokud se zásada autorizace nebo CORS z důvodu chybějícího middlewaru přeskočí. Podpora analyzátoru, která poskytuje další názory na neplatnou konfiguraci.

#### <a name="custom-authorization-handlers"></a>Vlastní obslužné rutiny autorizace

Pokud aplikace používá vlastní [obslužné rutiny autorizace](xref:security/authorization/policies#authorization-handlers), uvědomte si, že směrování koncového bodu předává do obslužných rutin než MVC jiný typ prostředku. Obslužné rutiny, které očekávají, že prostředek kontextu obslužné rutiny autorizace je typu <xref:Microsoft.AspNetCore.Mvc.Filters.AuthorizationFilterContext> (typ prostředku [poskytovaný filtry MVC](xref:security/authorization/policies#accessing-mvc-request-context-in-handlers)), bude nutné aktualizovat, aby zpracovával prostředky typu <xref:Microsoft.AspNetCore.Routing.RouteEndpoint> (typ prostředku, který se předala obslužným rutinám autorizace podle směrování koncových bodů).

MVC stále používá `AuthorizationFilterContext`ch prostředků, takže pokud aplikace používá autorizační filtry MVC spolu s autorizací směrování koncových bodů, může být nutné zpracovat oba typy prostředků.

### SignalR

Mapování SignalRch Center se teď provádí v `UseEndpoints`.

Namapujte všechna centra pomocí `MapHub`. Stejně jako v předchozích verzích je každé centrum výslovně uvedené.

V následujícím příkladu se přidá podpora SignalR centra `ChatHub`:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>();
    });
}
```

Pro řízení omezení velikosti zprávy od klientů je k dispozici nová možnost. Například v `Startup.ConfigureServices`:

```csharp
services.AddSignalR(hubOptions =>
{
    hubOptions.MaximumReceiveMessageSize = 32768;
});
```

V ASP.NET Core 2,2 můžete nastavit `TransportMaxBufferSize` a tím efektivně řídit maximální velikost zprávy. V ASP.NET Core 3,0 Tato možnost nyní určuje pouze maximální velikost před nedodržením přítlaku.

### <a name="mvc-controllers"></a>Řadiče MVC

Mapování řadičů teď probíhá uvnitř `UseEndpoints`.

Pokud aplikace používá směrování atributů, přidejte `MapControllers`. Vzhledem k tomu, že směrování zahrnuje podporu pro mnoho platforem v ASP.NET Core 3,0 nebo novějších, je přidání řadičů směrovaných k atributům výslovný souhlas.

Nahraďte následující:

* `MapRoute` s `MapControllerRoute`
* `MapAreaRoute` s `MapAreaControllerRoute`

Vzhledem k tomu, že směrování nyní zahrnuje podporu pro více než jen MVC, se terminologie změnila, aby tyto metody jasně zajistila, co dělají. Konvenční trasy, například `MapControllerRoute` / `MapAreaControllerRoute` / `MapDefaultControllerRoute` jsou aplikovány v pořadí, v jakém byly přidány. Nejprve umístěte konkrétnější trasy (například trasy pro oblast).

V následujícím příkladu:

* `MapControllers` přidává podporu pro řadiče směrované atributy.
* `MapAreaControllerRoute` přidá konvenční trasu pro řadiče v oblasti.
* `MapControllerRoute` přidá konvenční trasu pro řadiče.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapControllers();
        endpoints.MapAreaControllerRoute(
            "admin",
            "admin",
            "Admin/{controller=Home}/{action=Index}/{id?}");
        endpoints.MapControllerRoute(
            "default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

#### <a name="async-suffix-removal-from-controller-action-names"></a>Odebrání asynchronní přípony z názvů akcí kontroleru

V ASP.NET Core 3,0 ASP.NET Core MVC odebere příponu `Async` z názvů akcí řadiče. Tato nová výchozí hodnota má vliv na generaci směrování i propojení. Příklad:

```csharp
public class ProductsController : Controller
{
    public async Task<IActionResult> ListAsync()
    {
        var model = await _dbContext.Products.ToListAsync();
        return View(model);
    }
}
```

Před ASP.NET Core 3,0:

* K předchozí akci může být přistup v trase *Products/ListAsync* .
* Vyžaduje se generování propojení, které určuje příponu `Async`. Příklad:

    ```cshtml
    <a asp-controller="Products" asp-action="ListAsync">List</a>
    ```

V ASP.NET Core 3,0:

* Předchozí akce je k dispozici na trase *Products/List* .
* Generování odkazu nevyžaduje zadání přípony `Async`. Příklad:

    ```cshtml
    <a asp-controller="Products" asp-action="List">List</a>
    ```

Tato změna nemá vliv na názvy zadané pomocí atributu [[Action]](/dotnet/api/microsoft.aspnetcore.mvc.actionnameattribute) . Výchozí chování lze zakázat pomocí následujícího kódu v `Startup.ConfigureServices`:

```csharp
services.AddMvc(options =>
    options.SuppressAsyncSuffixInActionNames = false);
```

#### <a name="changes-to-link-generation"></a>Změny při vytváření propojení

Jak je vysvětleno v dokumentaci k [rozdílům z dřívějších verzí směrování](xref:fundamentals/routing#differences-from-earlier-versions-of-routing), existují rozdíly v generování odkazů (například pomocí `Url.Link` a podobných rozhraní API). Zde jsou některé z nich:

* Ve výchozím nastavení platí, že při použití směrování koncových bodů není velká a malá písmena parametrů trasy v generovaných identifikátorech URI nutně zachovaná. Toto chování lze řídit pomocí rozhraní `IOutboundParameterTransformer`.
* Generování identifikátoru URI pro neplatnou trasu (kontroler/akce nebo stránka, která neexistuje) vytvoří v rámci směrování koncového bodu prázdný řetězec místo vytvoření neplatného identifikátoru URI.
* Okolní hodnoty (parametry tras z aktuálního kontextu) se automaticky nepoužívají při vytváření odkazů s směrováním koncových bodů. Dříve při generování odkazu na jinou akci (nebo stránku) byly neurčené hodnoty tras odvozeny od hodnot okolí *aktuální* trasy. Při použití směrování koncového bodu musí být všechny parametry směrování explicitně zadané během generování propojení.

### <a name="razor-pages"></a>Razor Pages

Mapování Razor Pages nyní probíhá uvnitř `UseEndpoints`.

Pokud aplikace používá Razor Pages, přidejte `MapRazorPages`. Vzhledem k tomu, že směrování koncových bodů zahrnuje podporu pro spoustu platforem, přidání Razor Pages je nyní výslovným souhlasem.

V následující metodě `Startup.Configure` `MapRazorPages` přidá podporu pro Razor Pages:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapRazorPages();
    });
}
```

### <a name="use-mvc-without-endpoint-routing"></a>Použití MVC bez směrování koncových bodů

Použití MVC prostřednictvím `UseMvc` nebo `UseMvcWithDefaultRoute` v ASP.NET Core 3,0 vyžaduje explicitní výslovný souhlas uvnitř `Startup.ConfigureServices`. To je nutné, protože MVC musí zjistit, jestli se může při inicializaci spoléhat na autorizaci a middleware CORS. K dispozici je analyzátor, který se upozorní, pokud se aplikace pokusí použít nepodporovanou konfiguraci.

Pokud aplikace vyžaduje podporu starší verze `IRouter`, zakažte `EnableEndpointRouting` pomocí kterékoli z následujících přístupů v `Startup.ConfigureServices`:

```csharp
services.AddMvc(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllers(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllersWithViews(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddRazorPages().AddMvcOptions(options => options.EnableEndpointRouting = false);
```

### <a name="health-checks"></a>Kontroly stavu

Kontroly stavu lze použít jako *směrovač* s směrováním koncových bodů.

Přidejte `MapHealthChecks` pro použití kontrol stavu pomocí směrování koncových bodů. Metoda `MapHealthChecks` přijímá argumenty podobné `UseHealthChecks`. Výhodou použití `MapHealthChecks` přes `UseHealthChecks` je schopnost použít autorizaci a mít větší jemně odstupňovanou kontrolu nad zásadami pro porovnání.

V následujícím příkladu je `MapHealthChecks` volána pro koncový bod kontroly stavu v `/healthz`:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHealthChecks("/healthz", new HealthCheckOptions() { });
    });
}
```

## <a name="hostbuilder-replaces-webhostbuilder"></a>HostBuilder nahrazuje WebHostBuilder

Šablony ASP.NET Core 3,0 používají [obecného hostitele](xref:fundamentals/host/generic-host). Předchozí verze používaly [webového hostitele](xref:fundamentals/host/web-host). Následující kód ukazuje `Program` třídu vygenerovanou šablonou ASP.NET Core 3,0:

[!code-csharp[](22-to-30/samples/Program.cs?name=snippet)]

Následující kód ukazuje ASP.NET Core `Program` třídy generované šablonou 2,2:

[!code-csharp[](22-to-30/samples/Program2.2.cs?name=snippet)]

<xref:Microsoft.AspNetCore.Hosting.IWebHostBuilder> zůstává v 3,0 a je typ `webBuilder` zobrazený v předchozí ukázce kódu. <xref:Microsoft.AspNetCore.Hosting.WebHostBuilder> budou v budoucí verzi zastaralá a nahrazena `HostBuilder`.

Nejvýznamnější změnou z `WebHostBuilder` na `HostBuilder` je v [vkládání závislostí (di)](xref:fundamentals/dependency-injection). Při použití `HostBuilder`můžete do konstruktoru `Startup`vložit pouze následující:

* <xref:Microsoft.Extensions.Configuration.IConfiguration>
* `Microsoft.Extensions.Hosting.IHostEnvironment`
* <xref:Microsoft.AspNetCore.Hosting.IWebHostEnvironment>

Omezení `HostBuilder` DI:

* Povolí sestavení kontejneru DI jenom jednou.
* Předejde výsledným problémům životního cyklu objektů, jako je například řešení více instancí singleton.

## <a name="addauthorization-moved-to-a-different-assembly"></a>AddAuthorization přesunuté do jiného sestavení

ASP.NET Core 2,2 a nižší `AddAuthorization` metody v souboru *Microsoft. AspNetCore. Authorization. dll*:

* Bylo přejmenováno `AddAuthorizationCore`.
* Byly přesunuty do souboru *Microsoft. AspNetCore. Authorization. Policy. dll*.

Aplikace používající *Microsoft. AspNetCore. Authorization. dll* a *Microsoft. AspNetCore. Authorization. Policy. dll* nejsou ovlivněny.

Aplikace, které nepoužívají *Microsoft. AspNetCore. Authorization. Policy. dll* , by měly provádět jednu z následujících akcí:

* Přidejte odkaz na *Microsoft. AspNetCore. Authorization. Policy. dll*. Tento přístup je vhodný pro většinu aplikací a je nutný.
* Přepnout na použití `AddAuthorizationCore`

Další informace naleznete v tématu [Průlomová změna v `AddAuthorization(o =>`) přetížení v jiném sestavení #386](https://github.com/aspnet/Announcements/issues/386).

## <a name="identity-ui"></a>Uživatelské rozhraní identity

Aktualizace uživatelského rozhraní identity pro ASP.NET Core 3,0:

* Přidejte odkaz na balíček do [Microsoft. AspNetCore. identity. UI](https://nuget.org/packages/Microsoft.AspNetCore.Identity.UI).
* Aplikace, které nepoužívají Razor Pages, musí volat `MapRazorPages`. Viz [Razor Pages](#razor-pages) v tomto dokumentu.
* Výchozí architektura uživatelského rozhraní je Bootstrap 4. Nastavte vlastnost projektu `IdentityUIFrameworkVersion`, aby se změnila výchozí hodnota. Další informace najdete v [tomto oznámení GitHubu](https://github.com/aspnet/Announcements/issues/380).

## SignalR

Klient SignalR JavaScript se změnil z `@aspnet/signalr` na `@microsoft/signalr`. Pro reakci na tuto změnu změňte odkazy v souborech *Package. JSON* , `require` příkazy a ECMAScript `import` příkazy.

### <a name="systemtextjson-is-the-default-protocol"></a>System. text. JSON je výchozí protokol.

`System.Text.Json` je teď výchozím protokolem rozbočovače používaným klientem i serverem.

V `Startup.ConfigureServices`volejte `AddJsonProtocol` a nastavte možnosti serializátoru.

**WebServer**

```csharp
services.AddSignalR(...)
        .AddJsonProtocol(options =>
        {
            options.PayloadSerializerOptions.WriteIndented = false;
        })
```

**Služba**

```csharp
new HubConnectionBuilder()
    .WithUrl("/chatHub")
    .AddJsonProtocol(options =>
    {
        options.PayloadSerializerOptions.WriteIndented = false;
    })
    .Build();
```

### <a name="switch-to-newtonsoftjson"></a>Přepnout na Newtonsoft. JSON

Pokud používáte funkce `Newtonsoft.Json`, které nejsou v `System.Text.Json`podporované, můžete přejít zpátky na `Newtonsoft.Json`:

1. Nainstalujte [Microsoft. AspNetCore.SignalR. Balíček NuGet Protocols. NewtonsoftJson](https://www.nuget.org/packages/Microsoft.AspNetCore.SignalR.Protocols.NewtonsoftJson)
1. V klientovi řetězit `AddNewtonsoftJsonProtocol` volání metody do instance `HubConnectionBuilder`:

    ```csharp
    new HubConnectionBuilder()
        .WithUrl("/chatHub")
        .AddNewtonsoftJsonProtocol(...)
        .Build();
    ```

1. Na serveru řetězit `AddNewtonsoftJsonProtocol` volání metody `AddSignalR` v `Startup.ConfigureServices`:

    ```csharp
    services.AddSignalR()
        .AddNewtonsoftJsonProtocol(...);
    ```

## <a name="opt-in-to-runtime-compilation"></a>Přihlásit se ke kompilaci za běhu

Před ASP.NET Core 3,0 byla kompilace zobrazení běhového prostředí implicitní funkcí rozhraní. Kompilace za běhu doplňuje kompilaci zobrazení v době sestavení. Umožňuje rozhraní kompilovat zobrazení a stránky Razor (soubory *. cshtml* ) při změně souborů, aniž by bylo nutné znovu sestavit celou aplikaci. Tato funkce podporuje scénář pro rychlé úpravy v integrovaném vývojovém prostředí (IDE) a aktualizaci prohlížeče pro zobrazení změn.

V ASP.NET Core 3,0 je kompilace modulu runtime v případě výslovného souhlasu. Kompilace při sestavení je jediným mechanismem pro zobrazení kompilace, která je ve výchozím nastavení povolená. Modul runtime spoléhá na aplikaci Visual Studio nebo [dotnet – Sledujte](xref:tutorials/dotnet-watch) v Visual Studio Code pro opětovné sestavení projektu, když detekuje změny souborů *. cshtml* . V aplikaci Visual Studio se změny v souborech *. cs*, *. cshtml*nebo *. Razor* v projektu spouštějí (<kbd>CTRL + F5</kbd>), ale ne laděné (<kbd>F5</kbd>), spusťte opětovnou kompilaci projektu.

Povolení kompilace za běhu v projektu ASP.NET Core 3,0:

1. Nainstalujte balíček NuGet [Microsoft. AspNetCore. Mvc. Razor. RuntimeCompilation](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation) .
1. Aktualizovat `Startup.ConfigureServices` pro volání `AddRazorRuntimeCompilation`:

    Pro ASP.NET Core MVC použijte následující kód:

    ```csharp
    services.AddControllersWithViews()
        .AddRazorRuntimeCompilation(...);
    ```
 
    Pro ASP.NET Core Razor Pages použijte následující kód:
 
    ```csharp
    services.AddRazorPages()
        .AddRazorRuntimeCompilation(...);
    ```
 
Ukázka v https://github.com/aspnet/samples/tree/master/samples/aspnetcore/mvc/runtimecompilation ukazuje příklad povolení běhové kompilace podmíněně ve vývojových prostředích.

Další informace o kompilaci souborů Razor naleznete v tématu <xref:mvc/views/view-compilation>.

## <a name="migrate-libraries-via-multi-targeting"></a>Migrace knihoven přes cílení na více platforem

Knihovny často potřebují podporovat více verzí ASP.NET Core. Většina knihoven kompilovaných pro předchozí verze ASP.NET Core by měla pokračovat bez problémů. Následující podmínky vyžadují křížové kompilování aplikace:

* Knihovna se spoléhá na funkci, která má binární zásadní [změnu](#breaking-api-changes).
* Knihovna chce využívat nové funkce v ASP.NET Core 3,0. 

Příklad:

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFrameworks>netcoreapp3.0;netstandard2.0</TargetFrameworks>
  </PropertyGroup>

  <ItemGroup Condition="'$(TargetFramework)' == 'netcoreapp3.0'">
    <FrameworkReference Include="Microsoft.AspNetCore.App" />
  </ItemGroup>

  <ItemGroup Condition="'$(TargetFramework)' == 'netstandard2.0'">
    <PackageReference Include="Microsoft.AspNetCore" Version="2.1.0" />
  </ItemGroup>
</Project>
```

Pomocí `#ifdefs` povolit rozhraní API pro ASP.NET Core 3,0:

```csharp
var webRootFileProvider =
#if NETCOREAPP3_0
    GetRequiredService<IWebHostEnvironment>().WebRootFileProvider;
#elif NETSTANDARD2_0
    GetRequiredService<IHostingEnvironment>().WebRootFileProvider;
#else
#error unknown target framework
#endif
```

### <a name="publish"></a>Opětovn

Odstraňte složky *bin* a *obj* v adresáři projektu.

## <a name="testserver"></a>TestServer

U aplikací, které používají <xref:Microsoft.AspNetCore.TestHost.TestServer> přímo u [obecného hostitele](xref:fundamentals/host/web-host), vytvořte `TestServer` na <xref:Microsoft.AspNetCore.Hosting.IWebHostBuilder> v <xref:Microsoft.Extensions.Hosting.GenericHostWebHostBuilderExtensions.ConfigureWebHost*>:

```csharp
[Fact]
public async Task GenericCreateAndStartHost_GetTestServer()
{
    using var host = await new HostBuilder()
        .ConfigureWebHost(webBuilder =>
        {
            webBuilder
                .UseTestServer()
                .Configure(app => { });
        })
    .StartAsync();

    var response = await host.GetTestServer().CreateClient().GetAsync("/");

    Assert.Equal(HttpStatusCode.NotFound, response.StatusCode);
}
```

<a name="break"></a>

## <a name="breaking-api-changes"></a>Přerušení změn rozhraní API

Kontrola nejnovějších změn:

* [Úplný seznam nejnovějších změn v ASP.NET Core vydání 3,0](https://github.com/aspnet/Announcements/issues?page=2&q=is%3Aissue+is%3Aopen+label%3A%22Breaking+change%22+label%3A3.0.0)
* [Rušení změn rozhraní API v antipadělání, CORS, diagnostice, MVC a směrování](https://github.com/aspnet/Announcements/issues/387). Tento seznam obsahuje zásadní změny pro přepínače kompatibility.
* Shrnutí 2,2-až 3,0 přerušující změny v rámci .NET Core, ASP.NET Core a Entity Framework Core najdete v tématu [přerušující změny migrace z verze 2,2 na 3,0](/dotnet/core/compatibility/2.2-3.0).
* [Některé výchozí hodnoty SameSite souborů cookie se změnily na žádný (ASPNET/oznámení #348)](https://github.com/aspnet/Announcements/issues/348).

## <a name="net-core-30-on-azure-app-service"></a>.NET Core 3,0 na Azure App Service

Další informace o tom, jak se při zavádění .NET Core Azure App Service, najdete na webu App Service na oficiálním [.NET Core](https://aspnetcoreon.azurewebsites.net/) . Dokud není na Azure App Service k dispozici .NET Core 3,0, postupujte podle pokynů v tématu [nasazení ASP.NET Core verze Preview do Azure App Service](xref:host-and-deploy/azure-apps/index#deploy-aspnet-core-preview-release-to-azure-app-service).
AddAuthorization přesunuté do jiného sestavení
