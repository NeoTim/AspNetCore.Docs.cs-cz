---
title: Mezipaměť v paměti v ASP.NET Core
author: rick-anderson
description: Naučte se, jak ukládat data do mezipaměti v ASP.NET Core.
ms.author: riande
ms.custom: mvc
ms.date: 02/02/2020
no-loc:
- cookie
- Cookie
- Blazor
- Blazor Server
- Blazor WebAssembly
- Identity
- Let's Encrypt
- Razor
- SignalR
uid: performance/caching/memory
ms.openlocfilehash: 131fd5f2d09b20814cbd557d6b6d873ce15501db
ms.sourcegitcommit: 497be502426e9d90bb7d0401b1b9f74b6a384682
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 08/08/2020
ms.locfileid: "88021221"
---
# <a name="cache-in-memory-in-aspnet-core"></a><span data-ttu-id="429a5-103">Mezipaměť v paměti v ASP.NET Core</span><span class="sxs-lookup"><span data-stu-id="429a5-103">Cache in-memory in ASP.NET Core</span></span>

::: moniker range=">= aspnetcore-3.0"

<span data-ttu-id="429a5-104">Autor – [Rick Anderson](https://twitter.com/RickAndMSFT), [Jan Luo](https://github.com/JunTaoLuo)a [Steve Smith](https://ardalis.com/)</span><span class="sxs-lookup"><span data-stu-id="429a5-104">By [Rick Anderson](https://twitter.com/RickAndMSFT), [John Luo](https://github.com/JunTaoLuo), and [Steve Smith](https://ardalis.com/)</span></span>

<span data-ttu-id="429a5-105">[Zobrazit nebo stáhnout ukázkový kód](https://github.com/dotnet/AspNetCore.Docs/tree/master/aspnetcore/performance/caching/memory/3.0sample) ([Jak stáhnout](xref:index#how-to-download-a-sample))</span><span class="sxs-lookup"><span data-stu-id="429a5-105">[View or download sample code](https://github.com/dotnet/AspNetCore.Docs/tree/master/aspnetcore/performance/caching/memory/3.0sample) ([how to download](xref:index#how-to-download-a-sample))</span></span>

## <a name="caching-basics"></a><span data-ttu-id="429a5-106">Základy ukládání do mezipaměti</span><span class="sxs-lookup"><span data-stu-id="429a5-106">Caching basics</span></span>

<span data-ttu-id="429a5-107">Ukládání do mezipaměti může významně zlepšit výkon a škálovatelnost aplikace tím, že zkracuje práci potřebnou k vygenerování obsahu.</span><span class="sxs-lookup"><span data-stu-id="429a5-107">Caching can significantly improve the performance and scalability of an app by reducing the work required to generate content.</span></span> <span data-ttu-id="429a5-108">Ukládání do mezipaměti funguje nejlépe s daty, která se mění zřídka **a** jsou nákladné pro generování.</span><span class="sxs-lookup"><span data-stu-id="429a5-108">Caching works best with data that changes infrequently **and** is expensive to generate.</span></span> <span data-ttu-id="429a5-109">Ukládání do mezipaměti vytváří kopii dat, která může být vrácena mnohem rychleji než ze zdroje.</span><span class="sxs-lookup"><span data-stu-id="429a5-109">Caching makes a copy of data that can be returned much faster than from the source.</span></span> <span data-ttu-id="429a5-110">Aplikace by měly být napsány a testovány, aby **nikdy nebyly** závislé na datech uložených v mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="429a5-110">Apps should be written and tested to **never** depend on cached data.</span></span>

<span data-ttu-id="429a5-111">ASP.NET Core podporuje několik různých mezipamětí.</span><span class="sxs-lookup"><span data-stu-id="429a5-111">ASP.NET Core supports several different caches.</span></span> <span data-ttu-id="429a5-112">Nejjednodušší mezipaměť je založena na [IMemoryCache](/dotnet/api/microsoft.extensions.caching.memory.imemorycache).</span><span class="sxs-lookup"><span data-stu-id="429a5-112">The simplest cache is based on the [IMemoryCache](/dotnet/api/microsoft.extensions.caching.memory.imemorycache).</span></span> <span data-ttu-id="429a5-113">`IMemoryCache`představuje mezipaměť uloženou v paměti webového serveru.</span><span class="sxs-lookup"><span data-stu-id="429a5-113">`IMemoryCache` represents a cache stored in the memory of the web server.</span></span> <span data-ttu-id="429a5-114">Aplikace spuštěné na serverové farmě (více serverů) by měly zajistit, aby relace byly při použití mezipaměti v paměti rychlé.</span><span class="sxs-lookup"><span data-stu-id="429a5-114">Apps running on a server farm (multiple servers) should ensure sessions are sticky when using the in-memory cache.</span></span> <span data-ttu-id="429a5-115">Relace typu Sticky se zajišťují, aby následné požadavky z klienta přešly na stejný server.</span><span class="sxs-lookup"><span data-stu-id="429a5-115">Sticky sessions ensure that subsequent requests from a client all go to the same server.</span></span> <span data-ttu-id="429a5-116">Například Azure Web Apps používá [Směrování žádostí o aplikace](https://www.iis.net/learn/extensions/planning-for-arr) (ARR) ke směrování všech dalších požadavků na stejný server.</span><span class="sxs-lookup"><span data-stu-id="429a5-116">For example, Azure Web apps use [Application Request Routing](https://www.iis.net/learn/extensions/planning-for-arr) (ARR) to route all subsequent requests to the same server.</span></span>

<span data-ttu-id="429a5-117">Nesticky relace ve webové farmě vyžadují [distribuovanou mezipaměť](distributed.md) , aby nedocházelo k problémům s konzistencí mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="429a5-117">Non-sticky sessions in a web farm require a [distributed cache](distributed.md) to avoid cache consistency problems.</span></span> <span data-ttu-id="429a5-118">Pro některé aplikace může distribuovaná mezipaměť podporovat větší škálování než mezipaměť v paměti.</span><span class="sxs-lookup"><span data-stu-id="429a5-118">For some apps, a distributed cache can support higher scale-out than an in-memory cache.</span></span> <span data-ttu-id="429a5-119">Použití distribuované mezipaměti přesměruje paměť mezipaměti do externího procesu.</span><span class="sxs-lookup"><span data-stu-id="429a5-119">Using a distributed cache offloads the cache memory to an external process.</span></span>

<span data-ttu-id="429a5-120">Mezipaměť v paměti může ukládat libovolný objekt.</span><span class="sxs-lookup"><span data-stu-id="429a5-120">The in-memory cache can store any object.</span></span> <span data-ttu-id="429a5-121">Rozhraní distribuované mezipaměti je omezené na `byte[]` .</span><span class="sxs-lookup"><span data-stu-id="429a5-121">The distributed cache interface is limited to `byte[]`.</span></span> <span data-ttu-id="429a5-122">Položky mezipaměti v paměti a distribuované mezipaměti ukládají jako páry klíč-hodnota.</span><span class="sxs-lookup"><span data-stu-id="429a5-122">The in-memory and distributed cache store cache items as key-value pairs.</span></span>

## <a name="systemruntimecachingmemorycache"></a><span data-ttu-id="429a5-123">System. Runtime. Caching/MemoryCache</span><span class="sxs-lookup"><span data-stu-id="429a5-123">System.Runtime.Caching/MemoryCache</span></span>

<span data-ttu-id="429a5-124"><xref:System.Runtime.Caching>/<xref:System.Runtime.Caching.MemoryCache>([Balíček NuGet](https://www.nuget.org/packages/System.Runtime.Caching/)) se dá použít s:</span><span class="sxs-lookup"><span data-stu-id="429a5-124"><xref:System.Runtime.Caching>/<xref:System.Runtime.Caching.MemoryCache> ([NuGet package](https://www.nuget.org/packages/System.Runtime.Caching/)) can be used with:</span></span>

* <span data-ttu-id="429a5-125">.NET Standard 2,0 nebo novější.</span><span class="sxs-lookup"><span data-stu-id="429a5-125">.NET Standard 2.0 or later.</span></span>
* <span data-ttu-id="429a5-126">Jakákoli [implementace .NET](/dotnet/standard/net-standard#net-implementation-support) , která cílí na .NET Standard 2,0 nebo novější.</span><span class="sxs-lookup"><span data-stu-id="429a5-126">Any [.NET implementation](/dotnet/standard/net-standard#net-implementation-support) that targets .NET Standard 2.0 or later.</span></span> <span data-ttu-id="429a5-127">Například ASP.NET Core 2,0 nebo novější.</span><span class="sxs-lookup"><span data-stu-id="429a5-127">For example, ASP.NET Core 2.0 or later.</span></span>
* <span data-ttu-id="429a5-128">.NET Framework 4,5 nebo novější.</span><span class="sxs-lookup"><span data-stu-id="429a5-128">.NET Framework 4.5 or later.</span></span>

<span data-ttu-id="429a5-129">[Microsoft. Extensions. Caching. Memory](https://www.nuget.org/packages/Microsoft.Extensions.Caching.Memory/) / `IMemoryCache` (popsaná v tomto článku) se doporučuje, `System.Runtime.Caching` / `MemoryCache` protože je lépe integrovaná do ASP.NET Core.</span><span class="sxs-lookup"><span data-stu-id="429a5-129">[Microsoft.Extensions.Caching.Memory](https://www.nuget.org/packages/Microsoft.Extensions.Caching.Memory/)/`IMemoryCache` (described in this article) is recommended over `System.Runtime.Caching`/`MemoryCache` because it's better integrated into ASP.NET Core.</span></span> <span data-ttu-id="429a5-130">Například `IMemoryCache` funguje nativně s [vkládáním závislostí](xref:fundamentals/dependency-injection)ASP.NET Core.</span><span class="sxs-lookup"><span data-stu-id="429a5-130">For example, `IMemoryCache` works natively with ASP.NET Core [dependency injection](xref:fundamentals/dependency-injection).</span></span>

<span data-ttu-id="429a5-131">Použijte `System.Runtime.Caching` / `MemoryCache` jako most kompatibility při přenosu kódu z ASP.NET 4. x do ASP.NET Core.</span><span class="sxs-lookup"><span data-stu-id="429a5-131">Use `System.Runtime.Caching`/`MemoryCache` as a compatibility bridge when porting code from ASP.NET 4.x to ASP.NET Core.</span></span>

## <a name="cache-guidelines"></a><span data-ttu-id="429a5-132">Pokyny pro mezipaměť</span><span class="sxs-lookup"><span data-stu-id="429a5-132">Cache guidelines</span></span>

* <span data-ttu-id="429a5-133">Kód by měl vždy mít možnost Fallback načíst data a **nemusí** být závislý na dostupné hodnotě uložené v mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="429a5-133">Code should always have a fallback option to fetch data and **not** depend on a cached value being available.</span></span>
* <span data-ttu-id="429a5-134">Mezipaměť používá prostředek omezených, paměť.</span><span class="sxs-lookup"><span data-stu-id="429a5-134">The cache uses a scarce resource, memory.</span></span> <span data-ttu-id="429a5-135">Omezit nárůst mezipaměti:</span><span class="sxs-lookup"><span data-stu-id="429a5-135">Limit cache growth:</span></span>
  * <span data-ttu-id="429a5-136">Nepoužívejte **externí** vstup jako klíče mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="429a5-136">Do **not** use external input as cache keys.</span></span>
  * <span data-ttu-id="429a5-137">K omezení růstu mezipaměti použijte vypršení platnosti.</span><span class="sxs-lookup"><span data-stu-id="429a5-137">Use expirations to limit cache growth.</span></span>
  * <span data-ttu-id="429a5-138">[Pro omezení velikosti mezipaměti použijte možnost setSize, Size a SizeLimit](#use-setsize-size-and-sizelimit-to-limit-cache-size).</span><span class="sxs-lookup"><span data-stu-id="429a5-138">[Use SetSize, Size, and SizeLimit to limit cache size](#use-setsize-size-and-sizelimit-to-limit-cache-size).</span></span> <span data-ttu-id="429a5-139">Modul runtime ASP.NET Core **neomezuje velikost** mezipaměti na základě tlaku paměti.</span><span class="sxs-lookup"><span data-stu-id="429a5-139">The ASP.NET Core runtime does **not** limit cache size based on memory pressure.</span></span> <span data-ttu-id="429a5-140">Velikost mezipaměti můžete omezit na vývojáře.</span><span class="sxs-lookup"><span data-stu-id="429a5-140">It's up to the developer to limit cache size.</span></span>

## <a name="use-imemorycache"></a><span data-ttu-id="429a5-141">Použití IMemoryCache</span><span class="sxs-lookup"><span data-stu-id="429a5-141">Use IMemoryCache</span></span>

> [!WARNING]
> <span data-ttu-id="429a5-142">Použití *sdílené* mezipaměti paměti ze [Injektáže](xref:fundamentals/dependency-injection) a volání závislosti `SetSize` , `Size` nebo `SizeLimit` pro omezení velikosti mezipaměti může způsobit selhání aplikace.</span><span class="sxs-lookup"><span data-stu-id="429a5-142">Using a *shared* memory cache from [Dependency Injection](xref:fundamentals/dependency-injection) and calling `SetSize`, `Size`, or `SizeLimit` to limit cache size can cause the app to fail.</span></span> <span data-ttu-id="429a5-143">Pokud je u mezipaměti nastaveno omezení velikosti, všechny položky musí při přidávání určovat velikost.</span><span class="sxs-lookup"><span data-stu-id="429a5-143">When a size limit is set on a cache, all entries must specify a size when being added.</span></span> <span data-ttu-id="429a5-144">To může vést k problémům, protože vývojáři nemusí mít úplnou kontrolu nad tím, co používá sdílenou mezipaměť.</span><span class="sxs-lookup"><span data-stu-id="429a5-144">This can lead to issues since developers may not have full control on what uses the shared cache.</span></span> <span data-ttu-id="429a5-145">Entity Framework Core například používá sdílenou mezipaměť a neurčuje velikost.</span><span class="sxs-lookup"><span data-stu-id="429a5-145">For example, Entity Framework Core uses the shared cache and does not specify a size.</span></span> <span data-ttu-id="429a5-146">Pokud aplikace nastaví omezení velikosti mezipaměti a používá EF Core, aplikace vyvolá `InvalidOperationException` .</span><span class="sxs-lookup"><span data-stu-id="429a5-146">If an app sets a cache size limit and uses EF Core, the app throws an `InvalidOperationException`.</span></span>
> <span data-ttu-id="429a5-147">Při použití `SetSize` , `Size` nebo `SizeLimit` k omezení mezipaměti vytvořte pro ukládání do mezipaměti typ singleton.</span><span class="sxs-lookup"><span data-stu-id="429a5-147">When using `SetSize`, `Size`, or `SizeLimit` to limit cache, create a cache singleton for caching.</span></span> <span data-ttu-id="429a5-148">Další informace a příklad najdete v tématu [použití setSize, Size a SizeLimit k omezení velikosti mezipaměti](#use-setsize-size-and-sizelimit-to-limit-cache-size).</span><span class="sxs-lookup"><span data-stu-id="429a5-148">For more information and an example, see [Use SetSize, Size, and SizeLimit to limit cache size](#use-setsize-size-and-sizelimit-to-limit-cache-size).</span></span>
> <span data-ttu-id="429a5-149">Sdílená mezipaměť je jedna sdílená jinými architekturami nebo knihovnami.</span><span class="sxs-lookup"><span data-stu-id="429a5-149">A shared cache is one shared by other frameworks or libraries.</span></span> <span data-ttu-id="429a5-150">EF Core například používá sdílenou mezipaměť a neurčuje velikost.</span><span class="sxs-lookup"><span data-stu-id="429a5-150">For example, EF Core uses the shared cache and does not specify a size.</span></span> 

<span data-ttu-id="429a5-151">Mezipaměť v paměti je *Služba* , na kterou se odkazuje z aplikace pomocí [Injektáže závislostí](xref:fundamentals/dependency-injection).</span><span class="sxs-lookup"><span data-stu-id="429a5-151">In-memory caching is a *service* that's referenced from an app using [Dependency Injection](xref:fundamentals/dependency-injection).</span></span> <span data-ttu-id="429a5-152">Vyžádejte `IMemoryCache` instanci v konstruktoru:</span><span class="sxs-lookup"><span data-stu-id="429a5-152">Request the `IMemoryCache` instance in the constructor:</span></span>

[!code-csharp[](memory/3.0sample/WebCacheSample/Controllers/HomeController.cs?name=snippet_ctor)]

<span data-ttu-id="429a5-153">Následující kód používá [TryGetValue](/dotnet/api/microsoft.extensions.caching.memory.imemorycache.trygetvalue?view=aspnetcore-2.0#Microsoft_Extensions_Caching_Memory_IMemoryCache_TryGetValue_System_Object_System_Object__) ke kontrole, zda je čas v mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="429a5-153">The following code uses [TryGetValue](/dotnet/api/microsoft.extensions.caching.memory.imemorycache.trygetvalue?view=aspnetcore-2.0#Microsoft_Extensions_Caching_Memory_IMemoryCache_TryGetValue_System_Object_System_Object__) to check if a time is in the cache.</span></span> <span data-ttu-id="429a5-154">Pokud čas není uložen v mezipaměti, je vytvořena nová položka a přidána do mezipaměti se [sadou](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.set?view=aspnetcore-2.0#Microsoft_Extensions_Caching_Memory_CacheExtensions_Set__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object___0_Microsoft_Extensions_Caching_Memory_MemoryCacheEntryOptions_).</span><span class="sxs-lookup"><span data-stu-id="429a5-154">If a time isn't cached, a new entry is created and added to the cache with [Set](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.set?view=aspnetcore-2.0#Microsoft_Extensions_Caching_Memory_CacheExtensions_Set__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object___0_Microsoft_Extensions_Caching_Memory_MemoryCacheEntryOptions_).</span></span> <span data-ttu-id="429a5-155">`CacheKeys`Třída je součástí ukázky stahování.</span><span class="sxs-lookup"><span data-stu-id="429a5-155">The `CacheKeys` class is part of the download sample.</span></span>

[!code-csharp[](memory/3.0sample/WebCacheSample/CacheKeys.cs)]

[!code-csharp[](memory/3.0sample/WebCacheSample/Controllers/HomeController.cs?name=snippet1)]

<span data-ttu-id="429a5-156">Aktuální čas a čas v mezipaměti se zobrazí:</span><span class="sxs-lookup"><span data-stu-id="429a5-156">The current time and the cached time are displayed:</span></span>

[!code-cshtml[](memory/3.0sample/WebCacheSample/Views/Home/Cache.cshtml)]

<span data-ttu-id="429a5-157">Hodnota uložená v mezipaměti `DateTime` zůstává v mezipaměti a v době, kdy jsou požadavky v rámci časového limitu.</span><span class="sxs-lookup"><span data-stu-id="429a5-157">The cached `DateTime` value remains in the cache while there are requests within the timeout period.</span></span>

<span data-ttu-id="429a5-158">Následující kód používá [GetOrCreate](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.getorcreate#Microsoft_Extensions_Caching_Memory_CacheExtensions_GetOrCreate__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_System_Func_Microsoft_Extensions_Caching_Memory_ICacheEntry___0__) a [GetOrCreateAsync](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.getorcreateasync#Microsoft_Extensions_Caching_Memory_CacheExtensions_GetOrCreateAsync__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_System_Func_Microsoft_Extensions_Caching_Memory_ICacheEntry_System_Threading_Tasks_Task___0___) k ukládání dat do mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="429a5-158">The following code uses [GetOrCreate](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.getorcreate#Microsoft_Extensions_Caching_Memory_CacheExtensions_GetOrCreate__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_System_Func_Microsoft_Extensions_Caching_Memory_ICacheEntry___0__) and [GetOrCreateAsync](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.getorcreateasync#Microsoft_Extensions_Caching_Memory_CacheExtensions_GetOrCreateAsync__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_System_Func_Microsoft_Extensions_Caching_Memory_ICacheEntry_System_Threading_Tasks_Task___0___) to cache data.</span></span>

[!code-csharp[](memory/3.0sample/WebCacheSample/Controllers/HomeController.cs?name=snippet2&highlight=3-7,14-19)]

<span data-ttu-id="429a5-159">Následující kód volá [Get](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.get#Microsoft_Extensions_Caching_Memory_CacheExtensions_Get__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_) k načtení času uloženého v mezipaměti:</span><span class="sxs-lookup"><span data-stu-id="429a5-159">The following code calls [Get](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.get#Microsoft_Extensions_Caching_Memory_CacheExtensions_Get__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_) to fetch the cached time:</span></span>

[!code-csharp[](memory/3.0sample/WebCacheSample/Controllers/HomeController.cs?name=snippet_gct)]

<span data-ttu-id="429a5-160">Následující kód Získá nebo vytvoří položku uloženou v mezipaměti s absolutním vypršením platnosti:</span><span class="sxs-lookup"><span data-stu-id="429a5-160">The following code gets or creates a cached item with absolute expiration:</span></span>

[!code-csharp[](memory/3.0sample/WebCacheSample/Controllers/HomeController.cs?name=snippet99)]

<span data-ttu-id="429a5-161">Sada položek v mezipaměti s klouzavé vypršení platnosti je ohrožena pouze v případě, že je zastaralá.</span><span class="sxs-lookup"><span data-stu-id="429a5-161">A cached item set with a sliding expiration only is at risk of becoming stale.</span></span> <span data-ttu-id="429a5-162">Pokud se k němu dostanete častěji než klouzavé období vypršení platnosti, tato položka nikdy nevyprší.</span><span class="sxs-lookup"><span data-stu-id="429a5-162">If it's accessed more frequently than the sliding expiration interval, the item will never expire.</span></span> <span data-ttu-id="429a5-163">Zkombinujte klouzavé vypršení platnosti s absolutním vypršením platnosti a zajistěte tak, že platnost položky vyprší po uplynutí absolutního času vypršení.</span><span class="sxs-lookup"><span data-stu-id="429a5-163">Combine a sliding expiration with an absolute expiration to guarantee that the item expires once its absolute expiration time passes.</span></span> <span data-ttu-id="429a5-164">Absolutní vypršení platnosti nastaví horní mez na dobu, po kterou může být položka ukládána do mezipaměti, a stále umožňuje, aby položka vypršela dříve, pokud se nepožaduje v klouzavém intervalu vypršení platnosti.</span><span class="sxs-lookup"><span data-stu-id="429a5-164">The absolute expiration sets an upper bound to how long the item can be cached while still allowing the item to expire earlier if it isn't requested within the sliding expiration interval.</span></span> <span data-ttu-id="429a5-165">Při zadání absolutního i klouzavého vypršení platnosti jsou vypršení platnosti logicky ORed.</span><span class="sxs-lookup"><span data-stu-id="429a5-165">When both absolute and sliding expiration are specified, the expirations are logically ORed.</span></span> <span data-ttu-id="429a5-166">Pokud je interval klouzavého vypršení platnosti *nebo* absolutního času vypršení platnosti, položka bude z mezipaměti vyřazena.</span><span class="sxs-lookup"><span data-stu-id="429a5-166">If either the sliding expiration interval *or* the absolute expiration time pass, the item is evicted from the cache.</span></span>

<span data-ttu-id="429a5-167">Následující kód Získá nebo vytvoří položku uloženou v mezipaměti s použitím klouzavého *i* absolutního vypršení platnosti:</span><span class="sxs-lookup"><span data-stu-id="429a5-167">The following code gets or creates a cached item with both sliding *and* absolute expiration:</span></span>

[!code-csharp[](memory/3.0sample/WebCacheSample/Controllers/HomeController.cs?name=snippet9)]

<span data-ttu-id="429a5-168">Předchozí kód zaručuje, že data nebudou ukládána do mezipaměti déle než absolutní čas.</span><span class="sxs-lookup"><span data-stu-id="429a5-168">The preceding code guarantees the data will not be cached longer than the absolute time.</span></span>

<span data-ttu-id="429a5-169"><xref:Microsoft.Extensions.Caching.Memory.CacheExtensions.GetOrCreate*>, <xref:Microsoft.Extensions.Caching.Memory.CacheExtensions.GetOrCreateAsync*> a <xref:Microsoft.Extensions.Caching.Memory.CacheExtensions.Get*> jsou rozšiřující metody <xref:Microsoft.Extensions.Caching.Memory.CacheExtensions> třídy.</span><span class="sxs-lookup"><span data-stu-id="429a5-169"><xref:Microsoft.Extensions.Caching.Memory.CacheExtensions.GetOrCreate*>, <xref:Microsoft.Extensions.Caching.Memory.CacheExtensions.GetOrCreateAsync*>, and <xref:Microsoft.Extensions.Caching.Memory.CacheExtensions.Get*> are extension methods in the <xref:Microsoft.Extensions.Caching.Memory.CacheExtensions> class.</span></span> <span data-ttu-id="429a5-170">Tyto metody rozšiřuje schopnost <xref:Microsoft.Extensions.Caching.Memory.IMemoryCache> .</span><span class="sxs-lookup"><span data-stu-id="429a5-170">These methods extend the capability of <xref:Microsoft.Extensions.Caching.Memory.IMemoryCache>.</span></span>

## <a name="memorycacheentryoptions"></a><span data-ttu-id="429a5-171">MemoryCacheEntryOptions</span><span class="sxs-lookup"><span data-stu-id="429a5-171">MemoryCacheEntryOptions</span></span>

<span data-ttu-id="429a5-172">Následující ukázka:</span><span class="sxs-lookup"><span data-stu-id="429a5-172">The following sample:</span></span>

* <span data-ttu-id="429a5-173">Nastaví posuvný čas vypršení platnosti.</span><span class="sxs-lookup"><span data-stu-id="429a5-173">Sets a sliding expiration time.</span></span> <span data-ttu-id="429a5-174">Požadavky, které přistupují k této položce v mezipaměti, budou resetovat hodiny klouzavého vypršení platnosti.</span><span class="sxs-lookup"><span data-stu-id="429a5-174">Requests that access this cached item will reset the sliding expiration clock.</span></span>
* <span data-ttu-id="429a5-175">Nastaví prioritu mezipaměti na [CacheItemPriority. NeverRemove](xref:Microsoft.Extensions.Caching.Memory.CacheItemPriority.NeverRemove).</span><span class="sxs-lookup"><span data-stu-id="429a5-175">Sets the cache priority to [CacheItemPriority.NeverRemove](xref:Microsoft.Extensions.Caching.Memory.CacheItemPriority.NeverRemove).</span></span>
* <span data-ttu-id="429a5-176">Nastaví [PostEvictionDelegate](/dotnet/api/microsoft.extensions.caching.memory.postevictiondelegate) , který bude volán po vyřazení položky z mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="429a5-176">Sets a [PostEvictionDelegate](/dotnet/api/microsoft.extensions.caching.memory.postevictiondelegate) that will be called after the entry is evicted from the cache.</span></span> <span data-ttu-id="429a5-177">Zpětné volání je spuštěno v jiném vlákně z kódu, který odebere položku z mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="429a5-177">The callback is run on a different thread from the code that removes the item from the cache.</span></span>

[!code-csharp[](memory/3.0sample/WebCacheSample/Controllers/HomeController.cs?name=snippet_et&highlight=14-21)]

## <a name="use-setsize-size-and-sizelimit-to-limit-cache-size"></a><span data-ttu-id="429a5-178">Omezení velikosti mezipaměti pomocí SetSize, velikosti a SizeLimit</span><span class="sxs-lookup"><span data-stu-id="429a5-178">Use SetSize, Size, and SizeLimit to limit cache size</span></span>

<span data-ttu-id="429a5-179">`MemoryCache`Instance může volitelně určovat a vymáhat omezení velikosti.</span><span class="sxs-lookup"><span data-stu-id="429a5-179">A `MemoryCache` instance may optionally specify and enforce a size limit.</span></span> <span data-ttu-id="429a5-180">Omezení velikosti mezipaměti nemá definovanou měrnou jednotku, protože mezipaměť nemá žádný mechanismus pro měření velikosti položek.</span><span class="sxs-lookup"><span data-stu-id="429a5-180">The cache size limit does not have a defined unit of measure because the cache has no mechanism to measure the size of entries.</span></span> <span data-ttu-id="429a5-181">Pokud je nastaven limit velikosti mezipaměti, musí všechny položky určovat velikost.</span><span class="sxs-lookup"><span data-stu-id="429a5-181">If the cache size limit is set, all entries must specify size.</span></span> <span data-ttu-id="429a5-182">Modul runtime ASP.NET Core neomezuje velikost mezipaměti na základě tlaku paměti.</span><span class="sxs-lookup"><span data-stu-id="429a5-182">The ASP.NET Core runtime does not limit cache size based on memory pressure.</span></span> <span data-ttu-id="429a5-183">Velikost mezipaměti můžete omezit na vývojáře.</span><span class="sxs-lookup"><span data-stu-id="429a5-183">It's up to the developer to limit cache size.</span></span> <span data-ttu-id="429a5-184">Zadaná velikost je v jednotkách, které vývojář zvolí.</span><span class="sxs-lookup"><span data-stu-id="429a5-184">The size specified is in units the developer chooses.</span></span>

<span data-ttu-id="429a5-185">Například:</span><span class="sxs-lookup"><span data-stu-id="429a5-185">For example:</span></span>

* <span data-ttu-id="429a5-186">Pokud byla webová aplikace primárně do mezipaměti řetězců, každá velikost položky mezipaměti může být délka řetězce.</span><span class="sxs-lookup"><span data-stu-id="429a5-186">If the web app was primarily caching strings, each cache entry size could be the string length.</span></span>
* <span data-ttu-id="429a5-187">Aplikace může určit velikost všech položek jako 1 a limit velikosti je počet položek.</span><span class="sxs-lookup"><span data-stu-id="429a5-187">The app could specify the size of all entries as 1, and the size limit is the count of entries.</span></span>

<span data-ttu-id="429a5-188">Pokud <xref:Microsoft.Extensions.Caching.Memory.MemoryCacheOptions.SizeLimit> není nastaveno, mezipaměť se rozrůstá bez vazby.</span><span class="sxs-lookup"><span data-stu-id="429a5-188">If <xref:Microsoft.Extensions.Caching.Memory.MemoryCacheOptions.SizeLimit> isn't set, the cache grows without bound.</span></span> <span data-ttu-id="429a5-189">Modul runtime ASP.NET Core neořízne mezipaměť, pokud je systémová paměť nízká.</span><span class="sxs-lookup"><span data-stu-id="429a5-189">The ASP.NET Core runtime doesn't trim the cache when system memory is low.</span></span> <span data-ttu-id="429a5-190">Aplikace musí být navrženy tak, aby:</span><span class="sxs-lookup"><span data-stu-id="429a5-190">Apps must be architected to:</span></span>

* <span data-ttu-id="429a5-191">Omezte nárůst mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="429a5-191">Limit cache growth.</span></span>
* <span data-ttu-id="429a5-192">Zavolejte <xref:Microsoft.Extensions.Caching.Memory.MemoryCache.Compact*> nebo <xref:Microsoft.Extensions.Caching.Memory.MemoryCache.Remove*> když je dostupná paměť omezená:</span><span class="sxs-lookup"><span data-stu-id="429a5-192">Call <xref:Microsoft.Extensions.Caching.Memory.MemoryCache.Compact*> or <xref:Microsoft.Extensions.Caching.Memory.MemoryCache.Remove*> when available memory is limited:</span></span>

<span data-ttu-id="429a5-193">Následující kód vytvoří pevnou velikost jednotky <xref:Microsoft.Extensions.Caching.Memory.MemoryCache> dostupnou pro [vkládání závislostí](xref:fundamentals/dependency-injection).</span><span class="sxs-lookup"><span data-stu-id="429a5-193">The following code creates a unitless fixed size <xref:Microsoft.Extensions.Caching.Memory.MemoryCache> accessible by [dependency injection](xref:fundamentals/dependency-injection):</span></span>

[!code-csharp[](memory/sample/RPcache/Services/MyMemoryCache.cs?name=snippet)]

<span data-ttu-id="429a5-194">`SizeLimit`nemá jednotky.</span><span class="sxs-lookup"><span data-stu-id="429a5-194">`SizeLimit` does not have units.</span></span> <span data-ttu-id="429a5-195">Položky v mezipaměti musí určovat velikost v jakémkoli z jednotek, které považují za nejvhodnější, pokud byl nastaven limit velikosti mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="429a5-195">Cached entries must specify size in whatever units they deem most appropriate if the cache size limit has been set.</span></span> <span data-ttu-id="429a5-196">Všichni uživatelé instance mezipaměti by měli používat stejný systém jednotek.</span><span class="sxs-lookup"><span data-stu-id="429a5-196">All users of a cache instance should use the same unit system.</span></span> <span data-ttu-id="429a5-197">Záznam nebude uložen do mezipaměti, pokud součet velikostí záznamů uložených v mezipaměti překročí hodnotu zadanou parametrem `SizeLimit` .</span><span class="sxs-lookup"><span data-stu-id="429a5-197">An entry will not be cached if the sum of the cached entry sizes exceeds the value specified by `SizeLimit`.</span></span> <span data-ttu-id="429a5-198">Pokud není nastavené žádné omezení velikosti mezipaměti, bude velikost mezipaměti nastavená u položky ignorována.</span><span class="sxs-lookup"><span data-stu-id="429a5-198">If no cache size limit is set, the cache size set on the entry will be ignored.</span></span>

<span data-ttu-id="429a5-199">Následující kód se registruje v `MyMemoryCache` kontejneru [Injektáže pro vkládání závislostí](xref:fundamentals/dependency-injection) .</span><span class="sxs-lookup"><span data-stu-id="429a5-199">The following code registers `MyMemoryCache` with the [dependency injection](xref:fundamentals/dependency-injection) container.</span></span>

[!code-csharp[](memory/3.0sample/RPcache/Startup.cs?name=snippet)]

<span data-ttu-id="429a5-200">`MyMemoryCache`je vytvořen jako nezávislá mezipaměť paměti pro součásti, které mají informace o této velikosti omezené mezipaměti a také o tom, jak správně nastavit velikost položky mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="429a5-200">`MyMemoryCache` is created as an independent memory cache for components that are aware of this size limited cache and know how to set cache entry size appropriately.</span></span>

<span data-ttu-id="429a5-201">Následující kód používá `MyMemoryCache` :</span><span class="sxs-lookup"><span data-stu-id="429a5-201">The following code uses `MyMemoryCache`:</span></span>

[!code-csharp[](memory/3.0sample/RPcache/Pages/SetSize.cshtml.cs?name=snippet)]

<span data-ttu-id="429a5-202">Velikost položky mezipaměti lze nastavit pomocí <xref:Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions.Size> <xref:Microsoft.Extensions.Caching.Memory.MemoryCacheEntryExtensions.SetSize*> metod rozšíření:</span><span class="sxs-lookup"><span data-stu-id="429a5-202">The size of the cache entry can be set by <xref:Microsoft.Extensions.Caching.Memory.MemoryCacheEntryOptions.Size> or the <xref:Microsoft.Extensions.Caching.Memory.MemoryCacheEntryExtensions.SetSize*> extension methods:</span></span>

[!code-csharp[](memory/3.0sample/RPcache/Pages/SetSize.cshtml.cs?name=snippet2&highlight=9,10,14,15)]

### <a name="memorycachecompact"></a><span data-ttu-id="429a5-203">MemoryCache. Compact</span><span class="sxs-lookup"><span data-stu-id="429a5-203">MemoryCache.Compact</span></span>

<span data-ttu-id="429a5-204">`MemoryCache.Compact`pokusí se odebrat zadané procento mezipaměti v následujícím pořadí:</span><span class="sxs-lookup"><span data-stu-id="429a5-204">`MemoryCache.Compact` attempts to remove the specified percentage of the cache in the following order:</span></span>

* <span data-ttu-id="429a5-205">Všechny položky, jejichž platnost vypršela.</span><span class="sxs-lookup"><span data-stu-id="429a5-205">All expired items.</span></span>
* <span data-ttu-id="429a5-206">Položky podle priority.</span><span class="sxs-lookup"><span data-stu-id="429a5-206">Items by priority.</span></span> <span data-ttu-id="429a5-207">Nejprve se odeberou položky s nejnižší prioritou.</span><span class="sxs-lookup"><span data-stu-id="429a5-207">Lowest priority items are removed first.</span></span>
* <span data-ttu-id="429a5-208">Nejméně naposledy použité objekty.</span><span class="sxs-lookup"><span data-stu-id="429a5-208">Least recently used objects.</span></span>
* <span data-ttu-id="429a5-209">Položky s nejdřívějším absolutním vypršením platnosti.</span><span class="sxs-lookup"><span data-stu-id="429a5-209">Items with the earliest absolute expiration.</span></span>
* <span data-ttu-id="429a5-210">Položky s nejdřívějším klouzavém vypršením platnosti.</span><span class="sxs-lookup"><span data-stu-id="429a5-210">Items with the earliest sliding expiration.</span></span>

<span data-ttu-id="429a5-211">Připnuté položky s prioritou <xref:Microsoft.Extensions.Caching.Memory.CacheItemPriority.NeverRemove> nejsou nikdy odebrány.</span><span class="sxs-lookup"><span data-stu-id="429a5-211">Pinned items with priority <xref:Microsoft.Extensions.Caching.Memory.CacheItemPriority.NeverRemove> are never removed.</span></span> <span data-ttu-id="429a5-212">Následující kód odstraní položku mezipaměti a volání `Compact` :</span><span class="sxs-lookup"><span data-stu-id="429a5-212">The following code removes a cache item and calls `Compact`:</span></span>

[!code-csharp[](memory/3.0sample/RPcache/Pages/TestCache.cshtml.cs?name=snippet3)]

<span data-ttu-id="429a5-213">Další informace najdete v tématu [Compact source na GitHubu](https://github.com/dotnet/extensions/blob/v3.0.0-preview8.19405.4/src/Caching/Memory/src/MemoryCache.cs#L382-L393) .</span><span class="sxs-lookup"><span data-stu-id="429a5-213">See [Compact source on GitHub](https://github.com/dotnet/extensions/blob/v3.0.0-preview8.19405.4/src/Caching/Memory/src/MemoryCache.cs#L382-L393) for more information.</span></span>

## <a name="cache-dependencies"></a><span data-ttu-id="429a5-214">Závislosti mezipaměti</span><span class="sxs-lookup"><span data-stu-id="429a5-214">Cache dependencies</span></span>

<span data-ttu-id="429a5-215">Následující příklad ukazuje, jak vyprší platnost položky mezipaměti, pokud vyprší platnost závislé položky.</span><span class="sxs-lookup"><span data-stu-id="429a5-215">The following sample shows how to expire a cache entry if a dependent entry expires.</span></span> <span data-ttu-id="429a5-216"><xref:Microsoft.Extensions.Primitives.CancellationChangeToken>Přidá se k položce v mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="429a5-216">A <xref:Microsoft.Extensions.Primitives.CancellationChangeToken> is added to the cached item.</span></span> <span data-ttu-id="429a5-217">Když `Cancel` je volána na `CancellationTokenSource` , obě položky mezipaměti jsou vyřazeny.</span><span class="sxs-lookup"><span data-stu-id="429a5-217">When `Cancel` is called on the `CancellationTokenSource`, both cache entries are evicted.</span></span>

[!code-csharp[](memory/3.0sample/WebCacheSample/Controllers/HomeController.cs?name=snippet_ed)]

<span data-ttu-id="429a5-218">Použití <xref:System.Threading.CancellationTokenSource> Možnosti umožňuje vyřazení více položek mezipaměti jako skupiny.</span><span class="sxs-lookup"><span data-stu-id="429a5-218">Using a <xref:System.Threading.CancellationTokenSource> allows multiple cache entries to be evicted as a group.</span></span> <span data-ttu-id="429a5-219">Pomocí `using` vzoru ve výše uvedeném kódu budou položky mezipaměti vytvořené uvnitř `using` bloku dědit triggery a nastavení vypršení platnosti.</span><span class="sxs-lookup"><span data-stu-id="429a5-219">With the `using` pattern in the code above, cache entries created inside the `using` block will inherit triggers and expiration settings.</span></span>

## <a name="additional-notes"></a><span data-ttu-id="429a5-220">Další poznámky</span><span class="sxs-lookup"><span data-stu-id="429a5-220">Additional notes</span></span>

* <span data-ttu-id="429a5-221">K vypršení platnosti nedojde na pozadí.</span><span class="sxs-lookup"><span data-stu-id="429a5-221">Expiration doesn't happen in the background.</span></span> <span data-ttu-id="429a5-222">Neexistuje žádný časovač, který aktivně hledá neplatné položky v mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="429a5-222">There is no timer that actively scans the cache for expired items.</span></span> <span data-ttu-id="429a5-223">Jakákoli aktivita v mezipaměti ( `Get` , `Set` , `Remove` ) může aktivovat kontrolu na pozadí pro položky s vypršenou platností.</span><span class="sxs-lookup"><span data-stu-id="429a5-223">Any activity on the cache (`Get`, `Set`, `Remove`) can trigger a background scan for expired items.</span></span> <span data-ttu-id="429a5-224">Časovač na `CancellationTokenSource` ( <xref:System.Threading.CancellationTokenSource.CancelAfter*> ) také odebere položku a aktivuje kontrolu pro položky, jejichž platnost vypršela.</span><span class="sxs-lookup"><span data-stu-id="429a5-224">A timer on the `CancellationTokenSource` (<xref:System.Threading.CancellationTokenSource.CancelAfter*>) also removes the entry and trigger a scan for expired items.</span></span> <span data-ttu-id="429a5-225">Následující příklad používá [CancellationTokenSource (TimeSpan)](/dotnet/api/system.threading.cancellationtokensource.-ctor) pro registrovaný token.</span><span class="sxs-lookup"><span data-stu-id="429a5-225">The following example uses [CancellationTokenSource(TimeSpan)](/dotnet/api/system.threading.cancellationtokensource.-ctor) for the registered token.</span></span> <span data-ttu-id="429a5-226">Když se tento token aktivuje, okamžitě odstraní položku a aktivuje zpětná volání vyřazení:</span><span class="sxs-lookup"><span data-stu-id="429a5-226">When this token fires it removes the entry immediately and fires the eviction callbacks:</span></span>

[!code-csharp[](memory/3.0sample/WebCacheSample/Controllers/HomeController.cs?name=snippet_ae)]

* <span data-ttu-id="429a5-227">Při použití zpětného volání k naplnění položky mezipaměti:</span><span class="sxs-lookup"><span data-stu-id="429a5-227">When using a callback to repopulate a cache item:</span></span>

  * <span data-ttu-id="429a5-228">Více požadavků může najít hodnotu klíče uloženou v mezipaměti jako prázdné, protože zpětné volání nebylo dokončeno.</span><span class="sxs-lookup"><span data-stu-id="429a5-228">Multiple requests can find the cached key value empty because the callback hasn't completed.</span></span>
  * <span data-ttu-id="429a5-229">To může mít za následek, že v několika vláknech se znovu naplní položka v mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="429a5-229">This can result in several threads repopulating the cached item.</span></span>

* <span data-ttu-id="429a5-230">Když se jedna položka mezipaměti používá k vytvoření jiného, podřízená položka zkopíruje tokeny vypršení platnosti nadřazené položky a nastavení vypršení platnosti na základě času.</span><span class="sxs-lookup"><span data-stu-id="429a5-230">When one cache entry is used to create another, the child copies the parent entry's expiration tokens and time-based expiration settings.</span></span> <span data-ttu-id="429a5-231">K podřízenému objektu nevypršela platnost ručním odebráním nebo aktualizací nadřazené položky.</span><span class="sxs-lookup"><span data-stu-id="429a5-231">The child isn't expired by manual removal or updating of the parent entry.</span></span>

* <span data-ttu-id="429a5-232">Slouží <xref:Microsoft.Extensions.Caching.Memory.ICacheEntry.PostEvictionCallbacks> k nastavení zpětných volání, která budou aktivována po vyřazení položky mezipaměti z mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="429a5-232">Use <xref:Microsoft.Extensions.Caching.Memory.ICacheEntry.PostEvictionCallbacks> to set the callbacks that will be fired after the cache entry is evicted from the cache.</span></span>
* <span data-ttu-id="429a5-233">Pro většinu aplikací `IMemoryCache` je povolený.</span><span class="sxs-lookup"><span data-stu-id="429a5-233">For most apps, `IMemoryCache` is enabled.</span></span> <span data-ttu-id="429a5-234">Například volání,, `AddMvc` `AddControllersWithViews` `AddRazorPages` , `AddMvcCore().AddRazorViewEngine` a mnoho dalších `Add{Service}` metod v `ConfigureServices` umožňuje `IMemoryCache` .</span><span class="sxs-lookup"><span data-stu-id="429a5-234">For example, calling `AddMvc`, `AddControllersWithViews`, `AddRazorPages`, `AddMvcCore().AddRazorViewEngine`, and many other `Add{Service}` methods in `ConfigureServices`, enables `IMemoryCache`.</span></span> <span data-ttu-id="429a5-235">U aplikací, které nevolají jednu z předchozích `Add{Service}` metod, může být nutné zavolat <xref:Microsoft.Extensions.DependencyInjection.MemoryCacheServiceCollectionExtensions.AddMemoryCache*> na `ConfigureServices` .</span><span class="sxs-lookup"><span data-stu-id="429a5-235">For apps that are not calling one of the preceding `Add{Service}` methods, it may be necessary to call <xref:Microsoft.Extensions.DependencyInjection.MemoryCacheServiceCollectionExtensions.AddMemoryCache*> in `ConfigureServices`.</span></span>

## <a name="background-cache-update"></a><span data-ttu-id="429a5-236">Aktualizace mezipaměti na pozadí</span><span class="sxs-lookup"><span data-stu-id="429a5-236">Background cache update</span></span>

<span data-ttu-id="429a5-237">Použijte [službu na pozadí](xref:fundamentals/host/hosted-services) , například <xref:Microsoft.Extensions.Hosting.IHostedService> k aktualizaci mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="429a5-237">Use a [background service](xref:fundamentals/host/hosted-services) such as <xref:Microsoft.Extensions.Hosting.IHostedService> to update the cache.</span></span> <span data-ttu-id="429a5-238">Služba na pozadí může přepočítat položky a pak je přiřadit do mezipaměti pouze v případě, že jsou připravené.</span><span class="sxs-lookup"><span data-stu-id="429a5-238">The background service can recompute the entries and then assign them to the cache only when they’re ready.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="429a5-239">Další zdroje</span><span class="sxs-lookup"><span data-stu-id="429a5-239">Additional resources</span></span>

* <xref:performance/caching/distributed>
* <xref:fundamentals/change-tokens>
* <xref:performance/caching/response>
* <xref:performance/caching/middleware>
* <xref:mvc/views/tag-helpers/builtin-th/cache-tag-helper>
* <xref:mvc/views/tag-helpers/builtin-th/distributed-cache-tag-helper>

::: moniker-end

::: moniker range="< aspnetcore-3.0"

<!-- This is the 2.1 version -->
<span data-ttu-id="429a5-240">Autor – [Rick Anderson](https://twitter.com/RickAndMSFT), [Jan Luo](https://github.com/JunTaoLuo)a [Steve Smith](https://ardalis.com/)</span><span class="sxs-lookup"><span data-stu-id="429a5-240">By [Rick Anderson](https://twitter.com/RickAndMSFT), [John Luo](https://github.com/JunTaoLuo), and [Steve Smith](https://ardalis.com/)</span></span>

<span data-ttu-id="429a5-241">[Zobrazit nebo stáhnout ukázkový kód](https://github.com/dotnet/AspNetCore.Docs/tree/master/aspnetcore/performance/caching/memory/sample) ([Jak stáhnout](xref:index#how-to-download-a-sample))</span><span class="sxs-lookup"><span data-stu-id="429a5-241">[View or download sample code](https://github.com/dotnet/AspNetCore.Docs/tree/master/aspnetcore/performance/caching/memory/sample) ([how to download](xref:index#how-to-download-a-sample))</span></span>

## <a name="caching-basics"></a><span data-ttu-id="429a5-242">Základy ukládání do mezipaměti</span><span class="sxs-lookup"><span data-stu-id="429a5-242">Caching basics</span></span>

<span data-ttu-id="429a5-243">Ukládání do mezipaměti může významně zlepšit výkon a škálovatelnost aplikace tím, že zkracuje práci potřebnou k vygenerování obsahu.</span><span class="sxs-lookup"><span data-stu-id="429a5-243">Caching can significantly improve the performance and scalability of an app by reducing the work required to generate content.</span></span> <span data-ttu-id="429a5-244">Ukládání do mezipaměti funguje nejlépe s daty, která se mění zřídka.</span><span class="sxs-lookup"><span data-stu-id="429a5-244">Caching works best with data that changes infrequently.</span></span> <span data-ttu-id="429a5-245">Ukládání do mezipaměti vytváří kopii dat, která může být vrácena mnohem rychleji než z původního zdroje.</span><span class="sxs-lookup"><span data-stu-id="429a5-245">Caching makes a copy of data that can be returned much faster than from the original source.</span></span> <span data-ttu-id="429a5-246">Kód by měl být napsán a testován, aby **nikdy nebyl** závislý na datech uložených v mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="429a5-246">Code should be written and tested to **never** depend on cached data.</span></span>

<span data-ttu-id="429a5-247">ASP.NET Core podporuje několik různých mezipamětí.</span><span class="sxs-lookup"><span data-stu-id="429a5-247">ASP.NET Core supports several different caches.</span></span> <span data-ttu-id="429a5-248">Nejjednodušší mezipaměť je založena na [IMemoryCache](/dotnet/api/microsoft.extensions.caching.memory.imemorycache), který představuje mezipaměť uloženou v paměti webového serveru.</span><span class="sxs-lookup"><span data-stu-id="429a5-248">The simplest cache is based on the [IMemoryCache](/dotnet/api/microsoft.extensions.caching.memory.imemorycache), which represents a cache stored in the memory of the web server.</span></span> <span data-ttu-id="429a5-249">Aplikace, které běží na serverové farmě (více serverů), by měly zajistit, aby relace byly při použití mezipaměti v paměti rychlé.</span><span class="sxs-lookup"><span data-stu-id="429a5-249">Apps that run on a server farm (multiple servers) should ensure that sessions are sticky when using the in-memory cache.</span></span> <span data-ttu-id="429a5-250">Relace typu Sticky se zajišťují, aby pozdější požadavky z klienta přešly na stejný server.</span><span class="sxs-lookup"><span data-stu-id="429a5-250">Sticky sessions ensure that later requests from a client all go to the same server.</span></span> <span data-ttu-id="429a5-251">Například Azure Web Apps používá [Směrování žádostí o aplikace](https://www.iis.net/learn/extensions/planning-for-arr) (ARR) ke směrování všech požadavků od uživatelského agenta na stejný server.</span><span class="sxs-lookup"><span data-stu-id="429a5-251">For example, Azure Web apps use [Application Request Routing](https://www.iis.net/learn/extensions/planning-for-arr) (ARR) to route all requests from a user agent to the same server.</span></span>

<span data-ttu-id="429a5-252">Nesticky relace ve webové farmě vyžadují [distribuovanou mezipaměť](distributed.md) , aby nedocházelo k problémům s konzistencí mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="429a5-252">Non-sticky sessions in a web farm require a [distributed cache](distributed.md) to avoid cache consistency problems.</span></span> <span data-ttu-id="429a5-253">Pro některé aplikace může distribuovaná mezipaměť podporovat větší škálování než mezipaměť v paměti.</span><span class="sxs-lookup"><span data-stu-id="429a5-253">For some apps, a distributed cache can support higher scale-out than an in-memory cache.</span></span> <span data-ttu-id="429a5-254">Použití distribuované mezipaměti přesměruje paměť mezipaměti do externího procesu.</span><span class="sxs-lookup"><span data-stu-id="429a5-254">Using a distributed cache offloads the cache memory to an external process.</span></span>

<span data-ttu-id="429a5-255">Mezipaměť v paměti může ukládat libovolný objekt.</span><span class="sxs-lookup"><span data-stu-id="429a5-255">The in-memory cache can store any object.</span></span> <span data-ttu-id="429a5-256">Rozhraní distribuované mezipaměti je omezené na `byte[]` .</span><span class="sxs-lookup"><span data-stu-id="429a5-256">The distributed cache interface is limited to `byte[]`.</span></span> <span data-ttu-id="429a5-257">Položky mezipaměti v paměti a distribuované mezipaměti ukládají jako páry klíč-hodnota.</span><span class="sxs-lookup"><span data-stu-id="429a5-257">The in-memory and distributed cache store cache items as key-value pairs.</span></span>

## <a name="systemruntimecachingmemorycache"></a><span data-ttu-id="429a5-258">System. Runtime. Caching/MemoryCache</span><span class="sxs-lookup"><span data-stu-id="429a5-258">System.Runtime.Caching/MemoryCache</span></span>

<span data-ttu-id="429a5-259"><xref:System.Runtime.Caching>/<xref:System.Runtime.Caching.MemoryCache>([Balíček NuGet](https://www.nuget.org/packages/System.Runtime.Caching/)) se dá použít s:</span><span class="sxs-lookup"><span data-stu-id="429a5-259"><xref:System.Runtime.Caching>/<xref:System.Runtime.Caching.MemoryCache> ([NuGet package](https://www.nuget.org/packages/System.Runtime.Caching/)) can be used with:</span></span>

* <span data-ttu-id="429a5-260">.NET Standard 2,0 nebo novější.</span><span class="sxs-lookup"><span data-stu-id="429a5-260">.NET Standard 2.0 or later.</span></span>
* <span data-ttu-id="429a5-261">Jakákoli [implementace .NET](/dotnet/standard/net-standard#net-implementation-support) , která cílí na .NET Standard 2,0 nebo novější.</span><span class="sxs-lookup"><span data-stu-id="429a5-261">Any [.NET implementation](/dotnet/standard/net-standard#net-implementation-support) that targets .NET Standard 2.0 or later.</span></span> <span data-ttu-id="429a5-262">Například ASP.NET Core 2,0 nebo novější.</span><span class="sxs-lookup"><span data-stu-id="429a5-262">For example, ASP.NET Core 2.0 or later.</span></span>
* <span data-ttu-id="429a5-263">.NET Framework 4,5 nebo novější.</span><span class="sxs-lookup"><span data-stu-id="429a5-263">.NET Framework 4.5 or later.</span></span>

<span data-ttu-id="429a5-264">[Microsoft. Extensions. Caching. Memory](https://www.nuget.org/packages/Microsoft.Extensions.Caching.Memory/) / `IMemoryCache` (popsaná v tomto článku) se doporučuje, `System.Runtime.Caching` / `MemoryCache` protože je lépe integrovaná do ASP.NET Core.</span><span class="sxs-lookup"><span data-stu-id="429a5-264">[Microsoft.Extensions.Caching.Memory](https://www.nuget.org/packages/Microsoft.Extensions.Caching.Memory/)/`IMemoryCache` (described in this article) is recommended over `System.Runtime.Caching`/`MemoryCache` because it's better integrated into ASP.NET Core.</span></span> <span data-ttu-id="429a5-265">Například `IMemoryCache` funguje nativně s [vkládáním závislostí](xref:fundamentals/dependency-injection)ASP.NET Core.</span><span class="sxs-lookup"><span data-stu-id="429a5-265">For example, `IMemoryCache` works natively with ASP.NET Core [dependency injection](xref:fundamentals/dependency-injection).</span></span>

<span data-ttu-id="429a5-266">Použijte `System.Runtime.Caching` / `MemoryCache` jako most kompatibility při přenosu kódu z ASP.NET 4. x do ASP.NET Core.</span><span class="sxs-lookup"><span data-stu-id="429a5-266">Use `System.Runtime.Caching`/`MemoryCache` as a compatibility bridge when porting code from ASP.NET 4.x to ASP.NET Core.</span></span>

## <a name="cache-guidelines"></a><span data-ttu-id="429a5-267">Pokyny pro mezipaměť</span><span class="sxs-lookup"><span data-stu-id="429a5-267">Cache guidelines</span></span>

* <span data-ttu-id="429a5-268">Kód by měl vždy mít možnost Fallback načíst data a **nemusí** být závislý na dostupné hodnotě uložené v mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="429a5-268">Code should always have a fallback option to fetch data and **not** depend on a cached value being available.</span></span>
* <span data-ttu-id="429a5-269">Mezipaměť používá prostředek omezených, paměť.</span><span class="sxs-lookup"><span data-stu-id="429a5-269">The cache uses a scarce resource, memory.</span></span> <span data-ttu-id="429a5-270">Omezit nárůst mezipaměti:</span><span class="sxs-lookup"><span data-stu-id="429a5-270">Limit cache growth:</span></span>
  * <span data-ttu-id="429a5-271">Nepoužívejte **externí** vstup jako klíče mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="429a5-271">Do **not** use external input as cache keys.</span></span>
  * <span data-ttu-id="429a5-272">K omezení růstu mezipaměti použijte vypršení platnosti.</span><span class="sxs-lookup"><span data-stu-id="429a5-272">Use expirations to limit cache growth.</span></span>
  * <span data-ttu-id="429a5-273">[Pro omezení velikosti mezipaměti použijte možnost setSize, Size a SizeLimit](#use-setsize-size-and-sizelimit-to-limit-cache-size).</span><span class="sxs-lookup"><span data-stu-id="429a5-273">[Use SetSize, Size, and SizeLimit to limit cache size](#use-setsize-size-and-sizelimit-to-limit-cache-size).</span></span> <span data-ttu-id="429a5-274">Modul runtime ASP.NET Core neomezuje velikost mezipaměti na základě tlaku paměti.</span><span class="sxs-lookup"><span data-stu-id="429a5-274">The ASP.NET Core runtime does not limit cache size based on memory pressure.</span></span> <span data-ttu-id="429a5-275">Velikost mezipaměti můžete omezit na vývojáře.</span><span class="sxs-lookup"><span data-stu-id="429a5-275">It's up to the developer to limit cache size.</span></span>

## <a name="using-imemorycache"></a><span data-ttu-id="429a5-276">Použití IMemoryCache</span><span class="sxs-lookup"><span data-stu-id="429a5-276">Using IMemoryCache</span></span>

> [!WARNING]
> <span data-ttu-id="429a5-277">Použití *sdílené* mezipaměti paměti ze [Injektáže](xref:fundamentals/dependency-injection) a volání závislosti `SetSize` , `Size` nebo `SizeLimit` pro omezení velikosti mezipaměti může způsobit selhání aplikace.</span><span class="sxs-lookup"><span data-stu-id="429a5-277">Using a *shared* memory cache from [Dependency Injection](xref:fundamentals/dependency-injection) and calling `SetSize`, `Size`, or `SizeLimit` to limit cache size can cause the app to fail.</span></span> <span data-ttu-id="429a5-278">Pokud je u mezipaměti nastaveno omezení velikosti, všechny položky musí při přidávání určovat velikost.</span><span class="sxs-lookup"><span data-stu-id="429a5-278">When a size limit is set on a cache, all entries must specify a size when being added.</span></span> <span data-ttu-id="429a5-279">To může vést k problémům, protože vývojáři nemusí mít úplnou kontrolu nad tím, co používá sdílenou mezipaměť.</span><span class="sxs-lookup"><span data-stu-id="429a5-279">This can lead to issues since developers may not have full control on what uses the shared cache.</span></span> <span data-ttu-id="429a5-280">Entity Framework Core například používá sdílenou mezipaměť a neurčuje velikost.</span><span class="sxs-lookup"><span data-stu-id="429a5-280">For example, Entity Framework Core uses the shared cache and does not specify a size.</span></span> <span data-ttu-id="429a5-281">Pokud aplikace nastaví omezení velikosti mezipaměti a používá EF Core, aplikace vyvolá `InvalidOperationException` .</span><span class="sxs-lookup"><span data-stu-id="429a5-281">If an app sets a cache size limit and uses EF Core, the app throws an `InvalidOperationException`.</span></span>
> <span data-ttu-id="429a5-282">Při použití `SetSize` , `Size` nebo `SizeLimit` k omezení mezipaměti vytvořte pro ukládání do mezipaměti typ singleton.</span><span class="sxs-lookup"><span data-stu-id="429a5-282">When using `SetSize`, `Size`, or `SizeLimit` to limit cache, create a cache singleton for caching.</span></span> <span data-ttu-id="429a5-283">Další informace a příklad najdete v tématu [použití setSize, Size a SizeLimit k omezení velikosti mezipaměti](#use-setsize-size-and-sizelimit-to-limit-cache-size).</span><span class="sxs-lookup"><span data-stu-id="429a5-283">For more information and an example, see [Use SetSize, Size, and SizeLimit to limit cache size](#use-setsize-size-and-sizelimit-to-limit-cache-size).</span></span>

<span data-ttu-id="429a5-284">Mezipaměť v paměti je *Služba* , na kterou se odkazuje z vaší aplikace pomocí [Injektáže závislostí](../../fundamentals/dependency-injection.md).</span><span class="sxs-lookup"><span data-stu-id="429a5-284">In-memory caching is a *service* that's referenced from your app using [Dependency Injection](../../fundamentals/dependency-injection.md).</span></span> <span data-ttu-id="429a5-285">Zavolat `AddMemoryCache` na `ConfigureServices` :</span><span class="sxs-lookup"><span data-stu-id="429a5-285">Call `AddMemoryCache` in `ConfigureServices`:</span></span>

[!code-csharp[](memory/sample/WebCache/Startup.cs?highlight=9)]

<span data-ttu-id="429a5-286">Vyžádejte `IMemoryCache` instanci v konstruktoru:</span><span class="sxs-lookup"><span data-stu-id="429a5-286">Request the `IMemoryCache` instance in the constructor:</span></span>

[!code-csharp[](memory/sample/WebCache/Controllers/HomeController.cs?name=snippet_ctor)]

<span data-ttu-id="429a5-287">`IMemoryCache`vyžaduje balíček NuGet [Microsoft. Extensions. Caching. Memory](https://www.nuget.org/packages/Microsoft.Extensions.Caching.Memory/), který je k dispozici ve [službě Microsoft. AspNetCore. app Metapackage](xref:fundamentals/metapackage-app).</span><span class="sxs-lookup"><span data-stu-id="429a5-287">`IMemoryCache` requires NuGet package [Microsoft.Extensions.Caching.Memory](https://www.nuget.org/packages/Microsoft.Extensions.Caching.Memory/), which is available in the [Microsoft.AspNetCore.App metapackage](xref:fundamentals/metapackage-app).</span></span>

<span data-ttu-id="429a5-288">Následující kód používá [TryGetValue](/dotnet/api/microsoft.extensions.caching.memory.imemorycache.trygetvalue?view=aspnetcore-2.0#Microsoft_Extensions_Caching_Memory_IMemoryCache_TryGetValue_System_Object_System_Object__) ke kontrole, zda je čas v mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="429a5-288">The following code uses [TryGetValue](/dotnet/api/microsoft.extensions.caching.memory.imemorycache.trygetvalue?view=aspnetcore-2.0#Microsoft_Extensions_Caching_Memory_IMemoryCache_TryGetValue_System_Object_System_Object__) to check if a time is in the cache.</span></span> <span data-ttu-id="429a5-289">Pokud čas není uložen v mezipaměti, je vytvořena nová položka a přidána do mezipaměti se [sadou](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.set?view=aspnetcore-2.0#Microsoft_Extensions_Caching_Memory_CacheExtensions_Set__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object___0_Microsoft_Extensions_Caching_Memory_MemoryCacheEntryOptions_).</span><span class="sxs-lookup"><span data-stu-id="429a5-289">If a time isn't cached, a new entry is created and added to the cache with [Set](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.set?view=aspnetcore-2.0#Microsoft_Extensions_Caching_Memory_CacheExtensions_Set__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object___0_Microsoft_Extensions_Caching_Memory_MemoryCacheEntryOptions_).</span></span>

[!code-csharp[](memory/sample/WebCache/CacheKeys.cs)]

[!code-csharp[](memory/sample/WebCache/Controllers/HomeController.cs?name=snippet1)]

<span data-ttu-id="429a5-290">Aktuální čas a čas v mezipaměti se zobrazí:</span><span class="sxs-lookup"><span data-stu-id="429a5-290">The current time and the cached time are displayed:</span></span>

[!code-cshtml[](memory/sample/WebCache/Views/Home/Cache.cshtml)]

<span data-ttu-id="429a5-291">Hodnota uložená v mezipaměti `DateTime` zůstává v mezipaměti a v době, kdy jsou požadavky v rámci časového limitu.</span><span class="sxs-lookup"><span data-stu-id="429a5-291">The cached `DateTime` value remains in the cache while there are requests within the timeout period.</span></span> <span data-ttu-id="429a5-292">Následující obrázek ukazuje aktuální čas a starší čas načtený z mezipaměti:</span><span class="sxs-lookup"><span data-stu-id="429a5-292">The following image shows the current time and an older time retrieved from the cache:</span></span>

![Zobrazení indexu se dvěma různými časy zobrazení](memory/_static/time.png)

<span data-ttu-id="429a5-294">Následující kód používá [GetOrCreate](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.getorcreate#Microsoft_Extensions_Caching_Memory_CacheExtensions_GetOrCreate__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_System_Func_Microsoft_Extensions_Caching_Memory_ICacheEntry___0__) a [GetOrCreateAsync](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.getorcreateasync#Microsoft_Extensions_Caching_Memory_CacheExtensions_GetOrCreateAsync__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_System_Func_Microsoft_Extensions_Caching_Memory_ICacheEntry_System_Threading_Tasks_Task___0___) k ukládání dat do mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="429a5-294">The following code uses [GetOrCreate](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.getorcreate#Microsoft_Extensions_Caching_Memory_CacheExtensions_GetOrCreate__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_System_Func_Microsoft_Extensions_Caching_Memory_ICacheEntry___0__) and [GetOrCreateAsync](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.getorcreateasync#Microsoft_Extensions_Caching_Memory_CacheExtensions_GetOrCreateAsync__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_System_Func_Microsoft_Extensions_Caching_Memory_ICacheEntry_System_Threading_Tasks_Task___0___) to cache data.</span></span>

[!code-csharp[](memory/sample/WebCache/Controllers/HomeController.cs?name=snippet2&highlight=3-7,14-19)]

<span data-ttu-id="429a5-295">Následující kód volá [Get](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.get#Microsoft_Extensions_Caching_Memory_CacheExtensions_Get__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_) k načtení času uloženého v mezipaměti:</span><span class="sxs-lookup"><span data-stu-id="429a5-295">The following code calls [Get](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.get#Microsoft_Extensions_Caching_Memory_CacheExtensions_Get__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_) to fetch the cached time:</span></span>

[!code-csharp[](memory/sample/WebCache/Controllers/HomeController.cs?name=snippet_gct)]

<span data-ttu-id="429a5-296"><xref:Microsoft.Extensions.Caching.Memory.CacheExtensions.GetOrCreate*><xref:Microsoft.Extensions.Caching.Memory.CacheExtensions.GetOrCreateAsync*>metody rozšíření, a [Get](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.get#Microsoft_Extensions_Caching_Memory_CacheExtensions_Get__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_) jsou součástí třídy [CacheExtensions](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions) , která rozšiřuje možnosti <xref:Microsoft.Extensions.Caching.Memory.IMemoryCache> .</span><span class="sxs-lookup"><span data-stu-id="429a5-296"><xref:Microsoft.Extensions.Caching.Memory.CacheExtensions.GetOrCreate*> , <xref:Microsoft.Extensions.Caching.Memory.CacheExtensions.GetOrCreateAsync*>, and [Get](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions.get#Microsoft_Extensions_Caching_Memory_CacheExtensions_Get__1_Microsoft_Extensions_Caching_Memory_IMemoryCache_System_Object_) are extension methods part of the [CacheExtensions](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions) class that extends the capability of <xref:Microsoft.Extensions.Caching.Memory.IMemoryCache>.</span></span> <span data-ttu-id="429a5-297">Popis dalších metod mezipaměti naleznete v tématu [metody IMemoryCache](/dotnet/api/microsoft.extensions.caching.memory.imemorycache) a [metody CacheExtensions](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions) .</span><span class="sxs-lookup"><span data-stu-id="429a5-297">See [IMemoryCache methods](/dotnet/api/microsoft.extensions.caching.memory.imemorycache) and [CacheExtensions methods](/dotnet/api/microsoft.extensions.caching.memory.cacheextensions) for a description of other cache methods.</span></span>

## <a name="memorycacheentryoptions"></a><span data-ttu-id="429a5-298">MemoryCacheEntryOptions</span><span class="sxs-lookup"><span data-stu-id="429a5-298">MemoryCacheEntryOptions</span></span>

<span data-ttu-id="429a5-299">Následující ukázka:</span><span class="sxs-lookup"><span data-stu-id="429a5-299">The following sample:</span></span>

* <span data-ttu-id="429a5-300">Nastaví posuvný čas vypršení platnosti.</span><span class="sxs-lookup"><span data-stu-id="429a5-300">Sets a sliding expiration time.</span></span> <span data-ttu-id="429a5-301">Požadavky, které přistupují k této položce v mezipaměti, budou resetovat hodiny klouzavého vypršení platnosti.</span><span class="sxs-lookup"><span data-stu-id="429a5-301">Requests that access this cached item will reset the sliding expiration clock.</span></span>
* <span data-ttu-id="429a5-302">Nastaví prioritu mezipaměti na `CacheItemPriority.NeverRemove` .</span><span class="sxs-lookup"><span data-stu-id="429a5-302">Sets the cache priority to `CacheItemPriority.NeverRemove`.</span></span>
* <span data-ttu-id="429a5-303">Nastaví [PostEvictionDelegate](/dotnet/api/microsoft.extensions.caching.memory.postevictiondelegate) , který bude volán po vyřazení položky z mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="429a5-303">Sets a [PostEvictionDelegate](/dotnet/api/microsoft.extensions.caching.memory.postevictiondelegate) that will be called after the entry is evicted from the cache.</span></span> <span data-ttu-id="429a5-304">Zpětné volání je spuštěno v jiném vlákně z kódu, který odebere položku z mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="429a5-304">The callback is run on a different thread from the code that removes the item from the cache.</span></span>

[!code-csharp[](memory/sample/WebCache/Controllers/HomeController.cs?name=snippet_et&highlight=14-21)]

## <a name="use-setsize-size-and-sizelimit-to-limit-cache-size"></a><span data-ttu-id="429a5-305">Omezení velikosti mezipaměti pomocí SetSize, velikosti a SizeLimit</span><span class="sxs-lookup"><span data-stu-id="429a5-305">Use SetSize, Size, and SizeLimit to limit cache size</span></span>

<span data-ttu-id="429a5-306">`MemoryCache`Instance může volitelně určovat a vymáhat omezení velikosti.</span><span class="sxs-lookup"><span data-stu-id="429a5-306">A `MemoryCache` instance may optionally specify and enforce a size limit.</span></span> <span data-ttu-id="429a5-307">Omezení velikosti mezipaměti nemá definovanou měrnou jednotku, protože mezipaměť nemá žádný mechanismus pro měření velikosti položek.</span><span class="sxs-lookup"><span data-stu-id="429a5-307">The cache size limit does not have a defined unit of measure because the cache has no mechanism to measure the size of entries.</span></span> <span data-ttu-id="429a5-308">Pokud je nastaven limit velikosti mezipaměti, musí všechny položky určovat velikost.</span><span class="sxs-lookup"><span data-stu-id="429a5-308">If the cache size limit is set, all entries must specify size.</span></span> <span data-ttu-id="429a5-309">Modul runtime ASP.NET Core neomezuje velikost mezipaměti na základě tlaku paměti.</span><span class="sxs-lookup"><span data-stu-id="429a5-309">The ASP.NET Core runtime does not limit cache size based on memory pressure.</span></span> <span data-ttu-id="429a5-310">Velikost mezipaměti můžete omezit na vývojáře.</span><span class="sxs-lookup"><span data-stu-id="429a5-310">It's up to the developer to limit cache size.</span></span> <span data-ttu-id="429a5-311">Zadaná velikost je v jednotkách, které vývojář zvolí.</span><span class="sxs-lookup"><span data-stu-id="429a5-311">The size specified is in units the developer chooses.</span></span>

<span data-ttu-id="429a5-312">Například:</span><span class="sxs-lookup"><span data-stu-id="429a5-312">For example:</span></span>

* <span data-ttu-id="429a5-313">Pokud byla webová aplikace primárně do mezipaměti řetězců, každá velikost položky mezipaměti může být délka řetězce.</span><span class="sxs-lookup"><span data-stu-id="429a5-313">If the web app was primarily caching strings, each cache entry size could be the string length.</span></span>
* <span data-ttu-id="429a5-314">Aplikace může určit velikost všech položek jako 1 a limit velikosti je počet položek.</span><span class="sxs-lookup"><span data-stu-id="429a5-314">The app could specify the size of all entries as 1, and the size limit is the count of entries.</span></span>

<span data-ttu-id="429a5-315">Pokud není <xref:Microsoft.Extensions.Caching.Memory.MemoryCacheOptions.SizeLimit> nastaven, mezipaměť se rozrůstá bez vazby.</span><span class="sxs-lookup"><span data-stu-id="429a5-315">If <xref:Microsoft.Extensions.Caching.Memory.MemoryCacheOptions.SizeLimit> is not set, the cache grows without bound.</span></span> <span data-ttu-id="429a5-316">Modul runtime ASP.NET Core neořízne mezipaměť, pokud je systémová paměť nízká.</span><span class="sxs-lookup"><span data-stu-id="429a5-316">The ASP.NET Core runtime does not trim the cache when system memory is low.</span></span> <span data-ttu-id="429a5-317">Aplikace jsou v podstatě navrženy na:</span><span class="sxs-lookup"><span data-stu-id="429a5-317">Apps much be architected to:</span></span>

* <span data-ttu-id="429a5-318">Omezte nárůst mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="429a5-318">Limit cache growth.</span></span>
* <span data-ttu-id="429a5-319">Zavolejte <xref:Microsoft.Extensions.Caching.Memory.MemoryCache.Compact*> nebo <xref:Microsoft.Extensions.Caching.Memory.MemoryCache.Remove*> když je dostupná paměť omezená:</span><span class="sxs-lookup"><span data-stu-id="429a5-319">Call <xref:Microsoft.Extensions.Caching.Memory.MemoryCache.Compact*> or <xref:Microsoft.Extensions.Caching.Memory.MemoryCache.Remove*> when available memory is limited:</span></span>

<span data-ttu-id="429a5-320">Následující kód vytvoří pevnou velikost jednotky <xref:Microsoft.Extensions.Caching.Memory.MemoryCache> dostupnou pro [vkládání závislostí](xref:fundamentals/dependency-injection).</span><span class="sxs-lookup"><span data-stu-id="429a5-320">The following code creates a unitless fixed size <xref:Microsoft.Extensions.Caching.Memory.MemoryCache> accessible by [dependency injection](xref:fundamentals/dependency-injection):</span></span>

[!code-csharp[](memory/sample/RPcache/Services/MyMemoryCache.cs?name=snippet)]

<span data-ttu-id="429a5-321">`SizeLimit`nemá jednotky.</span><span class="sxs-lookup"><span data-stu-id="429a5-321">`SizeLimit` does not have units.</span></span> <span data-ttu-id="429a5-322">Položky v mezipaměti musí určovat velikost v jakémkoli z jednotek, které považují za nejvhodnější, pokud byl nastaven limit velikosti mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="429a5-322">Cached entries must specify size in whatever units they deem most appropriate if the cache size limit has been set.</span></span> <span data-ttu-id="429a5-323">Všichni uživatelé instance mezipaměti by měli používat stejný systém jednotek.</span><span class="sxs-lookup"><span data-stu-id="429a5-323">All users of a cache instance should use the same unit system.</span></span> <span data-ttu-id="429a5-324">Záznam nebude uložen do mezipaměti, pokud součet velikostí záznamů uložených v mezipaměti překročí hodnotu zadanou parametrem `SizeLimit` .</span><span class="sxs-lookup"><span data-stu-id="429a5-324">An entry will not be cached if the sum of the cached entry sizes exceeds the value specified by `SizeLimit`.</span></span> <span data-ttu-id="429a5-325">Pokud není nastavené žádné omezení velikosti mezipaměti, bude velikost mezipaměti nastavená u položky ignorována.</span><span class="sxs-lookup"><span data-stu-id="429a5-325">If no cache size limit is set, the cache size set on the entry will be ignored.</span></span>

<span data-ttu-id="429a5-326">Následující kód se registruje v `MyMemoryCache` kontejneru [Injektáže pro vkládání závislostí](xref:fundamentals/dependency-injection) .</span><span class="sxs-lookup"><span data-stu-id="429a5-326">The following code registers `MyMemoryCache` with the [dependency injection](xref:fundamentals/dependency-injection) container.</span></span>

[!code-csharp[](memory/sample/RPcache/Startup.cs?name=snippet&highlight=5)]

<span data-ttu-id="429a5-327">`MyMemoryCache`je vytvořen jako nezávislá mezipaměť paměti pro součásti, které mají informace o této velikosti omezené mezipaměti a také o tom, jak správně nastavit velikost položky mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="429a5-327">`MyMemoryCache` is created as an independent memory cache for components that are aware of this size limited cache and know how to set cache entry size appropriately.</span></span>

<span data-ttu-id="429a5-328">Následující kód používá `MyMemoryCache` :</span><span class="sxs-lookup"><span data-stu-id="429a5-328">The following code uses `MyMemoryCache`:</span></span>

[!code-csharp[](memory/sample/RPcache/Pages/About.cshtml.cs?name=snippet)]

<span data-ttu-id="429a5-329">Velikost položky mezipaměti lze nastavit podle [velikosti](/dotnet/api/microsoft.extensions.caching.memory.memorycacheentryoptions.size?view=aspnetcore-2.1#Microsoft_Extensions_Caching_Memory_MemoryCacheEntryOptions_Size) nebo metody rozšíření [setSize](/dotnet/api/microsoft.extensions.caching.memory.memorycacheentryextensions.setsize?view=aspnetcore-2.0#Microsoft_Extensions_Caching_Memory_MemoryCacheEntryExtensions_SetSize_Microsoft_Extensions_Caching_Memory_MemoryCacheEntryOptions_System_Int64_) :</span><span class="sxs-lookup"><span data-stu-id="429a5-329">The size of the cache entry can be set by [Size](/dotnet/api/microsoft.extensions.caching.memory.memorycacheentryoptions.size?view=aspnetcore-2.1#Microsoft_Extensions_Caching_Memory_MemoryCacheEntryOptions_Size) or the [SetSize](/dotnet/api/microsoft.extensions.caching.memory.memorycacheentryextensions.setsize?view=aspnetcore-2.0#Microsoft_Extensions_Caching_Memory_MemoryCacheEntryExtensions_SetSize_Microsoft_Extensions_Caching_Memory_MemoryCacheEntryOptions_System_Int64_) extension method:</span></span>

[!code-csharp[](memory/sample/RPcache/Pages/About.cshtml.cs?name=snippet2&highlight=9,10,14,15)]

### <a name="memorycachecompact"></a><span data-ttu-id="429a5-330">MemoryCache. Compact</span><span class="sxs-lookup"><span data-stu-id="429a5-330">MemoryCache.Compact</span></span>

<span data-ttu-id="429a5-331">`MemoryCache.Compact`pokusí se odebrat zadané procento mezipaměti v následujícím pořadí:</span><span class="sxs-lookup"><span data-stu-id="429a5-331">`MemoryCache.Compact` attempts to remove the specified percentage of the cache in the following order:</span></span>

* <span data-ttu-id="429a5-332">Všechny položky, jejichž platnost vypršela.</span><span class="sxs-lookup"><span data-stu-id="429a5-332">All expired items.</span></span>
* <span data-ttu-id="429a5-333">Položky podle priority.</span><span class="sxs-lookup"><span data-stu-id="429a5-333">Items by priority.</span></span> <span data-ttu-id="429a5-334">Nejprve se odeberou položky s nejnižší prioritou.</span><span class="sxs-lookup"><span data-stu-id="429a5-334">Lowest priority items are removed first.</span></span>
* <span data-ttu-id="429a5-335">Nejméně naposledy použité objekty.</span><span class="sxs-lookup"><span data-stu-id="429a5-335">Least recently used objects.</span></span>
* <span data-ttu-id="429a5-336">Položky s nejdřívějším absolutním vypršením platnosti.</span><span class="sxs-lookup"><span data-stu-id="429a5-336">Items with the earliest absolute expiration.</span></span>
* <span data-ttu-id="429a5-337">Položky s nejdřívějším klouzavém vypršením platnosti.</span><span class="sxs-lookup"><span data-stu-id="429a5-337">Items with the earliest sliding expiration.</span></span>

<span data-ttu-id="429a5-338">Připnuté položky s prioritou <xref:Microsoft.Extensions.Caching.Memory.CacheItemPriority.NeverRemove> nejsou nikdy odebrány.</span><span class="sxs-lookup"><span data-stu-id="429a5-338">Pinned items with priority <xref:Microsoft.Extensions.Caching.Memory.CacheItemPriority.NeverRemove> are never removed.</span></span>

[!code-csharp[](memory/3.0sample/RPcache/Pages/TestCache.cshtml.cs?name=snippet3)]

<span data-ttu-id="429a5-339">Další informace najdete v tématu [Compact source na GitHubu](https://github.com/dotnet/extensions/blob/v3.0.0-preview8.19405.4/src/Caching/Memory/src/MemoryCache.cs#L382-L393) .</span><span class="sxs-lookup"><span data-stu-id="429a5-339">See [Compact source on GitHub](https://github.com/dotnet/extensions/blob/v3.0.0-preview8.19405.4/src/Caching/Memory/src/MemoryCache.cs#L382-L393) for more information.</span></span>

## <a name="cache-dependencies"></a><span data-ttu-id="429a5-340">Závislosti mezipaměti</span><span class="sxs-lookup"><span data-stu-id="429a5-340">Cache dependencies</span></span>

<span data-ttu-id="429a5-341">Následující příklad ukazuje, jak vyprší platnost položky mezipaměti, pokud vyprší platnost závislé položky.</span><span class="sxs-lookup"><span data-stu-id="429a5-341">The following sample shows how to expire a cache entry if a dependent entry expires.</span></span> <span data-ttu-id="429a5-342"><xref:Microsoft.Extensions.Primitives.CancellationChangeToken>Přidá se k položce v mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="429a5-342">A <xref:Microsoft.Extensions.Primitives.CancellationChangeToken> is added to the cached item.</span></span> <span data-ttu-id="429a5-343">Když `Cancel` je volána na `CancellationTokenSource` , obě položky mezipaměti jsou vyřazeny.</span><span class="sxs-lookup"><span data-stu-id="429a5-343">When `Cancel` is called on the `CancellationTokenSource`, both cache entries are evicted.</span></span>

[!code-csharp[](memory/sample/WebCache/Controllers/HomeController.cs?name=snippet_ed)]

<span data-ttu-id="429a5-344">Použití `CancellationTokenSource` Možnosti umožňuje vyřazení více položek mezipaměti jako skupiny.</span><span class="sxs-lookup"><span data-stu-id="429a5-344">Using a `CancellationTokenSource` allows multiple cache entries to be evicted as a group.</span></span> <span data-ttu-id="429a5-345">Pomocí `using` vzoru ve výše uvedeném kódu budou položky mezipaměti vytvořené uvnitř `using` bloku dědit triggery a nastavení vypršení platnosti.</span><span class="sxs-lookup"><span data-stu-id="429a5-345">With the `using` pattern in the code above, cache entries created inside the `using` block will inherit triggers and expiration settings.</span></span>

## <a name="additional-notes"></a><span data-ttu-id="429a5-346">Další poznámky</span><span class="sxs-lookup"><span data-stu-id="429a5-346">Additional notes</span></span>

* <span data-ttu-id="429a5-347">Při použití zpětného volání k naplnění položky mezipaměti:</span><span class="sxs-lookup"><span data-stu-id="429a5-347">When using a callback to repopulate a cache item:</span></span>

  * <span data-ttu-id="429a5-348">Více požadavků může najít hodnotu klíče uloženou v mezipaměti jako prázdné, protože zpětné volání nebylo dokončeno.</span><span class="sxs-lookup"><span data-stu-id="429a5-348">Multiple requests can find the cached key value empty because the callback hasn't completed.</span></span>
  * <span data-ttu-id="429a5-349">To může mít za následek, že v několika vláknech se znovu naplní položka v mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="429a5-349">This can result in several threads repopulating the cached item.</span></span>

* <span data-ttu-id="429a5-350">Když se jedna položka mezipaměti používá k vytvoření jiného, podřízená položka zkopíruje tokeny vypršení platnosti nadřazené položky a nastavení vypršení platnosti na základě času.</span><span class="sxs-lookup"><span data-stu-id="429a5-350">When one cache entry is used to create another, the child copies the parent entry's expiration tokens and time-based expiration settings.</span></span> <span data-ttu-id="429a5-351">K podřízenému objektu nevypršela platnost ručním odebráním nebo aktualizací nadřazené položky.</span><span class="sxs-lookup"><span data-stu-id="429a5-351">The child isn't expired by manual removal or updating of the parent entry.</span></span>

* <span data-ttu-id="429a5-352">Pomocí [PostEvictionCallbacks](/dotnet/api/microsoft.extensions.caching.memory.icacheentry.postevictioncallbacks#Microsoft_Extensions_Caching_Memory_ICacheEntry_PostEvictionCallbacks) můžete nastavit zpětná volání, která budou aktivována po vyřazení položky mezipaměti z mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="429a5-352">Use [PostEvictionCallbacks](/dotnet/api/microsoft.extensions.caching.memory.icacheentry.postevictioncallbacks#Microsoft_Extensions_Caching_Memory_ICacheEntry_PostEvictionCallbacks) to set the callbacks that will be fired after the cache entry is evicted from the cache.</span></span>

## <a name="background-cache-update"></a><span data-ttu-id="429a5-353">Aktualizace mezipaměti na pozadí</span><span class="sxs-lookup"><span data-stu-id="429a5-353">Background cache update</span></span>

<span data-ttu-id="429a5-354">Použijte [službu na pozadí](xref:fundamentals/host/hosted-services) , například <xref:Microsoft.Extensions.Hosting.IHostedService> k aktualizaci mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="429a5-354">Use a [background service](xref:fundamentals/host/hosted-services) such as <xref:Microsoft.Extensions.Hosting.IHostedService> to update the cache.</span></span> <span data-ttu-id="429a5-355">Služba na pozadí může přepočítat položky a pak je přiřadit do mezipaměti pouze v případě, že jsou připravené.</span><span class="sxs-lookup"><span data-stu-id="429a5-355">The background service can recompute the entries and then assign them to the cache only when they’re ready.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="429a5-356">Další materiály</span><span class="sxs-lookup"><span data-stu-id="429a5-356">Additional resources</span></span>

* <xref:performance/caching/distributed>
* <xref:fundamentals/change-tokens>
* <xref:performance/caching/response>
* <xref:performance/caching/middleware>
* <xref:mvc/views/tag-helpers/builtin-th/cache-tag-helper>
* <xref:mvc/views/tag-helpers/builtin-th/distributed-cache-tag-helper>

::: moniker-end
