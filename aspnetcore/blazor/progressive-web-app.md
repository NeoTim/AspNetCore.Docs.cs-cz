---
title: Vytváření progresivních webových Blazor aplikací pomocí ASP.NET základní webové sestavy
author: guardrex
description: Naučte se, jak vytvořit progresivní webovou aplikaci (PWA) založenou Blazorna tom, která používá moderní funkce prohlížeče, aby se chovala jako desktopová aplikace.
monikerRange: '>= aspnetcore-3.1'
ms.author: riande
ms.custom: mvc
ms.date: 03/23/2020
no-loc:
- Blazor
- SignalR
uid: blazor/progressive-web-app
ms.openlocfilehash: fe69e51aefae9c80e5bb4b78151d384ce25d41a7
ms.sourcegitcommit: f7886fd2e219db9d7ce27b16c0dc5901e658d64e
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 04/06/2020
ms.locfileid: "80218944"
---
# <a name="build-progressive-web-applications-with-aspnet-core-blazor-webassembly"></a><span data-ttu-id="cec92-103">Vytváření progresivních webových aplikací s ASP.NET Core Blazor WebAssembly</span><span class="sxs-lookup"><span data-stu-id="cec92-103">Build Progressive Web Applications with ASP.NET Core Blazor WebAssembly</span></span>

<span data-ttu-id="cec92-104">Podle [Steve Sanderson](https://github.com/SteveSandersonMS)</span><span class="sxs-lookup"><span data-stu-id="cec92-104">By [Steve Sanderson](https://github.com/SteveSandersonMS)</span></span>

[!INCLUDE[](~/includes/blazorwasm-preview-notice.md)]

[!INCLUDE[](~/includes/blazorwasm-3.2-template-article-notice.md)]

<span data-ttu-id="cec92-105">Progresivní webová aplikace (PWA) je jednostránková aplikace (SPA), která používá moderní prohlížeče API a možnosti chovat jako desktopové aplikace.</span><span class="sxs-lookup"><span data-stu-id="cec92-105">A Progressive Web Application (PWA) is a Single Page Application (SPA) that uses modern browser APIs and capabilities to behave like a desktop app.</span></span> <span data-ttu-id="cec92-106">Blazor WebAssembly je platforma webových aplikací založená na standardech na straně klienta, takže může používat libovolné rozhraní API prohlížeče, včetně rozhraní PWA API vyžadovaných pro následující funkce:</span><span class="sxs-lookup"><span data-stu-id="cec92-106">Blazor WebAssembly is a standards-based client-side web app platform, so it can use any browser API, including PWA APIs required for the following capabilities:</span></span>

* <span data-ttu-id="cec92-107">Práce offline a okamžité načítání, nezávisle na rychlosti sítě.</span><span class="sxs-lookup"><span data-stu-id="cec92-107">Working offline and loading instantly, independent of network speed.</span></span>
* <span data-ttu-id="cec92-108">Běží ve vlastním okně aplikace, ne jen v okně prohlížeče.</span><span class="sxs-lookup"><span data-stu-id="cec92-108">Running in its own app window, not just a browser window.</span></span>
* <span data-ttu-id="cec92-109">Spuštění z nabídky startování operačního systému hostitele, doku nebo domovské obrazovky.</span><span class="sxs-lookup"><span data-stu-id="cec92-109">Being launched from the host's operating system start menu, dock, or home screen.</span></span>
* <span data-ttu-id="cec92-110">Příjem nabízených oznámení z back-endového serveru, i když uživatel aplikaci nepoužívá.</span><span class="sxs-lookup"><span data-stu-id="cec92-110">Receiving push notifications from a backend server, even while the user isn't using the app.</span></span>
* <span data-ttu-id="cec92-111">Automatická aktualizace na pozadí.</span><span class="sxs-lookup"><span data-stu-id="cec92-111">Automatically updating in the background.</span></span>

<span data-ttu-id="cec92-112">Slovo *progresivní* se používá k popisu těchto aplikací, protože:</span><span class="sxs-lookup"><span data-stu-id="cec92-112">The word *progressive* is used to describe such apps because:</span></span>

* <span data-ttu-id="cec92-113">Uživatel může nejprve objevit a používat aplikaci ve svém webovém prohlížeči jako každý jiný SPA.</span><span class="sxs-lookup"><span data-stu-id="cec92-113">A user might first discover and use the app within their web browser like any other SPA.</span></span>
* <span data-ttu-id="cec92-114">Později uživatel přejde k jeho instalaci do operačního systému a povolení nabízených oznámení.</span><span class="sxs-lookup"><span data-stu-id="cec92-114">Later, the user progresses to installing it in their OS and enabling push notifications.</span></span>

## <a name="create-a-project-from-the-pwa-template"></a><span data-ttu-id="cec92-115">Vytvoření projektu ze šablony pwa</span><span class="sxs-lookup"><span data-stu-id="cec92-115">Create a project from the PWA template</span></span>

# <a name="visual-studio"></a>[<span data-ttu-id="cec92-116">Visual Studio</span><span class="sxs-lookup"><span data-stu-id="cec92-116">Visual Studio</span></span>](#tab/visual-studio)

<span data-ttu-id="cec92-117">Při vytváření nové **aplikace Blazor WebAssembly** v **dialogovém** okně Vytvořit nový projekt zaškrtněte políčko **Progress Web Application:**</span><span class="sxs-lookup"><span data-stu-id="cec92-117">When creating a new **Blazor WebAssembly App** in the **Create a New Project** dialog, select the **Progress Web Application** check box:</span></span>

![Zaškrtávací políčko Progresivní webová aplikace je zaškrtnuto v dialogovém okně nového projektu sady Visual Studio.](progressive-web-app/_static/image1.png)

<!--

# [Visual Studio for Mac](#tab/visual-studio-mac)

-->

# <a name="visual-studio-code--net-core-cli"></a>[<span data-ttu-id="cec92-119">Visual Studio Code / .NET Core CLI</span><span class="sxs-lookup"><span data-stu-id="cec92-119">Visual Studio Code / .NET Core CLI</span></span>](#tab/visual-studio-code+netcore-cli)

<span data-ttu-id="cec92-120">Vytvořte projekt pwa v příkazovém prostředí s přepínačem: `--pwa`</span><span class="sxs-lookup"><span data-stu-id="cec92-120">Create a PWA project in a command shell with the `--pwa` switch:</span></span>

```dotnetcli
dotnet new blazorwasm -o MyNewProject --pwa
```

---

<span data-ttu-id="cec92-121">Volitelně lze aplikaci PWA nakonfigurovat pro aplikaci vytvořenou ze ASP.NET šablonu Hostované jádra.</span><span class="sxs-lookup"><span data-stu-id="cec92-121">Optionally, PWA can be configured for an app created from the ASP.NET Core Hosted template.</span></span> <span data-ttu-id="cec92-122">Scénář PWA je nezávislý na modelu hostování.</span><span class="sxs-lookup"><span data-stu-id="cec92-122">The PWA scenario is independent of the hosting model.</span></span>

## <a name="installation-and-app-manifest"></a><span data-ttu-id="cec92-123">Manifest instalace a aplikace</span><span class="sxs-lookup"><span data-stu-id="cec92-123">Installation and app manifest</span></span>

<span data-ttu-id="cec92-124">Při návštěvě aplikace vytvořené pomocí šablony PWA mají uživatelé možnost nainstalovat aplikaci do nabídky Start, docku nebo domovské obrazovky operačního systému.</span><span class="sxs-lookup"><span data-stu-id="cec92-124">When visiting an app created using the PWA template, users have the option of installing the app into their OS's start menu, dock, or home screen.</span></span> <span data-ttu-id="cec92-125">Způsob, jakým je tato možnost prezentována, závisí na prohlížeči uživatele.</span><span class="sxs-lookup"><span data-stu-id="cec92-125">The way this option is presented depends on the user's browser.</span></span> <span data-ttu-id="cec92-126">Při používání prohlížečů založených na chromu na ploše, jako je Edge nebo Chrome, se na panelu URL zobrazí tlačítko **Přidat.**</span><span class="sxs-lookup"><span data-stu-id="cec92-126">When using desktop Chromium-based browsers, such as Edge or Chrome, an **Add** button appears within the URL bar.</span></span> <span data-ttu-id="cec92-127">Poté, co uživatel vybere tlačítko **Přidat,** obdrží potvrzovací dialog:</span><span class="sxs-lookup"><span data-stu-id="cec92-127">After the user selects the **Add** button, they receive a confirmation dialog:</span></span>

![Potvrzovací diaglog v prohlížeči Google Chrome představuje tlačítko Instalovat uživateli pro aplikaci "MyBlazorPwa".](progressive-web-app/_static/image2.png)

<span data-ttu-id="cec92-129">V systému iOS mohou návštěvníci nainstalovat aplikaci PWA pomocí tlačítka **Sdílení** safari a možnosti **Přidat na domovskou obrazovku.**</span><span class="sxs-lookup"><span data-stu-id="cec92-129">On iOS, visitors can install the PWA using Safari's **Share** button and its **Add to Homescreen** option.</span></span> <span data-ttu-id="cec92-130">V Chromu pro Android by uživatelé měli vybrat tlačítko **Menu** v pravém horním rohu, následované **add to home screen**.</span><span class="sxs-lookup"><span data-stu-id="cec92-130">On Chrome for Android, users should select the **Menu** button in the upper-right corner, followed by **Add to Home screen**.</span></span>

<span data-ttu-id="cec92-131">Po instalaci se aplikace zobrazí ve vlastním okně bez adresního řádku:</span><span class="sxs-lookup"><span data-stu-id="cec92-131">Once installed, the app appears in its own window without an address bar:</span></span>

![Aplikace "MyBlazorPwa" běží v prohlížeči Google Chrome bez adresního řádku.](progressive-web-app/_static/image3.png)

<span data-ttu-id="cec92-133">Chcete-li přizpůsobit název okna, barevné schéma, ikonu nebo jiné podrobnosti, podívejte se na soubor *manifest.json* v adresáři *wwwroot* projektu.</span><span class="sxs-lookup"><span data-stu-id="cec92-133">To customize the window's title, color scheme, icon, or other details, see the *manifest.json* file in the project's *wwwroot* directory.</span></span> <span data-ttu-id="cec92-134">Schéma tohoto souboru je definováno webovými standardy.</span><span class="sxs-lookup"><span data-stu-id="cec92-134">The schema of this file is defined by web standards.</span></span> <span data-ttu-id="cec92-135">Další informace naleznete v [tématu MDN web docs: Web App Manifest](https://developer.mozilla.org/docs/Web/Manifest).</span><span class="sxs-lookup"><span data-stu-id="cec92-135">For more information, see [MDN web docs: Web App Manifest](https://developer.mozilla.org/docs/Web/Manifest).</span></span>

## <a name="offline-support"></a><span data-ttu-id="cec92-136">Podpora offline</span><span class="sxs-lookup"><span data-stu-id="cec92-136">Offline support</span></span>

<span data-ttu-id="cec92-137">Ve výchozím nastavení mají aplikace vytvořené pomocí možnosti šablony PWA podporu pro spouštění offline.</span><span class="sxs-lookup"><span data-stu-id="cec92-137">By default, apps created using the PWA template option have support for running offline.</span></span> <span data-ttu-id="cec92-138">Uživatel musí nejprve navštívit aplikaci, když je online.</span><span class="sxs-lookup"><span data-stu-id="cec92-138">A user must first visit the app while they're online.</span></span> <span data-ttu-id="cec92-139">Prohlížeč automaticky stáhne a uloží do mezipaměti všechny prostředky potřebné k provozu offline.</span><span class="sxs-lookup"><span data-stu-id="cec92-139">The browser automatically downloads and caches all of the resources required to operate offline.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="cec92-140">Rozvojová podpora by narušila obvyklý vývojový cyklus provádění změn a jejich testování.</span><span class="sxs-lookup"><span data-stu-id="cec92-140">Development support would interfere with the usual development cycle of making changes and testing them.</span></span> <span data-ttu-id="cec92-141">Proto je podpora offline povolena pouze pro *publikované* aplikace.</span><span class="sxs-lookup"><span data-stu-id="cec92-141">Therefore, offline support is only enabled for *published* apps.</span></span> 

> [!WARNING]
> <span data-ttu-id="cec92-142">Pokud máte v úmyslu distribuovat offline povoleno uda, existuje [několik důležitých upozornění a upozornění](#caveats-for-offline-pwas).</span><span class="sxs-lookup"><span data-stu-id="cec92-142">If you intend to distribute an offline-enabled PWA, there are [several important warnings and caveats](#caveats-for-offline-pwas).</span></span> <span data-ttu-id="cec92-143">Tyto scénáře jsou vlastní offline PWA Blazora nejsou specifické pro .</span><span class="sxs-lookup"><span data-stu-id="cec92-143">These scenarios are inherent to offline PWAs and not specific to Blazor.</span></span> <span data-ttu-id="cec92-144">Nezapomeňte si přečíst a pochopit tyto upozornění před provedením předpoklady o tom, jak bude aplikace s podporou offline fungovat.</span><span class="sxs-lookup"><span data-stu-id="cec92-144">Be sure to read and understand these caveats before making assumptions about how your offline-enabled app will work.</span></span>

<span data-ttu-id="cec92-145">Jak funguje offline podpora:</span><span class="sxs-lookup"><span data-stu-id="cec92-145">To see how offline support works:</span></span>

1. <span data-ttu-id="cec92-146">Publikujte aplikaci.</span><span class="sxs-lookup"><span data-stu-id="cec92-146">Publish the app.</span></span> <span data-ttu-id="cec92-147">Další informace naleznete v tématu <xref:host-and-deploy/blazor/index#publish-the-app>.</span><span class="sxs-lookup"><span data-stu-id="cec92-147">For more information, see <xref:host-and-deploy/blazor/index#publish-the-app>.</span></span>
1. <span data-ttu-id="cec92-148">Nasaďte aplikaci na server, který podporuje protokol HTTPS, a získejte přístup k aplikaci v prohlížeči na zabezpečené adrese HTTPS.</span><span class="sxs-lookup"><span data-stu-id="cec92-148">Deploy the app to a server that supports HTTPS, and access the app in a browser at its secure HTTPS address.</span></span>
1. <span data-ttu-id="cec92-149">Otevřete vývojářské nástroje prohlížeče a ověřte, zda je pro hostitele registrován *pracovník služby* na kartě **Aplikace:**</span><span class="sxs-lookup"><span data-stu-id="cec92-149">Open the browser's dev tools and verify that a *Service Worker* is registered for the host on the **Application** tab:</span></span>

   ![Google Chrome vývojářské nástroje 'Aplikace' karta zobrazuje servisní pracovník aktivován a běží.](progressive-web-app/_static/image4.png)

1. <span data-ttu-id="cec92-151">Znovu načtěte stránku a **Service Worker** zkontrolujte **memory cache** kartu **Síť.**</span><span class="sxs-lookup"><span data-stu-id="cec92-151">Reload the page and examine the **Network** tab. **Service Worker** or **memory cache** are listed as the sources for all of the page's assets:</span></span>

   ![Google Chrome vývojářské nástroje 'Síť' karta zobrazující zdroje pro všechny stránky podkladů.](progressive-web-app/_static/image5.png)

1. <span data-ttu-id="cec92-153">Chcete-li ověřit, že prohlížeč není závislý na přístupu k síti pro načtení aplikace, buď:</span><span class="sxs-lookup"><span data-stu-id="cec92-153">To verify that the browser isn't dependent on network access to load the app, either:</span></span>

   * <span data-ttu-id="cec92-154">Vypněte webový server a podívejte se, jak aplikace nadále funguje normálně, což zahrnuje opětovné načtení stránky.</span><span class="sxs-lookup"><span data-stu-id="cec92-154">Shut down the web server and see how the app continues to function normally, which includes page reloads.</span></span> <span data-ttu-id="cec92-155">Stejně tak aplikace nadále fungovat normálně, když je pomalé připojení k síti.</span><span class="sxs-lookup"><span data-stu-id="cec92-155">Likewise, the app continues to function normally when there's a slow network connection.</span></span>
   * <span data-ttu-id="cec92-156">Na kartě **Síť** můžete prohlížeči dát pokyn k simulaci režimu offline:</span><span class="sxs-lookup"><span data-stu-id="cec92-156">Instruct the browser to simulate offline mode in the **Network** tab:</span></span>

   ![Google Chrome vývojářské nástroje 'Síť' kartu s režimem prohlížeče dropdown se mění z 'Online' na 'Offline'.](progressive-web-app/_static/image6.png)

<span data-ttu-id="cec92-158">Podpora offline pomocí servisního pracovníka je Blazorwebový standard, který není specifický pro aplikaci .</span><span class="sxs-lookup"><span data-stu-id="cec92-158">Offline support using a service worker is a web standard, not specific to Blazor.</span></span> <span data-ttu-id="cec92-159">Další informace o servisních pracovnících naleznete v [tématu MDN web docs: Service Worker API](https://developer.mozilla.org/docs/Web/API/Service_Worker_API).</span><span class="sxs-lookup"><span data-stu-id="cec92-159">For more information on service workers, see [MDN web docs: Service Worker API](https://developer.mozilla.org/docs/Web/API/Service_Worker_API).</span></span> <span data-ttu-id="cec92-160">Další informace o běžných vzorcích používání pracovníků služeb naleznete v [tématu Web Google: Životní cyklus servisního pracovníka](https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle).</span><span class="sxs-lookup"><span data-stu-id="cec92-160">To learn more about common usage patterns for service workers, see [Google Web: The Service Worker Lifecycle](https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle).</span></span>

Blazor<span data-ttu-id="cec92-161">Šablona PWA společnosti vytváří dva soubory servisních pracovníků:</span><span class="sxs-lookup"><span data-stu-id="cec92-161">'s PWA template produces two service worker files:</span></span>

* <span data-ttu-id="cec92-162">*wwwroot/service-worker.js*, který se používá během vývoje.</span><span class="sxs-lookup"><span data-stu-id="cec92-162">*wwwroot/service-worker.js*, which is used during development.</span></span>
* <span data-ttu-id="cec92-163">*wwwroot/service-worker.published.js*, který se používá po publikování aplikace.</span><span class="sxs-lookup"><span data-stu-id="cec92-163">*wwwroot/service-worker.published.js*, which is used after the app is published.</span></span>

<span data-ttu-id="cec92-164">Chcete-li sdílet logiku mezi dvěma soubory pracovníka služby, zvažte následující přístup:</span><span class="sxs-lookup"><span data-stu-id="cec92-164">To share logic between the two service worker files, consider the following approach:</span></span>

* <span data-ttu-id="cec92-165">Přidejte třetí soubor JavaScriptu, který bude obsahovat společnou logiku.</span><span class="sxs-lookup"><span data-stu-id="cec92-165">Add a third JavaScript file to hold the common logic.</span></span>
* <span data-ttu-id="cec92-166">Pomocí [self.importScripts](https://developer.mozilla.org/docs/Web/API/WorkerGlobalScope/importScripts) načtěte společnou logiku do obou souborů servisních pracovníků.</span><span class="sxs-lookup"><span data-stu-id="cec92-166">Use [self.importScripts](https://developer.mozilla.org/docs/Web/API/WorkerGlobalScope/importScripts) to load the common logic into both service worker files.</span></span>

### <a name="cache-first-fetch-strategy"></a><span data-ttu-id="cec92-167">Strategie načítání první cache</span><span class="sxs-lookup"><span data-stu-id="cec92-167">Cache-first fetch strategy</span></span>

<span data-ttu-id="cec92-168">Předdefinovaný pracovník *služby.published.js* řeší požadavky pomocí strategie *první mezipaměti.*</span><span class="sxs-lookup"><span data-stu-id="cec92-168">The built-in *service-worker.published.js* service worker resolves requests using a *cache-first* strategy.</span></span> <span data-ttu-id="cec92-169">To znamená, že pracovník služby upřednostňuje vrácení obsahu uloženého v mezipaměti bez ohledu na to, zda má uživatel přístup k síti nebo je na serveru k dispozici novější obsah.</span><span class="sxs-lookup"><span data-stu-id="cec92-169">This means that the service worker prefers to return cached content, regardless of whether the user has network access or newer content is available on the server.</span></span>

<span data-ttu-id="cec92-170">Strategie první cache je cenná, protože:</span><span class="sxs-lookup"><span data-stu-id="cec92-170">The cache-first strategy is valuable because:</span></span>

* <span data-ttu-id="cec92-171">**Zajišťuje spolehlivost.**</span><span class="sxs-lookup"><span data-stu-id="cec92-171">**It ensures reliability.**</span></span> <span data-ttu-id="cec92-172">&ndash;Přístup k síti není logický stav.</span><span class="sxs-lookup"><span data-stu-id="cec92-172">&ndash; Network access isn't a boolean state.</span></span> <span data-ttu-id="cec92-173">Uživatel není jednoduše online nebo offline:</span><span class="sxs-lookup"><span data-stu-id="cec92-173">A user isn't simply online or offline:</span></span>

  * <span data-ttu-id="cec92-174">Zařízení uživatele může předpokládat, že je online, ale síť může být tak pomalá, že je nepraktická.</span><span class="sxs-lookup"><span data-stu-id="cec92-174">The user's device may assume it's online, but the network might be so slow as to be impractical to wait for.</span></span>
  * <span data-ttu-id="cec92-175">Síť může vrátit neplatné výsledky pro určité adresy URL, například když je závislý portál WIFI, který v současné době blokuje nebo přesměrovává určité požadavky.</span><span class="sxs-lookup"><span data-stu-id="cec92-175">The network might return invalid results for certain URLs, such as when there's a captive WIFI portal that's currently blocking or redirecting certain requests.</span></span>
  
  <span data-ttu-id="cec92-176">To je důvod, `navigator.onLine` proč rozhraní API prohlížeče není spolehlivé a nemělo by být závislé.</span><span class="sxs-lookup"><span data-stu-id="cec92-176">This is why the browser's `navigator.onLine` API isn't reliable and shouldn't be depended upon.</span></span>

* <span data-ttu-id="cec92-177">**Zajišťuje správnost.**</span><span class="sxs-lookup"><span data-stu-id="cec92-177">**It ensures correctness.**</span></span> <span data-ttu-id="cec92-178">&ndash;Při vytváření mezipaměti offline prostředků, pracovník služby používá hash obsahu zaručit, že načte kompletní a samokonzistentní snímek prostředků v jednom okamžiku v čase.</span><span class="sxs-lookup"><span data-stu-id="cec92-178">&ndash; When building a cache of offline resources, the service worker uses content hashing to guarantee it has fetched a complete and self-consistent snapshot of resources at a single instant in time.</span></span> <span data-ttu-id="cec92-179">Tato mezipaměť se pak používá jako atomická jednotka.</span><span class="sxs-lookup"><span data-stu-id="cec92-179">This cache is then used as an atomic unit.</span></span> <span data-ttu-id="cec92-180">Nemá smysl žádat síť o novější zdroje, protože jediné požadované verze jsou ty, které již byly uloženy v mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="cec92-180">There's no point asking the network for newer resources, since the only versions required are the ones already cached.</span></span> <span data-ttu-id="cec92-181">Cokoli jiného riskuje nekonzistenci a nekompatibilitu (například při pokusu o použití verzí sestavení .NET, které nebyly zkompilovány společně).</span><span class="sxs-lookup"><span data-stu-id="cec92-181">Anything else risks inconsistency and incompatibility (for example, trying to use versions of .NET assemblies that weren't compiled together).</span></span>

### <a name="background-updates"></a><span data-ttu-id="cec92-182">Aktualizace na pozadí</span><span class="sxs-lookup"><span data-stu-id="cec92-182">Background updates</span></span>

<span data-ttu-id="cec92-183">Jako mentální model si můžete myslet, že offline aplikace PWA se chová jako mobilní aplikace, kterou lze nainstalovat.</span><span class="sxs-lookup"><span data-stu-id="cec92-183">As a mental model, you can think of an offline-first PWA as behaving like a mobile app that can be installed.</span></span> <span data-ttu-id="cec92-184">Aplikace se spustí okamžitě bez ohledu na připojení k síti, ale nainstalované aplikace logika pochází z point-in-time snímek, který nemusí být nejnovější verze.</span><span class="sxs-lookup"><span data-stu-id="cec92-184">The app starts up immediately regardless of network connectivity, but the installed app logic comes from a point-in-time snapshot that might not be the latest version.</span></span>

<span data-ttu-id="cec92-185">Šablona Blazor PWA vytváří aplikace, které se automaticky pokoušejí aktualizovat na pozadí, kdykoli uživatel navštíví a má funkční síťové připojení.</span><span class="sxs-lookup"><span data-stu-id="cec92-185">The Blazor PWA template produces apps that automatically try to update themselves in the background whenever the user visits and has a working network connection.</span></span> <span data-ttu-id="cec92-186">Způsob, jakým to funguje, je následující:</span><span class="sxs-lookup"><span data-stu-id="cec92-186">The way this works is as follows:</span></span>

* <span data-ttu-id="cec92-187">Během kompilace projekt generuje *manifest prostředků servisního pracovníka*.</span><span class="sxs-lookup"><span data-stu-id="cec92-187">During compilation, the project generates a *service worker assets manifest*.</span></span> <span data-ttu-id="cec92-188">Ve výchozím nastavení se nazývá *service-worker-assets.js*.</span><span class="sxs-lookup"><span data-stu-id="cec92-188">By default, this is called *service-worker-assets.js*.</span></span> <span data-ttu-id="cec92-189">Manifest obsahuje seznam všech statických prostředků, které aplikace potřebuje k fungování offline, například sestavení .NET, soubory JavaScript a CSS, včetně jejich hodnot hash obsahu.</span><span class="sxs-lookup"><span data-stu-id="cec92-189">The manifest lists all the static resources that the app requires to function offline, such as .NET assemblies, JavaScript files, and CSS, including their content hashes.</span></span> <span data-ttu-id="cec92-190">Seznam prostředků je načten pracovníkem služby tak, aby věděl, které prostředky do mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="cec92-190">The resource list is loaded by the service worker so that it knows which resources to cache.</span></span>
* <span data-ttu-id="cec92-191">Pokaždé, když uživatel navštíví aplikaci, prohlížeč znovu požádá *service-worker.js* a *service-worker-assets.js* na pozadí.</span><span class="sxs-lookup"><span data-stu-id="cec92-191">Each time the user visits the app, the browser re-requests *service-worker.js* and *service-worker-assets.js* in the background.</span></span> <span data-ttu-id="cec92-192">Soubory jsou porovnány bajt pro bajt s existujícím nainstalovaným servisním pracovníkem.</span><span class="sxs-lookup"><span data-stu-id="cec92-192">The files are compared byte-for-byte with the existing installed service worker.</span></span> <span data-ttu-id="cec92-193">Pokud server vrátí změněný obsah pro některý z těchto souborů, pracovník služby se pokusí nainstalovat novou verzi sebe sama.</span><span class="sxs-lookup"><span data-stu-id="cec92-193">If the server returns changed content for either of these files, the service worker attempts to install a new version of itself.</span></span>
* <span data-ttu-id="cec92-194">Při instalaci nové verze sebe sama vytvoří pracovník služby novou samostatnou mezipaměť pro offline prostředky a spustí vyplnění mezipaměti prostředky uvedenými v *souboru service-worker-assets.js*.</span><span class="sxs-lookup"><span data-stu-id="cec92-194">When installing a new version of itself, the service worker creates a new, separate cache for offline resources and starts populating the cache with resources listed in *service-worker-assets.js*.</span></span> <span data-ttu-id="cec92-195">Tato logika je `onInstall` implementována ve funkci uvnitř *service-worker.published.js*.</span><span class="sxs-lookup"><span data-stu-id="cec92-195">This logic is implemented in the `onInstall` function inside *service-worker.published.js*.</span></span>
* <span data-ttu-id="cec92-196">Proces se úspěšně dokončí, když jsou načteny všechny prostředky bez chyby a všechny hashy obsahu odpovídají.</span><span class="sxs-lookup"><span data-stu-id="cec92-196">The process completes successfully when all of the resources are loaded without error and all content hashes match.</span></span> <span data-ttu-id="cec92-197">Pokud je úspěšná, nový pracovník služby přejde čekání na stav *aktivace.*</span><span class="sxs-lookup"><span data-stu-id="cec92-197">If successful, the new service worker enters a *waiting for activation* state.</span></span> <span data-ttu-id="cec92-198">Jakmile uživatel aplikaci zavře (žádné zbývající karty aplikace nebo okna), *nový* pracovník služby se aktivuje a použije se pro následné návštěvy aplikací.</span><span class="sxs-lookup"><span data-stu-id="cec92-198">As soon as the user closes the app (no remaining app tabs or windows), the new service worker becomes *active* and is used for subsequent app visits.</span></span> <span data-ttu-id="cec92-199">Starý pracovník služby a jeho mezipaměť jsou odstraněny.</span><span class="sxs-lookup"><span data-stu-id="cec92-199">The old service worker and its cache are deleted.</span></span>
* <span data-ttu-id="cec92-200">Pokud proces není úspěšně dokončen, je zahozena instance nového servisního pracovníka.</span><span class="sxs-lookup"><span data-stu-id="cec92-200">If the process doesn't complete successfully, the new service worker instance is discarded.</span></span> <span data-ttu-id="cec92-201">Proces aktualizace je pokus znovu na další návštěvu uživatele, když doufejme, že klient má lepší síťové připojení, které lze dokončit požadavky.</span><span class="sxs-lookup"><span data-stu-id="cec92-201">The update process is attempted again on the user's next visit, when hopefully the client has a better network connection that can complete the requests.</span></span>

<span data-ttu-id="cec92-202">Přizpůsobte tento proces úpravou logiky servisního pracovníka.</span><span class="sxs-lookup"><span data-stu-id="cec92-202">Customize this process by editing the service worker logic.</span></span> <span data-ttu-id="cec92-203">Žádné z předchozích chování Blazor je specifické, ale je pouze výchozí prostředí poskytované možnosti šablony PWA.</span><span class="sxs-lookup"><span data-stu-id="cec92-203">None of the preceding behavior is specific to Blazor but is merely the default experience provided by the PWA template option.</span></span> <span data-ttu-id="cec92-204">Další informace naleznete v [tématu MDN web docs: Service Worker API](https://developer.mozilla.org/docs/Web/API/Service_Worker_API).</span><span class="sxs-lookup"><span data-stu-id="cec92-204">For more information, see [MDN web docs: Service Worker API](https://developer.mozilla.org/docs/Web/API/Service_Worker_API).</span></span>

### <a name="how-requests-are-resolved"></a><span data-ttu-id="cec92-205">Jak jsou požadavky vyřešeny</span><span class="sxs-lookup"><span data-stu-id="cec92-205">How requests are resolved</span></span>

<span data-ttu-id="cec92-206">Jak je popsáno v části [Strategie načítání první cache,](#cache-first-fetch-strategy) výchozí pracovník služby používá strategii *první cache,* což znamená, že se pokusí poskytovat obsah uložený v mezipaměti, pokud je k dispozici.</span><span class="sxs-lookup"><span data-stu-id="cec92-206">As described in the [Cache-first fetch strategy](#cache-first-fetch-strategy) section, the default service worker uses a *cache-first* strategy, meaning that it tries to serve cached content when available.</span></span> <span data-ttu-id="cec92-207">Pokud není k dispozici žádný obsah uložený v mezipaměti pro určitou adresu URL, například při vyžádání dat z rozhraní API back-endu, pracovník služby se vrátí k pravidelnému síťovému požadavku.</span><span class="sxs-lookup"><span data-stu-id="cec92-207">If there is no content cached for a certain URL, for example when requesting data from a backend API, the service worker falls back on a regular network request.</span></span> <span data-ttu-id="cec92-208">Požadavek na síť je úspěšný, pokud je server dostupný.</span><span class="sxs-lookup"><span data-stu-id="cec92-208">The network request succeeds if the server is reachable.</span></span> <span data-ttu-id="cec92-209">Tato logika `onFetch` je implementována uvnitř funkce v rámci *service-worker.published.js*.</span><span class="sxs-lookup"><span data-stu-id="cec92-209">This logic is implemented inside `onFetch` function within *service-worker.published.js*.</span></span>

<span data-ttu-id="cec92-210">Pokud komponenty Razor aplikace spoléhají na vyžádání dat z rozhraní API back-endu a chcete poskytnout popisné uživatelské prostředí pro neúspěšné požadavky z důvodu nedostupnosti sítě, implementujte logiku v rámci komponent aplikace.</span><span class="sxs-lookup"><span data-stu-id="cec92-210">If the app's Razor components rely on requesting data from backend APIs and you want to provide a friendly user experience for failed requests due to network unavailability, implement logic within the app's components.</span></span> <span data-ttu-id="cec92-211">Můžete například `try/catch` `HttpClient` použít kolem požadavků.</span><span class="sxs-lookup"><span data-stu-id="cec92-211">For example, use `try/catch` around `HttpClient` requests.</span></span>

### <a name="support-server-rendered-pages"></a><span data-ttu-id="cec92-212">Podpora stránek vykreslených serverem</span><span class="sxs-lookup"><span data-stu-id="cec92-212">Support server-rendered pages</span></span>

<span data-ttu-id="cec92-213">Zvažte, co se stane, když uživatel `/counter` poprvé přejde na adresu URL, jako je například nebo jakýkoli jiný přímý odkaz v aplikaci.</span><span class="sxs-lookup"><span data-stu-id="cec92-213">Consider what happens when the user first navigates to a URL such as `/counter` or any other deep link in the app.</span></span> <span data-ttu-id="cec92-214">V těchto případech nechcete vracet obsah uložený `/counter`v mezipaměti jako , ale místo `/index.html` toho potřebujete Blazor prohlížeč k načtení obsahu uloženého v mezipaměti, aby bylo nutné spustit aplikaci WebAssembly.</span><span class="sxs-lookup"><span data-stu-id="cec92-214">In these cases, you don't want to return content cached as `/counter`, but instead need the browser to load the content cached as `/index.html` to start up your Blazor WebAssembly app.</span></span> <span data-ttu-id="cec92-215">Tyto počáteční požadavky jsou označovány jako *navigační* požadavky, na rozdíl od:</span><span class="sxs-lookup"><span data-stu-id="cec92-215">These initial requests are known as *navigation* requests, as opposed to:</span></span>

* <span data-ttu-id="cec92-216">*požadavky na dílčí zdroje* pro obrazy, šablony stylů nebo jiné soubory.</span><span class="sxs-lookup"><span data-stu-id="cec92-216">*subresource* requests for images, stylesheets, or other files.</span></span>
* <span data-ttu-id="cec92-217">*načíst/XHR* požadavky na data rozhraní API.</span><span class="sxs-lookup"><span data-stu-id="cec92-217">*fetch/XHR* requests for API data.</span></span>

<span data-ttu-id="cec92-218">Výchozí pracovník služby obsahuje logiku zvláštního případu pro navigační požadavky.</span><span class="sxs-lookup"><span data-stu-id="cec92-218">The default service worker contains special-case logic for navigation requests.</span></span> <span data-ttu-id="cec92-219">Pracovník služby vyřeší požadavky vrácením obsahu uloženého `/index.html`v mezipaměti pro , bez ohledu na požadovanou adresu URL.</span><span class="sxs-lookup"><span data-stu-id="cec92-219">The service worker resolves the requests by returning the cached content for `/index.html`, regardless of the requested URL.</span></span> <span data-ttu-id="cec92-220">Tato logika je `onFetch` implementována ve funkci uvnitř *service-worker.published.js*.</span><span class="sxs-lookup"><span data-stu-id="cec92-220">This logic is implemented in the `onFetch` function inside *service-worker.published.js*.</span></span>

<span data-ttu-id="cec92-221">Pokud vaše aplikace obsahuje určité adresy URL, které musí vrátit `/index.html` serverem vykreslené HTML a neslouží z mezipaměti, pak je třeba upravit logiku v pracovníkovi služby.</span><span class="sxs-lookup"><span data-stu-id="cec92-221">If your app has certain URLs that must return server-rendered HTML, and not serve `/index.html` from the cache, then you need to edit the logic in your service worker.</span></span> <span data-ttu-id="cec92-222">Pokud všechny adresy URL `/Identity/` obsahující je třeba zpracovat jako pravidelné požadavky pouze online na server, upravte *logiku service-worker.published.js.* `onFetch`</span><span class="sxs-lookup"><span data-stu-id="cec92-222">If all URLs containing `/Identity/` need to be handled as regular online-only requests to the server, then modify *service-worker.published.js* `onFetch` logic.</span></span> <span data-ttu-id="cec92-223">Vyhledejte následující kód:</span><span class="sxs-lookup"><span data-stu-id="cec92-223">Locate the following code:</span></span>

```javascript
const shouldServeIndexHtml = event.request.mode === 'navigate';
```

<span data-ttu-id="cec92-224">Změňte kód na následující:</span><span class="sxs-lookup"><span data-stu-id="cec92-224">Change the code to the following:</span></span>

```javascript
const shouldServeIndexHtml = event.request.mode === 'navigate'
    && !event.request.url.includes('/Identity/');
```

<span data-ttu-id="cec92-225">Pokud tak neučiníte, pak bez ohledu na připojení k síti pracovník služby zachytí požadavky `/index.html`na tyto adresy URL a vyřeší je pomocí .</span><span class="sxs-lookup"><span data-stu-id="cec92-225">If you don't do this, then regardless of network connectivity, the service worker intercepts requests for such URLs and resolves them using `/index.html`.</span></span>

### <a name="control-asset-caching"></a><span data-ttu-id="cec92-226">Řízení ukládání majetku do mezipaměti</span><span class="sxs-lookup"><span data-stu-id="cec92-226">Control asset caching</span></span>

<span data-ttu-id="cec92-227">Pokud váš projekt `ServiceWorkerAssetsManifest` definuje vlastnost MSBuild, Blazornástroj sestavení sestavení společnosti generuje manifest prostředků pracovníka služby se zadaným názvem.</span><span class="sxs-lookup"><span data-stu-id="cec92-227">If your project defines the `ServiceWorkerAssetsManifest` MSBuild property, Blazor's build tooling generates a service worker assets manifest with the specified name.</span></span> <span data-ttu-id="cec92-228">Výchozí šablona aplikace PWA vytvoří soubor projektu obsahující následující vlastnost:</span><span class="sxs-lookup"><span data-stu-id="cec92-228">The default PWA template produces a project file containing the following property:</span></span>

```xml
<ServiceWorkerAssetsManifest>service-worker-assets.js</ServiceWorkerAssetsManifest>
```

<span data-ttu-id="cec92-229">Soubor je umístěn do výstupního *adresáře wwwroot,* takže prohlížeč `/service-worker-assets.js`může načíst tento soubor vyžádáním .</span><span class="sxs-lookup"><span data-stu-id="cec92-229">The file is placed in the *wwwroot* output directory, so the browser can retrieve this file by requesting `/service-worker-assets.js`.</span></span> <span data-ttu-id="cec92-230">Chcete-li zobrazit obsah tohoto souboru, otevřete */bin/Debug/{TARGET FRAMEWORK}/wwwroot/service-worker-assets.js* v textovém editoru.</span><span class="sxs-lookup"><span data-stu-id="cec92-230">To see the contents of this file, open */bin/Debug/{TARGET FRAMEWORK}/wwwroot/service-worker-assets.js* in a text editor.</span></span> <span data-ttu-id="cec92-231">Neupravujte však soubor, protože je znovu vygenerován v každém sestavení.</span><span class="sxs-lookup"><span data-stu-id="cec92-231">However, don't edit the file, as it's regenerated on each build.</span></span>

<span data-ttu-id="cec92-232">Ve výchozím nastavení tento manifest uvádí:</span><span class="sxs-lookup"><span data-stu-id="cec92-232">By default, this manifest lists:</span></span>

* <span data-ttu-id="cec92-233">Všechny Blazorspravované prostředky, například sestavení .NET a runtime soubory .NET WebAssembly potřebné k fungování offline.</span><span class="sxs-lookup"><span data-stu-id="cec92-233">Any Blazor-managed resources, such as .NET assemblies and the .NET WebAssembly runtime files required to function offline.</span></span>
* <span data-ttu-id="cec92-234">Všechny prostředky pro publikování do adresáře *wwwroot* aplikace, jako jsou obrázky, styly a soubory JavaScript, včetně statických webových datových zdrojů dodávaných externími projekty a balíčky NuGet.</span><span class="sxs-lookup"><span data-stu-id="cec92-234">All resources for publishing to the app's *wwwroot* directory, such as images, stylesheets, and JavaScript files, including static web assets supplied by external projects and NuGet packages.</span></span>

<span data-ttu-id="cec92-235">Můžete určit, které z těchto prostředků jsou načteny a uloženy `onInstall` do mezipaměti pracovníka služby úpravou logiky v *service-worker.published.js*.</span><span class="sxs-lookup"><span data-stu-id="cec92-235">You can control which of these resources are fetched and cached by the service worker by editing the logic in `onInstall` in *service-worker.published.js*.</span></span> <span data-ttu-id="cec92-236">Ve výchozím nastavení pracovník služby načítá a ukládá soubory odpovídající typickým příponek webových souborů, například *.html* Blazor , *.css*, *.js*a *.wasm*, plus typy souborů specifické pro WebAssembly (*DLL*, *.pdb*).</span><span class="sxs-lookup"><span data-stu-id="cec92-236">By default, the service worker fetches and caches files matching typical web filename extensions such as *.html*, *.css*, *.js*, and *.wasm*, plus file types specific to Blazor WebAssembly (*.dll*, *.pdb*).</span></span>

<span data-ttu-id="cec92-237">Chcete-li zahrnout další prostředky, které nejsou k dispozici v adresáři `ItemGroup` *wwwroot* aplikace, definujte další položky MSBuild, jak je znázorněno v následujícím příkladu:</span><span class="sxs-lookup"><span data-stu-id="cec92-237">To include additional resources that aren't present in the app's *wwwroot* directory, define extra MSBuild `ItemGroup` entries, as shown in the following example:</span></span>

```xml
<ItemGroup>
  <ServiceWorkerAssetsManifestItem Include="MyDirectory\AnotherFile.json"
    RelativePath="MyDirectory\AnotherFile.json" AssetUrl="files/AnotherFile.json" />
</ItemGroup>
```

<span data-ttu-id="cec92-238">Metadata `AssetUrl` určují adresu URL základní relativní, kterou by měl prohlížeč použít při načítání prostředku do mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="cec92-238">The `AssetUrl` metadata specifies the base-relative URL that the browser should use when fetching the resource to cache.</span></span> <span data-ttu-id="cec92-239">To může být nezávislé na jeho původní název zdrojového souboru na disku.</span><span class="sxs-lookup"><span data-stu-id="cec92-239">This can be independent of its original source file name on disk.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="cec92-240">Přidání `ServiceWorkerAssetsManifestItem` a nezpůsobí, že soubor bude publikován v adresáři *wwwroot* aplikace.</span><span class="sxs-lookup"><span data-stu-id="cec92-240">Adding a `ServiceWorkerAssetsManifestItem` doesn't cause the file to be published in the app's *wwwroot* directory.</span></span> <span data-ttu-id="cec92-241">Výstup publikování musí být řízen samostatně.</span><span class="sxs-lookup"><span data-stu-id="cec92-241">The publish output must be controlled separately.</span></span> <span data-ttu-id="cec92-242">Pouze `ServiceWorkerAssetsManifestItem` způsobí, že další položka se zobrazí v manifestu služby pracovníka.</span><span class="sxs-lookup"><span data-stu-id="cec92-242">The `ServiceWorkerAssetsManifestItem` only causes an additional entry to appear in the service worker assets manifest.</span></span>

## <a name="push-notifications"></a><span data-ttu-id="cec92-243">Nabízená oznámení</span><span class="sxs-lookup"><span data-stu-id="cec92-243">Push notifications</span></span>

<span data-ttu-id="cec92-244">Stejně jako všechny Blazor ostatní pwa, WebAssembly PWA může přijímat nabízená oznámení z back-endového serveru.</span><span class="sxs-lookup"><span data-stu-id="cec92-244">Like any other PWA, a Blazor WebAssembly PWA can receive push notifications from a backend server.</span></span> <span data-ttu-id="cec92-245">Server může odesílat nabízená oznámení kdykoli, i když uživatel aplikaci aktivně nepoužívá.</span><span class="sxs-lookup"><span data-stu-id="cec92-245">The server can send push notifications at any time, even when the user isn't actively using the app.</span></span> <span data-ttu-id="cec92-246">Nabízená oznámení lze například odeslat, když jiný uživatel provede příslušnou akci.</span><span class="sxs-lookup"><span data-stu-id="cec92-246">For example, push notifications can be sent when a different user performs a relevant action.</span></span>

<span data-ttu-id="cec92-247">Mechanismus pro odesílání nabízených oznámení je Blazor zcela nezávislý na webassembly, protože je implementován back-endserver, který může používat libovolnou technologii.</span><span class="sxs-lookup"><span data-stu-id="cec92-247">The mechanism for sending a push notification is entirely independent of Blazor WebAssembly, since it's implemented by the backend server which can use any technology.</span></span> <span data-ttu-id="cec92-248">Pokud chcete odesílat nabízená oznámení ze serveru ASP.NET Core, zvažte [použití techniky podobné přístupu přijatému v dílně Blazing Pizza](https://github.com/dotnet-presentations/blazor-workshop/blob/master/docs/09-progressive-web-app.md#sending-push-notifications).</span><span class="sxs-lookup"><span data-stu-id="cec92-248">If you want to send push notifications from an ASP.NET Core server, consider [using a technique similar to the approach taken in the Blazing Pizza workshop](https://github.com/dotnet-presentations/blazor-workshop/blob/master/docs/09-progressive-web-app.md#sending-push-notifications).</span></span>

<span data-ttu-id="cec92-249">Mechanismus pro příjem a zobrazení nabízeného oznámení na Blazor straně klienta je také nezávislý na webové sestavě, protože je implementován v souboru JavaScript u servisního pracovníka.</span><span class="sxs-lookup"><span data-stu-id="cec92-249">The mechanism for receiving and displaying a push notification on the client is also independent of Blazor WebAssembly, since it's implemented in the service worker JavaScript file.</span></span> <span data-ttu-id="cec92-250">Například viz [přístup použitý v dílně Blazing Pizza](https://github.com/dotnet-presentations/blazor-workshop/blob/master/docs/09-progressive-web-app.md#displaying-notifications).</span><span class="sxs-lookup"><span data-stu-id="cec92-250">For an example, see [the approach used in the Blazing Pizza workshop](https://github.com/dotnet-presentations/blazor-workshop/blob/master/docs/09-progressive-web-app.md#displaying-notifications).</span></span>

## <a name="caveats-for-offline-pwas"></a><span data-ttu-id="cec92-251">Upozornění pro offline pwa</span><span class="sxs-lookup"><span data-stu-id="cec92-251">Caveats for offline PWAs</span></span>

<span data-ttu-id="cec92-252">Ne všechny aplikace by se měly pokoušet podporovat offline použití.</span><span class="sxs-lookup"><span data-stu-id="cec92-252">Not all apps should attempt to support offline use.</span></span> <span data-ttu-id="cec92-253">Podpora offline přidává značnou složitost, zatímco ne vždy relevantní pro případy použití požadované.</span><span class="sxs-lookup"><span data-stu-id="cec92-253">Offline support adds significant complexity, while not always being relevant for the use cases required.</span></span>

<span data-ttu-id="cec92-254">Podpora offline je obvykle relevantní pouze:</span><span class="sxs-lookup"><span data-stu-id="cec92-254">Offline support is usually relevant only:</span></span>

* <span data-ttu-id="cec92-255">Pokud je primární úložiště dat místní v prohlížeči.</span><span class="sxs-lookup"><span data-stu-id="cec92-255">If the primary data store is local to the browser.</span></span> <span data-ttu-id="cec92-256">Například přístup je relevantní v aplikaci s ui pro zařízení [IoT,](https://en.wikipedia.org/wiki/Internet_of_things) které ukládá data v `localStorage` nebo [IndexedDB](https://developer.mozilla.org/docs/Web/API/IndexedDB_API).</span><span class="sxs-lookup"><span data-stu-id="cec92-256">For example, the approach is relevant in an app with a UI for an [IoT](https://en.wikipedia.org/wiki/Internet_of_things) device that stores data in `localStorage` or [IndexedDB](https://developer.mozilla.org/docs/Web/API/IndexedDB_API).</span></span>
* <span data-ttu-id="cec92-257">Pokud aplikace provádí značné množství práce načíst a ukládat do mezipaměti data rozhraní API pro každého uživatele tak, aby mohli procházet data v režimu offline.</span><span class="sxs-lookup"><span data-stu-id="cec92-257">If the app performs a significant amount of work to fetch and cache the backend API data relevant to each user so that they can navigate through the data offline.</span></span> <span data-ttu-id="cec92-258">Pokud aplikace musí podporovat úpravy, musí být vytvořen systém pro sledování změn a synchronizaci dat s back-endem.</span><span class="sxs-lookup"><span data-stu-id="cec92-258">If the app must support editing, a system for tracking changes and synchronizing data with the backend must be built.</span></span>
* <span data-ttu-id="cec92-259">Pokud je cílem zaručit, že se aplikace načte okamžitě bez ohledu na podmínky v síti.</span><span class="sxs-lookup"><span data-stu-id="cec92-259">If the goal is to guarantee that the app loads immediately regardless of network conditions.</span></span> <span data-ttu-id="cec92-260">Implementujte vhodné uživatelské prostředí kolem požadavků rozhraní API back-endu, abyste zobrazili průběh požadavků a řádně se chovali, když se požadavky nezdaří z důvodu nedostupnosti sítě.</span><span class="sxs-lookup"><span data-stu-id="cec92-260">Implement a suitable user experience around backend API requests to show the progress of requests and behave gracefully when requests fail due to network unavailability.</span></span>

<span data-ttu-id="cec92-261">Kromě toho se pwa s podporou offline musí vypořádat s řadou dalších komplikací.</span><span class="sxs-lookup"><span data-stu-id="cec92-261">Additionally, offline-capable PWAs must deal with a range of additional complications.</span></span> <span data-ttu-id="cec92-262">Vývojáři by se měli pečlivě seznámit s upozorněními v následujících částech.</span><span class="sxs-lookup"><span data-stu-id="cec92-262">Developers should carefully familiarize themselves with the caveats in the following sections.</span></span>

### <a name="offline-support-only-when-published"></a><span data-ttu-id="cec92-263">Podpora offline pouze při publikování</span><span class="sxs-lookup"><span data-stu-id="cec92-263">Offline support only when published</span></span>

<span data-ttu-id="cec92-264">Během vývoje obvykle chcete vidět každou změnu, která se okamžitě projeví v prohlížeči, aniž byste museli projít procesem aktualizace na pozadí.</span><span class="sxs-lookup"><span data-stu-id="cec92-264">During development you typically want to see each change reflected immediately in the browser without going through a background update process.</span></span> <span data-ttu-id="cec92-265">Proto Blazoršablona pwa aplikace umožňuje podporu offline pouze při publikování.</span><span class="sxs-lookup"><span data-stu-id="cec92-265">Therefore, Blazor's PWA template enables offline support only when published.</span></span>

<span data-ttu-id="cec92-266">Při vytváření aplikace podporující offline nestačí otestovat aplikaci ve vývojovém prostředí.</span><span class="sxs-lookup"><span data-stu-id="cec92-266">When building an offline-capable app, it's not enough to test the app in the Development environment.</span></span> <span data-ttu-id="cec92-267">Aplikaci je nutné otestovat v publikovaném stavu, abyste pochopili, jak reaguje na různé podmínky sítě.</span><span class="sxs-lookup"><span data-stu-id="cec92-267">You must test the app in its published state to understand how it responds to different network conditions.</span></span>

### <a name="update-completion-after-user-navigation-away-from-app"></a><span data-ttu-id="cec92-268">Aktualizace dokončení po navigaci uživatele mimo aplikaci</span><span class="sxs-lookup"><span data-stu-id="cec92-268">Update completion after user navigation away from app</span></span>

<span data-ttu-id="cec92-269">Aktualizace se nedokončí, dokud uživatel nepřejde mimo aplikaci na všech kartách.</span><span class="sxs-lookup"><span data-stu-id="cec92-269">Updates don't complete until the user has navigated away from the app in all tabs.</span></span> <span data-ttu-id="cec92-270">Jak je vysvětleno v části [Aktualizace na pozadí,](#background-updates) po nasazení aktualizace do aplikace prohlížeč načte aktualizované soubory pracovníka služby a zahájí proces aktualizace.</span><span class="sxs-lookup"><span data-stu-id="cec92-270">As explained in the [Background updates](#background-updates) section, after you deploy an update to the app, the browser fetches the updated service worker files to begin the update process.</span></span>

<span data-ttu-id="cec92-271">Co překvapuje mnoho vývojářů je, že i když tato aktualizace dokončí, **to se projeví,** dokud uživatel má navigovat pryč ve všech kartách.</span><span class="sxs-lookup"><span data-stu-id="cec92-271">What surprises many developers is that, even when this update completes, it does **not** take effect until the user has navigated away in all tabs.</span></span> <span data-ttu-id="cec92-272">**Nestačí** aktualizovat kartu zobrazující aplikaci, i když je to jediná karta zobrazující aplikaci.</span><span class="sxs-lookup"><span data-stu-id="cec92-272">It is **not** sufficient to refresh the tab displaying the app, even if it's the only tab displaying the app.</span></span> <span data-ttu-id="cec92-273">Dokud nebude aplikace úplně zavřená, zůstane nový servisní pracovník v čekání na *aktivaci* stavu.</span><span class="sxs-lookup"><span data-stu-id="cec92-273">Until your app is completely closed, the new service worker remains in the *waiting to activate* status.</span></span> <span data-ttu-id="cec92-274">**To není specifické Blazorpro , ale je standardní chování webové platformy.**</span><span class="sxs-lookup"><span data-stu-id="cec92-274">**This is not specific to Blazor, but rather is a standard web platform behavior.**</span></span>

<span data-ttu-id="cec92-275">To obvykle trápí vývojáře, kteří se pokoušejí otestovat aktualizace svého servisního pracovníka nebo prostředků v mezipaměti offline.</span><span class="sxs-lookup"><span data-stu-id="cec92-275">This commonly troubles developers who are trying to test updates to their service worker or offline cached resources.</span></span> <span data-ttu-id="cec92-276">Pokud zaškrtnete vývojářské nástroje prohlížeče, může se zobrazit něco jako následující:</span><span class="sxs-lookup"><span data-stu-id="cec92-276">If you check in the browser's developer tools, you may see something like the following:</span></span>

![Google Chrome 'Aplikace' karta ukazuje, že servisní pracovník aplikace je 'čeká na aktivaci'.](progressive-web-app/_static/image7.png)

<span data-ttu-id="cec92-278">Tak dlouho, dokud seznam "klientů", které jsou karty nebo okna zobrazující vaši aplikaci, je neprázdný, pracovník pokračuje v čekání.</span><span class="sxs-lookup"><span data-stu-id="cec92-278">For as long as the list of "clients," which are tabs or windows displaying your app, is nonempty, the worker continues waiting.</span></span> <span data-ttu-id="cec92-279">Důvodem, proč to servisní pracovníci dělají, je zaručit konzistenci.</span><span class="sxs-lookup"><span data-stu-id="cec92-279">The reason service workers do this is to guarantee consistency.</span></span> <span data-ttu-id="cec92-280">Konzistence znamená, že všechny prostředky jsou načteny ze stejné atomové mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="cec92-280">Consistency means that all resources are fetched from the same atomic cache.</span></span>

<span data-ttu-id="cec92-281">Při testování změn může být vhodné kliknout na odkaz "skipWaiting", jak je znázorněno na předchozím snímku obrazovky, a pak znovu načíst stránku.</span><span class="sxs-lookup"><span data-stu-id="cec92-281">When testing changes, you may find it convenient to click the "skipWaiting" link as shown in the preceding screenshot, then reload the page.</span></span> <span data-ttu-id="cec92-282">Můžete to automatizovat pro všechny uživatele kódováním servisního pracovníka [přeskočit "čekání" fáze a okamžitě aktivovat na aktualizaci](https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle#skip_the_waiting_phase).</span><span class="sxs-lookup"><span data-stu-id="cec92-282">You can automate this for all users by coding your service worker to [skip the "waiting" phase and immediately activate on update](https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle#skip_the_waiting_phase).</span></span> <span data-ttu-id="cec92-283">Pokud přeskočíte fázi čekání, vzdáváte se záruky, že prostředky jsou vždy načteny konzistentně ze stejné instance mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="cec92-283">If you skip the waiting phase, you're giving up the guarantee that resources are always fetched consistently from the same cache instance.</span></span>

### <a name="users-may-run-any-historical-version-of-the-app"></a><span data-ttu-id="cec92-284">Uživatelé mohou spustit libovolnou historickou verzi aplikace</span><span class="sxs-lookup"><span data-stu-id="cec92-284">Users may run any historical version of the app</span></span>

<span data-ttu-id="cec92-285">Weboví vývojáři obvykle očekávají, že uživatelé spustí pouze nejnovější nasazenou verzi své webové aplikace, protože to je normální v rámci tradičního modelu webové distribuce.</span><span class="sxs-lookup"><span data-stu-id="cec92-285">Web developers habitually expect that users only run the latest deployed version of their web app, since that's normal within the traditional web distribution model.</span></span> <span data-ttu-id="cec92-286">Server PWA, který je první v offline programu, se však více podomábá nativní mobilní aplikaci, kde uživatelé nemusí nutně spouštět nejnovější verzi.</span><span class="sxs-lookup"><span data-stu-id="cec92-286">However, an offline-first PWA is more akin to a native mobile app, where users aren't necessarily running the latest version.</span></span>

<span data-ttu-id="cec92-287">Jak je vysvětleno v části [Aktualizace na pozadí,](#background-updates) po nasazení aktualizace do aplikace **každý existující uživatel nadále používá předchozí verzi alespoň jednu další návštěvu,** protože aktualizace probíhá na pozadí a není aktivována, dokud uživatel poté nepřejde pryč.</span><span class="sxs-lookup"><span data-stu-id="cec92-287">As explained in the [Background updates](#background-updates) section, after you deploy an update to your app, **each existing user continues to use a previous version for at least one further visit** because the update occurs in the background and isn't activated until the user thereafter navigates away.</span></span> <span data-ttu-id="cec92-288">Navíc předchozí verze, která se používá, nemusí být nutně předchozí verze, kterou jste nasadili.</span><span class="sxs-lookup"><span data-stu-id="cec92-288">Plus, the previous version being used isn't necessarily the previous one you deployed.</span></span> <span data-ttu-id="cec92-289">Předchozí verze může být *libovolná* historická verze, v závislosti na tom, kdy uživatel naposledy dokončil aktualizaci.</span><span class="sxs-lookup"><span data-stu-id="cec92-289">The previous version can be *any* historical version, depending on when the user last completed an update.</span></span>

<span data-ttu-id="cec92-290">To může být problém, pokud front-endové a back-endové části aplikace vyžadují souhlas o schématu pro požadavky rozhraní API.</span><span class="sxs-lookup"><span data-stu-id="cec92-290">This can be an issue if the frontend and backend parts of your app require agreement about the schema for API requests.</span></span> <span data-ttu-id="cec92-291">Nesmíte nasadit změny schématu zpětného nekompatibilního rozhraní API, dokud si nejste jisti, že všichni uživatelé inovovali.</span><span class="sxs-lookup"><span data-stu-id="cec92-291">You must not deploy backward-incompatible API schema changes until you can be sure that all users have upgraded.</span></span> <span data-ttu-id="cec92-292">Případně zablokujte uživatelům používání nekompatibilních starších verzí aplikace.</span><span class="sxs-lookup"><span data-stu-id="cec92-292">Alternatively, block users from using incompatible older versions of the app.</span></span> <span data-ttu-id="cec92-293">Tento scénář požadavek je stejný jako pro nativní mobilní aplikace.</span><span class="sxs-lookup"><span data-stu-id="cec92-293">This scenario requirement is the same as for native mobile apps.</span></span> <span data-ttu-id="cec92-294">Pokud nasadíte narušující změny v serverových api, klientská aplikace je přerušena pro uživatele, kteří ještě nejsou aktualizovány.</span><span class="sxs-lookup"><span data-stu-id="cec92-294">If you deploy a breaking change in server APIs, the client app is broken for users who haven't yet updated.</span></span>

<span data-ttu-id="cec92-295">Pokud je to možné, nenasazujte narušující změny do back-endových api.</span><span class="sxs-lookup"><span data-stu-id="cec92-295">If possible, don't deploy breaking changes to your backend APIs.</span></span> <span data-ttu-id="cec92-296">Pokud je to nutné, zvažte použití [standardních api servisního pracovníka, jako je ServiceWorkerRegistration](https://developer.mozilla.org/docs/Web/API/ServiceWorkerRegistration) k určení, zda je aplikace aktuální a pokud ne, abyste zabránili použití.</span><span class="sxs-lookup"><span data-stu-id="cec92-296">If you must do so, consider using [standard Service Worker APIs such as ServiceWorkerRegistration](https://developer.mozilla.org/docs/Web/API/ServiceWorkerRegistration) to determine whether the app is up-to-date, and if not, to prevent usage.</span></span>

### <a name="interference-with-server-rendered-pages"></a><span data-ttu-id="cec92-297">Rušení stránek vykreslených serverem</span><span class="sxs-lookup"><span data-stu-id="cec92-297">Interference with server-rendered pages</span></span>

<span data-ttu-id="cec92-298">Jak je popsáno v části [Stránky vykreslené serverem podpory,](#support-server-rendered-pages) pokud chcete obejít chování servisního pracovníka vrácení `/index.html` obsahu pro všechny požadavky navigace, upravte logiku v pracovníkovi služby.</span><span class="sxs-lookup"><span data-stu-id="cec92-298">As described in the [Support server-rendered pages](#support-server-rendered-pages) section, if you want to bypass the service worker's behavior of returning `/index.html` contents for all navigation requests, edit the logic in your service worker.</span></span>

### <a name="all-service-worker-asset-manifest-contents-are-cached-by-default"></a><span data-ttu-id="cec92-299">Veškerý obsah manifestu majetku pracovníka servisu je ve výchozím nastavení uložen do mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="cec92-299">All service worker asset manifest contents are cached by default</span></span>

<span data-ttu-id="cec92-300">Jak je popsáno v části [Řízení ukládání majetku do mezipaměti,](#control-asset-caching) soubor *service-worker-assets.js* je generován během sestavení a uvádí všechny prostředky, které by měl pracovník služby načíst a uložit do mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="cec92-300">As described in the [Control asset caching](#control-asset-caching) section, the file *service-worker-assets.js* is generated during build and lists all assets the service worker should fetch and cache.</span></span>

<span data-ttu-id="cec92-301">Vzhledem k tomu, že tento seznam ve výchozím nastavení obsahuje vše, co je vydáváno na *wwwroot*, včetně obsahu dodávaného externími balíčky a projekty, musíte být opatrní, abyste tam nevložili příliš mnoho obsahu.</span><span class="sxs-lookup"><span data-stu-id="cec92-301">Since this list by default includes everything emitted to *wwwroot*, including content supplied by external packages and projects, you must be careful not to put too much content there.</span></span> <span data-ttu-id="cec92-302">Pokud adresář *wwwroot* obsahuje miliony bitových kopií, pracovník služby se pokusí načíst a uložit do mezipaměti všechny, spotřebovává nadměrnou šířku pásma a s největší pravděpodobností není úspěšně dokončena.</span><span class="sxs-lookup"><span data-stu-id="cec92-302">If the *wwwroot* directory contains millions of images, the service worker tries to fetch and cache them all, consuming excessive bandwidth and most likely not completing successfully.</span></span>

<span data-ttu-id="cec92-303">Implementujte libovolnou logiku pro řízení, která podmnožina obsahu manifestu `onInstall` by měla být načtena a uložena do mezipaměti úpravou funkce v *service-worker.published.js*.</span><span class="sxs-lookup"><span data-stu-id="cec92-303">Implement arbitrary logic to control which subset of the manifest's contents should be fetched and cached by editing the `onInstall` function in *service-worker.published.js*.</span></span>

### <a name="interaction-with-authentication"></a><span data-ttu-id="cec92-304">Interakce s ověřováním</span><span class="sxs-lookup"><span data-stu-id="cec92-304">Interaction with authentication</span></span>

<span data-ttu-id="cec92-305">Možnost šablony PWA je možné použít ve spojení s možnostmi ověřování.</span><span class="sxs-lookup"><span data-stu-id="cec92-305">It's possible to use the PWA template option in conjunction with the authentication options.</span></span> <span data-ttu-id="cec92-306">Server PWA s podporou offline může také podporovat ověřování, pokud má uživatel připojení k síti.</span><span class="sxs-lookup"><span data-stu-id="cec92-306">An offline-capable PWA can also support authentication when the user has network connectivity.</span></span>

<span data-ttu-id="cec92-307">Pokud uživatel nemá připojení k síti, nemůže ověřit ani získat přístupové tokeny.</span><span class="sxs-lookup"><span data-stu-id="cec92-307">When a user doesn't have network connectivity, they can't authenticate or obtain access tokens.</span></span> <span data-ttu-id="cec92-308">Ve výchozím nastavení má pokus o návštěvu přihlašovací stránky bez přístupu k síti za následek zprávu o chybě v síti.</span><span class="sxs-lookup"><span data-stu-id="cec92-308">By default, attempting to visit the login page without network access results in a "network error" message.</span></span>

<span data-ttu-id="cec92-309">Je nutné navrhnout tok uživatelského rozhraní, který umožňuje uživateli dělat užitečné věci v offline bez pokusu o ověření nebo získání přístupových tokenů.</span><span class="sxs-lookup"><span data-stu-id="cec92-309">You must design a UI flow that lets the user do useful things while offline without attempting to authenticate or obtain access tokens.</span></span> <span data-ttu-id="cec92-310">Případně můžete navrhnout aplikaci tak, aby se nezdařila, když síť není k dispozici.</span><span class="sxs-lookup"><span data-stu-id="cec92-310">Alternatively, you can design the app to fail in a graceful way when the network isn't available.</span></span> <span data-ttu-id="cec92-311">Pokud to ve vaší aplikaci není možné, možná nebudete chtít povolit offline podporu.</span><span class="sxs-lookup"><span data-stu-id="cec92-311">If this isn't possible in your app, you might not want to enable offline support.</span></span>
