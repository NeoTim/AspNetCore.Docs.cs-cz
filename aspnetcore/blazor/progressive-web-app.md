---
title: Sestavování progresivních webových aplikací pomocí ASP.NET Core Blazor webovém sestavení
author: guardrex
description: Naučte se vytvářet progresivní webové aplikace (PWAs) založené na Blazor, webové aplikace, které používají moderní funkce prohlížeče, se chovají jako desktopové aplikace.
monikerRange: '>= aspnetcore-3.1'
ms.author: riande
ms.custom: mvc
ms.date: 03/09/2020
no-loc:
- Blazor
- SignalR
uid: blazor/progressive-web-app
ms.openlocfilehash: f1c1ce50f20bf579e67e1d4eb02cc7d9d681e354
ms.sourcegitcommit: 98bcf5fe210931e3eb70f82fd675d8679b33f5d6
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 03/11/2020
ms.locfileid: "79083718"
---
# <a name="build-progressive-web-applications-with-aspnet-core-opno-locblazor-webassembly"></a><span data-ttu-id="14939-103">Sestavování progresivních webových aplikací pomocí ASP.NET Core Blazor webovém sestavení</span><span class="sxs-lookup"><span data-stu-id="14939-103">Build Progressive Web Applications with ASP.NET Core Blazor WebAssembly</span></span>

<span data-ttu-id="14939-104">Pomocí [Steve Sanderson](https://github.com/SteveSandersonMS)</span><span class="sxs-lookup"><span data-stu-id="14939-104">By [Steve Sanderson](https://github.com/SteveSandersonMS)</span></span>

[!INCLUDE[](~/includes/blazorwasm-preview-notice.md)]

[!INCLUDE[](~/includes/blazorwasm-3.2-template-article-notice.md)]

<span data-ttu-id="14939-105">Progresivní webová aplikace (PWA) je webová aplikace, která používá moderní rozhraní API a možnosti prohlížeče, aby se choval jako desktopová aplikace.</span><span class="sxs-lookup"><span data-stu-id="14939-105">A Progressive Web Application (PWA) is a web-based application that uses modern browser APIs and capabilities to behave like a desktop application.</span></span> <span data-ttu-id="14939-106">Tyto možnosti mohou zahrnovat:</span><span class="sxs-lookup"><span data-stu-id="14939-106">These capabilities can include:</span></span>

* <span data-ttu-id="14939-107">Práce v režimu offline a okamžité načítání vždy nezávisle na rychlosti sítě</span><span class="sxs-lookup"><span data-stu-id="14939-107">Working offline and always loading instantly, independently of network speed</span></span>
* <span data-ttu-id="14939-108">Může běžet ve vlastním okně aplikace, ne jenom v okně prohlížeče.</span><span class="sxs-lookup"><span data-stu-id="14939-108">Being able to run in its own application window, not just a browser window</span></span>
* <span data-ttu-id="14939-109">Spouští se z nabídky Start (OS) hostitelského operačního systému, ukotvení nebo domovské obrazovky.</span><span class="sxs-lookup"><span data-stu-id="14939-109">Being launched from the host operating system (OS) start menu, dock, or home screen</span></span>
* <span data-ttu-id="14939-110">Příjem nabízených oznámení ze serveru back-end, a to i v případě, že uživatel aplikaci nepoužívá</span><span class="sxs-lookup"><span data-stu-id="14939-110">Receiving push notifications from a backend server, even while the user is not using the application</span></span>
* <span data-ttu-id="14939-111">Automatické aktualizace na pozadí</span><span class="sxs-lookup"><span data-stu-id="14939-111">Automatically updating in the background</span></span>

<span data-ttu-id="14939-112">Uživatel může nejdříve vyhledat a použít aplikaci v rámci webového prohlížeče, jako je jakákoli jiná jednostránková aplikace (SPA), a potom později postup nainstalovat do svého operačního systému a povolit nabízená oznámení.</span><span class="sxs-lookup"><span data-stu-id="14939-112">A user might first discover and use the application within their web browser like any other single-page application (SPA), then later progress to installing it in their OS and enabling push notifications.</span></span> <span data-ttu-id="14939-113">Proto používáme termín *progresivní*.</span><span class="sxs-lookup"><span data-stu-id="14939-113">That's why we use the term *progressive*.</span></span>

Blazor<span data-ttu-id="14939-114"> WebAssembly je skutečnou platformou webové aplikace na straně klienta, takže může používat libovolné rozhraní API prohlížeče, včetně rozhraní API PWA potřebných pro výše uvedené možnosti.</span><span class="sxs-lookup"><span data-stu-id="14939-114"> WebAssembly is a true standards-based client-side web application platform, so it can use any browser API, including PWA APIs needed for the capabilities listed above.</span></span> <span data-ttu-id="14939-115">Může pracovat offline stejně jako jakékoli jiné webové technologie na straně klienta.</span><span class="sxs-lookup"><span data-stu-id="14939-115">It can work offline just like any other client-side web technology.</span></span>

## <a name="pwa-template"></a><span data-ttu-id="14939-116">Šablona PWA</span><span class="sxs-lookup"><span data-stu-id="14939-116">PWA template</span></span>

<span data-ttu-id="14939-117">Při vytváření nové aplikace Blazor WebAssembly vám nabídnete možnost Přidat funkce PWA.</span><span class="sxs-lookup"><span data-stu-id="14939-117">When creating a new Blazor WebAssembly application, you are offered the option to add PWA features.</span></span> <span data-ttu-id="14939-118">V aplikaci Visual Studio je možnost uvedena jako zaškrtávací políčko v dialogovém okně pro vytvoření projektu:</span><span class="sxs-lookup"><span data-stu-id="14939-118">In Visual Studio, the option is given as a checkbox in the project creation dialog:</span></span>

![image](https://user-images.githubusercontent.com/1101362/76207411-a6b54200-61f5-11ea-9dfc-6acd87a91428.png)

<span data-ttu-id="14939-120">Pokud vytváříte projekt na příkazovém řádku, můžete použít příznak `--pwa`.</span><span class="sxs-lookup"><span data-stu-id="14939-120">If you're creating the project on the command line, you can use the `--pwa` flag.</span></span> <span data-ttu-id="14939-121">Například:</span><span class="sxs-lookup"><span data-stu-id="14939-121">For example,</span></span>

```dotnetcli
dotnet new blazorwasm --pwa -o MyNewProject
```

<span data-ttu-id="14939-122">V obou případech je můžete kombinovat s možností "ASP.NET Core Hosted", pokud chcete, ale nemusíte to dělat.</span><span class="sxs-lookup"><span data-stu-id="14939-122">In both cases, you're free to combine this with the "ASP.NET Core hosted" option if you wish, but don't have to do so.</span></span> <span data-ttu-id="14939-123">Funkce PWA jsou nezávislé na modelu hostování.</span><span class="sxs-lookup"><span data-stu-id="14939-123">PWA features are independent of the hosting model.</span></span>

## <a name="installation-and-app-manifest"></a><span data-ttu-id="14939-124">Instalace a manifest aplikace</span><span class="sxs-lookup"><span data-stu-id="14939-124">Installation and app manifest</span></span>

<span data-ttu-id="14939-125">Když se navštíví aplikace vytvořená pomocí možnosti šablony PWA, uživatelé mají možnost nainstalovat aplikaci do nabídky Start, Dock nebo Home v operačním systému.</span><span class="sxs-lookup"><span data-stu-id="14939-125">When visiting an application created using the PWA template option, users have the option to install the application into their OS's start menu, dock, or home screen.</span></span>

<span data-ttu-id="14939-126">Způsob, jakým je tato možnost uvedená, závisí na prohlížeči uživatele.</span><span class="sxs-lookup"><span data-stu-id="14939-126">The way this option is presented depends on the user's browser.</span></span> <span data-ttu-id="14939-127">Například při použití prohlížečů založených na desktopových Chromech, jako jsou Edge nebo Chrome, se na panelu Adresa URL zobrazí tlačítko *Přidat* :</span><span class="sxs-lookup"><span data-stu-id="14939-127">For example, when using desktop Chromium-based browsers such as Edge or Chrome, an *Add* button appears within the URL bar:</span></span>

![image](https://user-images.githubusercontent.com/1101362/76208127-f7796a80-61f6-11ea-8aea-7fba704be787.png)

<span data-ttu-id="14939-129">V systému iOS můžou Návštěvníci nainstalovat aplikaci PWA pomocí tlačítka pro *sdílení* v prohlížeči Safari a její možnosti *Přidat do homescreen* .</span><span class="sxs-lookup"><span data-stu-id="14939-129">On iOS, visitors can install the PWA using Safari's *Share* button and its *Add to Homescreen* option.</span></span> <span data-ttu-id="14939-130">V Chrome pro Android by uživatelé měli klepnout na tlačítko *nabídky* v pravém horním rohu a pak zvolit *Přidat na domovskou obrazovku*.</span><span class="sxs-lookup"><span data-stu-id="14939-130">On Chrome for Android, users should tap the *Menu* button in the upper-right corner, then choose *Add to Home screen*.</span></span>

<span data-ttu-id="14939-131">Po instalaci se aplikace zobrazí ve vlastním okně bez jakéhokoli panelu Adresa.</span><span class="sxs-lookup"><span data-stu-id="14939-131">Once installed, the application appears in its own window, without any address bar.</span></span>

![image](https://user-images.githubusercontent.com/1101362/76208588-e2e9a200-61f7-11ea-85e1-8c3fc849b252.png)

<span data-ttu-id="14939-133">Chcete-li přizpůsobit název okna, barevné schéma, ikonu nebo jiné podrobnosti, přečtěte si soubor `manifest.json` v adresáři *wwwroot* vašeho projektu.</span><span class="sxs-lookup"><span data-stu-id="14939-133">To customize the window's title, color scheme, icon, or other details, see the file `manifest.json` in your project's *wwwroot* directory.</span></span> <span data-ttu-id="14939-134">Schéma tohoto souboru je definováno webovými standardy.</span><span class="sxs-lookup"><span data-stu-id="14939-134">The schema of this file is defined by web standards.</span></span> <span data-ttu-id="14939-135">Podrobnou dokumentaci najdete v tématu https://developer.mozilla.org/docs/Web/Manifest.</span><span class="sxs-lookup"><span data-stu-id="14939-135">For detailed documentation, see https://developer.mozilla.org/docs/Web/Manifest.</span></span>

## <a name="offline-support"></a><span data-ttu-id="14939-136">Podpora offline</span><span class="sxs-lookup"><span data-stu-id="14939-136">Offline support</span></span>

<span data-ttu-id="14939-137">Ve výchozím nastavení mají aplikace vytvořené pomocí možnosti šablony PWA podporu pro spuštění offline.</span><span class="sxs-lookup"><span data-stu-id="14939-137">By default, applications created using the PWA template option have support for running offline.</span></span> <span data-ttu-id="14939-138">Uživatel musí nejdřív aplikaci navštívit, pokud jsou online, a pak bude automaticky stahovat a ukládat do mezipaměti všechny prostředky potřebné k provozu offline.</span><span class="sxs-lookup"><span data-stu-id="14939-138">A user must first visit the application while they are online, then the browser will automatically download and cache all the resources needed to operate offline.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="14939-139">Podpora offline je povolená jenom pro *publikované* aplikace.</span><span class="sxs-lookup"><span data-stu-id="14939-139">Offline support is only enabled for *published* applications.</span></span> <span data-ttu-id="14939-140">Během vývoje není povolený.</span><span class="sxs-lookup"><span data-stu-id="14939-140">It is not enabled during development.</span></span> <span data-ttu-id="14939-141">Důvodem je to, že by došlo ke konfliktu s obvyklým vývojovým cyklem provádění změn a jejich testování.</span><span class="sxs-lookup"><span data-stu-id="14939-141">This is because it would interfere with the usual development cycle of making changes and testing them.</span></span>

> [!WARNING]
> <span data-ttu-id="14939-142">Pokud máte v úmyslu dodávat offline s povolenou aplikaci PWA, je k dispozici [několik důležitých upozornění a aspektů](#caveats-for-offline-pwas) , které je potřeba pochopit.</span><span class="sxs-lookup"><span data-stu-id="14939-142">If you intend to ship an offline-enabled PWA, there are [several important warnings and caveats](#caveats-for-offline-pwas) you need to understand.</span></span> <span data-ttu-id="14939-143">Jsou podstatou pro offline PWAs a nespecifická pro Blazor.</span><span class="sxs-lookup"><span data-stu-id="14939-143">These are inherent to offline PWAs, and not specific to Blazor.</span></span> <span data-ttu-id="14939-144">Nezapomeňte si tyto upozornění přečíst a pochopit před tím, než začnete vytvářet předpoklady pro práci offline aplikace.</span><span class="sxs-lookup"><span data-stu-id="14939-144">Be sure to read and understand these caveats before making assumptions about how your offline-enabled application will work.</span></span>

<span data-ttu-id="14939-145">Pokud chcete zjistit, jak funguje podpora offline, nejprve [publikujte aplikaci](https://docs.microsoft.com/aspnet/core/host-and-deploy/blazor/?view=aspnetcore-3.1&tabs=visual-studio#publish-the-app)a hostovat ji na serveru podporujícím protokol HTTPS.</span><span class="sxs-lookup"><span data-stu-id="14939-145">To see how offline support works, first [publish your application](https://docs.microsoft.com/aspnet/core/host-and-deploy/blazor/?view=aspnetcore-3.1&tabs=visual-studio#publish-the-app), and host it on a server supporting HTTPS.</span></span> <span data-ttu-id="14939-146">Při návštěvě aplikace byste měli být schopni otevřít vývojové nástroje v prohlížeči a ověřit, zda je *pracovní proces služby* zaregistrován pro vašeho hostitele:</span><span class="sxs-lookup"><span data-stu-id="14939-146">When you visit the application, you should be able to open the browser's dev tools and verify that a *Service Worker* is registered for your host:</span></span>

![image](https://user-images.githubusercontent.com/1101362/76210294-bd5e9780-61fb-11ea-9869-65c55c62803d.png)

<span data-ttu-id="14939-148">Pokud navíc znovu načtete stránku, pak na kartě *síť* byste měli vidět, že všechny prostředky potřebné k načtení stránky se načítají z *pracovníka služby* nebo *mezipaměti paměti*:</span><span class="sxs-lookup"><span data-stu-id="14939-148">Additionally, if you reload the page, then on the *Network* tab you should see that all resources needed to load your page are being retrieved from the *Service Worker* or *Memory Cache*:</span></span>

![image](https://user-images.githubusercontent.com/1101362/76210472-1d553e00-61fc-11ea-84c6-291644df709e.png)

<span data-ttu-id="14939-150">To ukazuje, že prohlížeč není závislý na síťovém přístupu pro načtení vaší aplikace.</span><span class="sxs-lookup"><span data-stu-id="14939-150">This shows that the browser is not dependent on network access to load your application.</span></span> <span data-ttu-id="14939-151">To můžete ověřit buď tak, že vypnete webový server, nebo nastavíte, aby prohlížeč simuloval offline režim:</span><span class="sxs-lookup"><span data-stu-id="14939-151">To verify this, you can either shut down your web server, or instruct the browser to simulate offline mode:</span></span>

![image](https://user-images.githubusercontent.com/1101362/76210556-47a6fb80-61fc-11ea-9d12-20a8f6528744.png)

<span data-ttu-id="14939-153">Teď, i když nemáte přístup k webovému serveru, byste měli být schopni stránku znovu načíst a zjistit, že se vaše aplikace pořád načítá a běží.</span><span class="sxs-lookup"><span data-stu-id="14939-153">Now, even without access to your web server, you should be able to reload the page and see that your application still loads and runs.</span></span> <span data-ttu-id="14939-154">Podobně i v případě, že simulaci velmi pomalé síťové připojení, bude stránka stále načtena ihned, protože je načítána nezávisle na síti.</span><span class="sxs-lookup"><span data-stu-id="14939-154">Likewise, even if you simulate a very slow network connection, your page will still load immediately since it is loaded independently of the network.</span></span>

### <a name="service-worker"></a><span data-ttu-id="14939-155">Pracovní proces služby</span><span class="sxs-lookup"><span data-stu-id="14939-155">Service worker</span></span>

<span data-ttu-id="14939-156">Podpora offline se dosahuje pomocí pracovního procesu služby.</span><span class="sxs-lookup"><span data-stu-id="14939-156">Offline support is achieved using a service worker.</span></span> <span data-ttu-id="14939-157">Toto je webový standard, který není specifický pro Blazor.</span><span class="sxs-lookup"><span data-stu-id="14939-157">This is a web standard, not specific to Blazor.</span></span> <span data-ttu-id="14939-158">Dokumentaci k pracovníkům služeb najdete v tématu https://developer.mozilla.org/docs/Web/API/Service_Worker_API.</span><span class="sxs-lookup"><span data-stu-id="14939-158">For documentation about service workers, see https://developer.mozilla.org/docs/Web/API/Service_Worker_API.</span></span> <span data-ttu-id="14939-159">Další informace o běžných vzorech použití pro pracovní procesy najdete v skvělém článku životní [cyklus pracovního procesu služby](https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle).</span><span class="sxs-lookup"><span data-stu-id="14939-159">To learn more about common usage patterns for service workers, see the excellent article [The Service Worker Lifecycle](https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle).</span></span>

<span data-ttu-id="14939-160">Šablona aplikace BlazorPWA vytvoří dva pracovní pracovní soubory služby:</span><span class="sxs-lookup"><span data-stu-id="14939-160">Blazor's PWA template produces two service worker files:</span></span>

* <span data-ttu-id="14939-161">*wwwroot/Service-Worker. js*, který se používá během vývoje</span><span class="sxs-lookup"><span data-stu-id="14939-161">*wwwroot/service-worker.js*, which is used during development</span></span>
* <span data-ttu-id="14939-162">*wwwroot/Service-Worker. Publikováno. js*, který se používá po publikování vaší aplikace</span><span class="sxs-lookup"><span data-stu-id="14939-162">*wwwroot/service-worker.published.js*, which is used once your application is published</span></span>

<span data-ttu-id="14939-163">Pokud chcete sdílet logiku mezi těmito dvěma soubory, zvažte přidání třetího souboru JavaScriptu pro uložení běžné logiky a použití [`self.importScripts`](https://developer.mozilla.org/docs/Web/API/WorkerGlobalScope/importScripts) k načtení této logiky do obou souborů.</span><span class="sxs-lookup"><span data-stu-id="14939-163">If you want to share logic between these two files, consider adding a third JavaScript file to hold the common logic, and use [`self.importScripts`](https://developer.mozilla.org/docs/Web/API/WorkerGlobalScope/importScripts) to load that logic into both files.</span></span>

#### <a name="cache-first-fetch-strategy"></a><span data-ttu-id="14939-164">Strategie prvního načtení mezipaměti</span><span class="sxs-lookup"><span data-stu-id="14939-164">Cache-first fetch strategy</span></span>

<span data-ttu-id="14939-165">Vestavěný pracovní proces služby *Service-Worker. Publish. js* řeší požadavky pomocí strategie *mezipaměti-First* .</span><span class="sxs-lookup"><span data-stu-id="14939-165">The built-in *service-worker.published.js* service worker resolves requests using a *cache-first* strategy.</span></span> <span data-ttu-id="14939-166">To znamená, že vždy raději vrátí obsah uložený v mezipaměti, pokud je k dispozici, bez ohledu na to, zda má uživatel přístup k síti nebo zda je na serveru k dispozici novější obsah.</span><span class="sxs-lookup"><span data-stu-id="14939-166">This means it always prefers to return cached content if available, regardless of whether the user has network access or whether newer content is available on the server.</span></span>

<span data-ttu-id="14939-167">Existují dva důvody, proč je to užitečné:</span><span class="sxs-lookup"><span data-stu-id="14939-167">There are two reasons why this is valuable:</span></span>

* <span data-ttu-id="14939-168">**Zajišťuje spolehlivost.**</span><span class="sxs-lookup"><span data-stu-id="14939-168">**It ensures reliability.**</span></span> <span data-ttu-id="14939-169">Přístup k síti není logickým stavem.</span><span class="sxs-lookup"><span data-stu-id="14939-169">Network access is not a boolean state.</span></span> <span data-ttu-id="14939-170">Uživatel není jednoduše online nebo offline.</span><span class="sxs-lookup"><span data-stu-id="14939-170">A user is not simply "online" or "offline".</span></span> <span data-ttu-id="14939-171">Ve skutečnosti se zařízení uživatele může domnívat, že je online, ale síť může být tak pomalá, aby bylo možné počkat na.</span><span class="sxs-lookup"><span data-stu-id="14939-171">In reality, the user's device may believe it is online, but the network may be so slow as to be impractical to wait for.</span></span> <span data-ttu-id="14939-172">Nebo může být u některých adres URL neplatných výsledků, například v případě, že je k dispozici nějaký portál Wi-Fi, který aktuálně blokuje nebo přesměrovává určité požadavky.</span><span class="sxs-lookup"><span data-stu-id="14939-172">Or the network might be returning invalid results for certain URLs, such as when there is a captive WIFI portal that is currently blocking or redirecting certain requests.</span></span> <span data-ttu-id="14939-173">Důvodem je to, proč `navigator.onLine` rozhraní API prohlížeče není spolehlivé a nemělo by být závislé na.</span><span class="sxs-lookup"><span data-stu-id="14939-173">This is why the browser's `navigator.onLine` API is not reliable and should not be depended upon.</span></span>
* <span data-ttu-id="14939-174">**Zajišťuje správnost.**</span><span class="sxs-lookup"><span data-stu-id="14939-174">**It ensures correctness.**</span></span> <span data-ttu-id="14939-175">Při sestavování mezipaměti offline prostředků používá pracovník služby k zajištění toho, aby získal úplný a vysoce konzistentní snímek prostředků v jednom čase.</span><span class="sxs-lookup"><span data-stu-id="14939-175">When building a cache of offline resources, the service worker uses content hashing to guarantee it has fetched a complete and self-consistent snapshot of resources at a single instant in time.</span></span> <span data-ttu-id="14939-176">Tato mezipaměť se pak použije jako atomická jednotka.</span><span class="sxs-lookup"><span data-stu-id="14939-176">This cache is then used as an atomic unit.</span></span> <span data-ttu-id="14939-177">V takovém případě neexistuje žádný bod, který žádá o síť pro novější prostředky, protože jediné požadované verze jsou ty, které jste už uložili do mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="14939-177">Given this, there is no point asking the network for newer resources, since the only versions you want are the ones you've already cached.</span></span> <span data-ttu-id="14939-178">Cokoli jiného rizika nekonzistence a nekompatibilita (například pokus o použití verzí sestavení .NET, která nebyla zkompilována dohromady).</span><span class="sxs-lookup"><span data-stu-id="14939-178">Anything else risks inconsistency and incompatibility (for example, trying to use versions of .NET assemblies that were not compiled together).</span></span>

#### <a name="background-updates"></a><span data-ttu-id="14939-179">Aktualizace na pozadí</span><span class="sxs-lookup"><span data-stu-id="14939-179">Background updates</span></span>

<span data-ttu-id="14939-180">V rámci duševního modelu si můžete představit jako v případě aplikace PWA offline, jako je například mobilní aplikace, kterou lze nainstalovat.</span><span class="sxs-lookup"><span data-stu-id="14939-180">As a mental model, you can think of an offline-first PWA as behaving like an mobile app that can be installed.</span></span> <span data-ttu-id="14939-181">Vždy se spustí okamžitě bez ohledu na připojení k síti, ale nainstalovaná logika aplikace pochází z snímku v čase, který nemusí být nejnovější verze.</span><span class="sxs-lookup"><span data-stu-id="14939-181">It always starts up immediately regardless of network connectivity, but the installed application logic comes from a point-in-time snapshot that might not be the latest version.</span></span>

<span data-ttu-id="14939-182">Šablona Blazor PWA vytváří aplikace, které se automaticky pokusí o aktualizaci na pozadí, kdykoli uživatel navštíví a má fungující síťové připojení.</span><span class="sxs-lookup"><span data-stu-id="14939-182">The Blazor PWA template produces applications that automatically try to update themselves in the background whenever the user visits and has a working network connection.</span></span> <span data-ttu-id="14939-183">Způsob funguje takto:</span><span class="sxs-lookup"><span data-stu-id="14939-183">The way this works is as follows:</span></span>

* <span data-ttu-id="14939-184">Během kompilace projekt vygeneruje *manifest assetů pracovního procesu služby*.</span><span class="sxs-lookup"><span data-stu-id="14939-184">During compilation, your project generates a *service worker assets manifest*.</span></span> <span data-ttu-id="14939-185">Ve výchozím nastavení se tento název nazývá *Service-Worker-assets. js*.</span><span class="sxs-lookup"><span data-stu-id="14939-185">By default this is called *service-worker-assets.js*.</span></span> <span data-ttu-id="14939-186">Zobrazí se seznam všech statických prostředků, které vaše aplikace potřebuje pro funkci offline, jako jsou například sestavení .NET, soubory JavaScriptu, šablony stylů CSS atd., včetně jejich hodnot hash obsahu.</span><span class="sxs-lookup"><span data-stu-id="14939-186">This lists all the static resources your application needs to function offline, such as .NET assemblies, JavaScript files, CSS, etc., including their content hashes.</span></span> <span data-ttu-id="14939-187">Tento seznam je načten pracovním procesem služby, aby věděl, které prostředky se mají ukládat do mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="14939-187">This list is loaded by your service worker so that it knows which resources to cache.</span></span>
* <span data-ttu-id="14939-188">Pokaždé, když uživatel navštíví vaši aplikaci, prohlížeč znovu vyžádá *Service-Worker. js* a *Service-Worker-assets. js* na pozadí.</span><span class="sxs-lookup"><span data-stu-id="14939-188">Each time the user visits your application, the browser re-requests *service-worker.js* and *service-worker-assets.js* in the background.</span></span> <span data-ttu-id="14939-189">Pokud server vrátí změněný obsah pro některý z těchto souborů (v porovnání s existujícím nainstalovaným pracovním procesem služby), pracovník služby se pokusí nainstalovat novou verzi.</span><span class="sxs-lookup"><span data-stu-id="14939-189">If the server returns changed content for either of these files (compared byte-for-byte with the existing installed service worker), the service worker tries to install a new version of itself.</span></span>
* <span data-ttu-id="14939-190">Při instalaci nové verze samotné pracovní proces služby vytvoří novou a samostatnou mezipaměť pro offline prostředky a začne ji naplnit prostředky uvedenými v *Service-Worker-assets. js*.</span><span class="sxs-lookup"><span data-stu-id="14939-190">When installing a new version of itself, the service worker creates a new, separate cache for offline resources, and starts populating it with resources listed in *service-worker-assets.js*.</span></span> <span data-ttu-id="14939-191">Tato logika je implementována ve funkci `onInstall` v rámci *Service-Worker. Publish. js*.</span><span class="sxs-lookup"><span data-stu-id="14939-191">This logic is implemented in the `onInstall` function inside *service-worker.published.js*.</span></span>
* <span data-ttu-id="14939-192">Pokud se proces úspěšně dokončí (tj. všechny prostředky se načtou bez chyb a všechny hodnoty hash obsahu se shodují), nový pracovní proces služby vstoupí do stavu "čekání na aktivaci".</span><span class="sxs-lookup"><span data-stu-id="14939-192">If the process completes successfully (i.e., all the resources are loaded without error, and all content hashes match), then the new service worker enters a "waiting for activation" state.</span></span> <span data-ttu-id="14939-193">Jakmile uživatel aplikaci zavře (tj. neexistují žádné zbývající karty ani zobrazení oken vaší aplikace), bude nový pracovní proces služby "aktivní" a bude použit pro následné návštěvy aplikace.</span><span class="sxs-lookup"><span data-stu-id="14939-193">As soon as the user closes your application (i.e., there are no remaining tabs or windows displaying your application), the new service worker becomes "active" and will be used for subsequent visits to your application.</span></span> <span data-ttu-id="14939-194">Původní pracovní proces služby a jeho mezipaměť se odstraní.</span><span class="sxs-lookup"><span data-stu-id="14939-194">The old service worker and its cache are deleted.</span></span>
* <span data-ttu-id="14939-195">Pokud se proces neúspěšně nedokončí, nová instance pracovního procesu služby se zahodí.</span><span class="sxs-lookup"><span data-stu-id="14939-195">If the process does not complete successfully, the new service worker instance is discarded.</span></span> <span data-ttu-id="14939-196">V případě, že bude snad mít lepší síťové připojení, které může dokončit požadavky, se proces aktualizace znovu pokusí o další návštěvu uživatele.</span><span class="sxs-lookup"><span data-stu-id="14939-196">The update process will be attempted again on the user's next visit, when hopefully they have a better network connection that can complete the requests.</span></span>

<span data-ttu-id="14939-197">Libovolný aspekt tohoto procesu můžete přizpůsobit úpravou logiky pracovního procesu služby.</span><span class="sxs-lookup"><span data-stu-id="14939-197">You can customize any aspect of this process by editing the service worker logic.</span></span> <span data-ttu-id="14939-198">Žádná z výše uvedených možností není specifická pro Blazor, ale je pouze návrhem, který poskytuje možnost šablony PWA.</span><span class="sxs-lookup"><span data-stu-id="14939-198">None of the above is specific to Blazor, but is merely a suggestion provided by the PWA template option.</span></span> <span data-ttu-id="14939-199">Další informace najdete v [dokumentaci k pracovnímu pracovníkovi služby](https://developer.mozilla.org/docs/Web/API/Service_Worker_API.) .</span><span class="sxs-lookup"><span data-stu-id="14939-199">See [service worker documentation](https://developer.mozilla.org/docs/Web/API/Service_Worker_API.) for more information.</span></span>

#### <a name="how-requests-are-resolved"></a><span data-ttu-id="14939-200">Jak se řeší požadavky</span><span class="sxs-lookup"><span data-stu-id="14939-200">How requests are resolved</span></span>

<span data-ttu-id="14939-201">Jak je popsáno výše, používá výchozí pracovní proces služby strategii *mezipaměti* , což znamená, že se při dostupnosti pokusí o poskytování obsahu v mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="14939-201">As described above, the default service worker uses a *cache-first* strategy, meaning that it tries to serve cached content when available.</span></span> <span data-ttu-id="14939-202">Pokud není obsah uložený v mezipaměti pro určitou adresu URL, například při vyžádání dat z back-endu API, pracovní proces služby se vrátí na běžný požadavek sítě, který může být úspěšný jenom v případě, že je server dostupný.</span><span class="sxs-lookup"><span data-stu-id="14939-202">If there is no content cached for a certain URL, for example when requesting data from a backend API, the service worker falls back on a regular network request which can only succeed if the server is reachable.</span></span> <span data-ttu-id="14939-203">Tato logika je implementována uvnitř `onFetch` v rámci *Service-Worker. Publish. js*.</span><span class="sxs-lookup"><span data-stu-id="14939-203">This logic is implemented inside `onFetch` within *service-worker.published.js*.</span></span>

<span data-ttu-id="14939-204">Pokud vaše Blazor komponenty spoléhají na požadavky na data z back-endové rozhraní API a chcete poskytnout uživatelsky přívětivé uživatelské prostředí v případě, kdy tyto požadavky selžou kvůli nedostupnosti sítě, je nutné implementovat logiku v rámci svých komponent.</span><span class="sxs-lookup"><span data-stu-id="14939-204">If your Blazor components rely on requesting data from backend APIs, and you want to provide a friendly user experience in the case where such requests fail due to network unavailability, then you need to implement logic within your components.</span></span> <span data-ttu-id="14939-205">Můžete například použít `try/catch` kolem `HttpClient` požadavků.</span><span class="sxs-lookup"><span data-stu-id="14939-205">For example, use `try/catch` around `HttpClient` requests.</span></span>

#### <a name="support-server-rendered-pages"></a><span data-ttu-id="14939-206">Server podpory – vykreslené stránky</span><span class="sxs-lookup"><span data-stu-id="14939-206">Support server-rendered pages</span></span>

<span data-ttu-id="14939-207">Zvažte, co se stane, když uživatel poprvé přejde na adresu URL, například `/counter` nebo jakýkoli přímý odkaz na aplikaci.</span><span class="sxs-lookup"><span data-stu-id="14939-207">Consider what happens when the user first navigates to a URL such as `/counter` or any other deep link into your application.</span></span> <span data-ttu-id="14939-208">V těchto případech nechcete vracet obsah uložený v mezipaměti jako `/counter`, ale místo toho musí prohlížeč načíst obsah uložený v mezipaměti jako `/index.html` pro spuštění aplikace Blazor WebAssembly.</span><span class="sxs-lookup"><span data-stu-id="14939-208">In these cases, you don't want to return content cached as `/counter`, but instead need the browser to load the content cached as `/index.html` to start up your Blazor WebAssembly application.</span></span> <span data-ttu-id="14939-209">Tyto počáteční požadavky se označují jako požadavky na *navigaci* (na rozdíl od požadavků na *subprostředky* pro Image/CSS/atd.), nebo *načte/XHR* požadavky na data rozhraní API.</span><span class="sxs-lookup"><span data-stu-id="14939-209">These initial requests are known as *navigation* requests (as opposed to *subresource* requests for images/CSS/etc, or *fetch/XHR* requests for API data).</span></span>

<span data-ttu-id="14939-210">Výchozí pracovní proces služby obsahuje zvláštní případovou logiku pro požadavky na navigaci.</span><span class="sxs-lookup"><span data-stu-id="14939-210">The default service worker contains special-case logic for navigation requests.</span></span> <span data-ttu-id="14939-211">Vyřeší je tak, že vrátí obsah uložený v mezipaměti pro `/index.html`bez ohledu na požadovanou adresu URL.</span><span class="sxs-lookup"><span data-stu-id="14939-211">It resolves them by returning the cached content for `/index.html`, regardless of the requested URL.</span></span> <span data-ttu-id="14939-212">Tato logika je implementována ve funkci `onFetch` v rámci *Service-Worker. Publish. js*.</span><span class="sxs-lookup"><span data-stu-id="14939-212">This logic is implemented in the `onFetch` function inside *service-worker.published.js*.</span></span>

<span data-ttu-id="14939-213">Pokud má vaše aplikace určité adresy URL, které musí vracet Server HTML vykreslený serverem (a neobsluhuje `/index.html` z mezipaměti), pak je potřeba upravit logiku pracovního procesu služby.</span><span class="sxs-lookup"><span data-stu-id="14939-213">If your application has certain URLs that must return server-rendered HTML (and not serve `/index.html` from the cache), then you need to edit the logic in your service worker.</span></span> <span data-ttu-id="14939-214">Například pokud všechny adresy URL obsahující `/Identity/` musí být zpracovány jako běžné požadavky pouze online na server a pak upravit logiku `onFetch` *Service-Worker. Publish. js* .</span><span class="sxs-lookup"><span data-stu-id="14939-214">For example, if all URLs containing `/Identity/` need to be handled as regular online-only requests to the server, then modify *service-worker.published.js* `onFetch` logic.</span></span> <span data-ttu-id="14939-215">Vyhledejte následující kód:</span><span class="sxs-lookup"><span data-stu-id="14939-215">Locate the following code:</span></span>

```javascript
const shouldServeIndexHtml = event.request.mode === 'navigate';
```

<span data-ttu-id="14939-216">Změňte kód následujícím způsobem:</span><span class="sxs-lookup"><span data-stu-id="14939-216">Change the code to the following:</span></span>

```javascript
const shouldServeIndexHtml = event.request.mode === 'navigate'
    && !event.request.url.includes('/Identity/');
```

<span data-ttu-id="14939-217">Pokud to neuděláte, pracovní proces služby bude zachytávat požadavky na takové adresy URL a bude je řešit pomocí `/index.html`.</span><span class="sxs-lookup"><span data-stu-id="14939-217">If you don't do this, then regardless of network connectivity, the service worker will intercept requests for such URLs and will resolve them using `/index.html`.</span></span>

#### <a name="control-asset-caching"></a><span data-ttu-id="14939-218">Ukládání prostředků do mezipaměti ovládacích prvků</span><span class="sxs-lookup"><span data-stu-id="14939-218">Control asset caching</span></span>

<span data-ttu-id="14939-219">Pokud váš projekt definuje vlastnost MSBuild s názvem `ServiceWorkerAssetsManifest`, pak Nástroj pro sestavení Blazorvygeneruje manifest prostředků pracovního procesu služby se zadaným názvem.</span><span class="sxs-lookup"><span data-stu-id="14939-219">If your project defines an MSBuild property called `ServiceWorkerAssetsManifest`, then Blazor's build tooling will generate a service worker assets manifest with the specified name.</span></span> <span data-ttu-id="14939-220">Výchozí šablona PWA vytvoří soubor projektu, který obsahuje následující:</span><span class="sxs-lookup"><span data-stu-id="14939-220">The default PWA template produces a project file containing the following:</span></span>

```xml
<ServiceWorkerAssetsManifest>service-worker-assets.js</ServiceWorkerAssetsManifest>
```

<span data-ttu-id="14939-221">Soubor je umístěn do výstupního adresáře *wwwroot* , takže prohlížeč může tento soubor načíst požadavkem `/service-worker-assets.js`.</span><span class="sxs-lookup"><span data-stu-id="14939-221">The file is placed in the *wwwroot* output directory, so the browser can retrieve this file by requesting `/service-worker-assets.js`.</span></span> <span data-ttu-id="14939-222">Chcete-li zobrazit obsah, otevřete *YourProject\bin\Debug\netstandard2.1\wwwroot\service-Worker-assets.js* v textovém editoru.</span><span class="sxs-lookup"><span data-stu-id="14939-222">To see the contents, open *YourProject\bin\Debug\netstandard2.1\wwwroot\service-worker-assets.js* in a text editor.</span></span> <span data-ttu-id="14939-223">Neupravujte ale soubor, protože se znovu vygeneruje u každého sestavení.</span><span class="sxs-lookup"><span data-stu-id="14939-223">However, don't edit the file, as it will be regenerated on each build.</span></span>

<span data-ttu-id="14939-224">Ve výchozím nastavení tento manifest uvádí:</span><span class="sxs-lookup"><span data-stu-id="14939-224">By default, this manifest lists:</span></span>

* <span data-ttu-id="14939-225">Všechny prostředky spravované Blazor, jako jsou sestavení .NET, a soubory runtime .NET WebAssembly, které jsou potřeba pro funkci offline</span><span class="sxs-lookup"><span data-stu-id="14939-225">Any Blazor-managed resources such as .NET assemblies and the .NET WebAssembly runtime files needed to function offline</span></span>
* <span data-ttu-id="14939-226">Všechny prostředky, které budou publikovány v adresáři *wwwroot* , například obrázky, soubory CSS a soubory JavaScriptu.</span><span class="sxs-lookup"><span data-stu-id="14939-226">All resources that will be published in your *wwwroot* directory, such as images, CSS files, and JavaScript files.</span></span> <span data-ttu-id="14939-227">To zahrnuje statické webové prostředky poskytované externími projekty a balíčky NuGet.</span><span class="sxs-lookup"><span data-stu-id="14939-227">This includes static web assets supplied by external projects and NuGet packages.</span></span>

<span data-ttu-id="14939-228">Úpravou logiky v `onInstall` v *Service-Worker. Publish. js*můžete řídit, které z těchto prostředků budou načteny a uloženy do mezipaměti pracovním procesem služby.</span><span class="sxs-lookup"><span data-stu-id="14939-228">You can control which of these resources will be fetched and cached by the service worker by editing the logic in `onInstall` in *service-worker.published.js*.</span></span> <span data-ttu-id="14939-229">Ve výchozím nastavení načte a zapíše soubory do mezipaměti, které odpovídají typickým příponám názvů webů, jako je například *. html*, *. CSS*, *. js*, *. wasm*a další, a navíc typy souborů specifické pro Blazor WebAssembly ( *. dll*, *. pdb*).</span><span class="sxs-lookup"><span data-stu-id="14939-229">By default, it will fetch and cache files matching typical web filename extensions such as *.html*, *.css*, *.js*, *.wasm*, and others, plus file types specific to Blazor WebAssembly (*.dll*, *.pdb*).</span></span>

<span data-ttu-id="14939-230">Pokud chcete zahrnout další prostředky, které nejsou k dispozici v adresáři *wwwroot* , můžete to provést tak, že definujete další položky položek MSBuild.</span><span class="sxs-lookup"><span data-stu-id="14939-230">If you want to include additional resources that aren't present in your *wwwroot* directory, you can do so by defining extra MSBuild itemgroup entries.</span></span> <span data-ttu-id="14939-231">Například v souboru projektu přidejte:</span><span class="sxs-lookup"><span data-stu-id="14939-231">For example, in your project file, add:</span></span>

```xml
<ItemGroup>
    <ServiceWorkerAssetsManifestItem
        Include="MyDirectory\AnotherFile.json"
        RelativePath="MyDirectory\AnotherFile.json"
        AssetUrl="files/AnotherFile.json" />
</ItemGroup>
```

<span data-ttu-id="14939-232">Metadata `AssetUrl` určují základní relativní adresu URL, kterou by měl prohlížeč použít při načítání prostředku do mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="14939-232">The `AssetUrl` metadata specifies the base-relative URL that the browser should use when fetching the resource to cache.</span></span> <span data-ttu-id="14939-233">To může být nezávislé na původním názvu zdrojového souboru na disku.</span><span class="sxs-lookup"><span data-stu-id="14939-233">This can be independent of its original source file name on disk.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="14939-234">Přidání `ServiceWorkerAssetsManifestItem` nezpůsobí publikování souboru v adresáři *wwwroot* .</span><span class="sxs-lookup"><span data-stu-id="14939-234">Adding a `ServiceWorkerAssetsManifestItem` does not cause the file to be published in your *wwwroot* directory.</span></span> <span data-ttu-id="14939-235">Můžete si také řídit výstup publikování samostatně.</span><span class="sxs-lookup"><span data-stu-id="14939-235">It up to you to control your publish output separately.</span></span> <span data-ttu-id="14939-236">`ServiceWorkerAssetsManifestItem` způsobí, že se v manifestu Asset Service Worker zobrazí další položka.</span><span class="sxs-lookup"><span data-stu-id="14939-236">The `ServiceWorkerAssetsManifestItem` only causes an additional entry to appear in the service worker assets manifest.</span></span>

## <a name="push-notifications"></a><span data-ttu-id="14939-237">Nabízená oznámení</span><span class="sxs-lookup"><span data-stu-id="14939-237">Push notifications</span></span>

<span data-ttu-id="14939-238">Stejně jako jakékoli jiné PWA může Blazor WebAssembly PWA přijímat nabízená oznámení ze serveru back-end.</span><span class="sxs-lookup"><span data-stu-id="14939-238">Like any other PWA, a Blazor WebAssembly PWA can receive push notifications from a backend server.</span></span> <span data-ttu-id="14939-239">Server je může kdykoli odeslat, i když uživatel aktivně nepoužívá vaši aplikaci (například když jiný uživatel provede akci, která může být relevantní).</span><span class="sxs-lookup"><span data-stu-id="14939-239">Your server can send these at any time, even when the user is not actively using your application (for example, when a different user performs an action that may be relevant).</span></span>

<span data-ttu-id="14939-240">Mechanismus pro odeslání nabízeného oznámení je zcela nezávislý na Blazor WebAssembly, protože je implementovaný back-end serverem, který může používat libovolnou technologii.</span><span class="sxs-lookup"><span data-stu-id="14939-240">The mechanism for sending a push notification is entirely independent of Blazor WebAssembly, since it's implemented by the backend server which can use any technology.</span></span> <span data-ttu-id="14939-241">Pokud chcete zasílat nabízená oznámení ze serveru ASP.NET Core, zvažte [použití techniky podobné tomu na neuvěřitelně Pizza Workshop](https://github.com/dotnet-presentations/blazor-workshop/blob/master/docs/09-progressive-web-app.md#sending-push-notifications).</span><span class="sxs-lookup"><span data-stu-id="14939-241">If you want to send push notifications from an ASP.NET Core server, consider [using a technique similar to that in the Blazing Pizza workshop](https://github.com/dotnet-presentations/blazor-workshop/blob/master/docs/09-progressive-web-app.md#sending-push-notifications).</span></span>

<span data-ttu-id="14939-242">Mechanismus pro příjem a zobrazování nabízených oznámení na straně klienta je také nezávislý na Blazor WebAssembly, protože je implementována v pracovním procesu služby, což je soubor JavaScriptu.</span><span class="sxs-lookup"><span data-stu-id="14939-242">The mechanism for receiving and displaying a push notification on the client is also independent of Blazor WebAssembly, since it's implemented in the service worker, which is a JavaScript file.</span></span> <span data-ttu-id="14939-243">Jako příklad můžete znovu zobrazit [přístup k použití v neuvěřitelně Pizza Workshop](https://github.com/dotnet-presentations/blazor-workshop/blob/master/docs/09-progressive-web-app.md#displaying-notifications).</span><span class="sxs-lookup"><span data-stu-id="14939-243">As an example, you can again see [the approach used in the Blazing Pizza workshop](https://github.com/dotnet-presentations/blazor-workshop/blob/master/docs/09-progressive-web-app.md#displaying-notifications).</span></span>

## <a name="caveats-for-offline-pwas"></a><span data-ttu-id="14939-244">Upozornění pro offline PWAs</span><span class="sxs-lookup"><span data-stu-id="14939-244">Caveats for offline PWAs</span></span>

<span data-ttu-id="14939-245">Ne všechny aplikace by se měly pokusit o podporu offline použití.</span><span class="sxs-lookup"><span data-stu-id="14939-245">Not all applications should attempt to support offline use.</span></span> <span data-ttu-id="14939-246">Přináší značnou složitost, ale ne vždy důležité.</span><span class="sxs-lookup"><span data-stu-id="14939-246">It adds significant complexity, while not always being relevant.</span></span>

<span data-ttu-id="14939-247">Podpora offline je obvykle relevantní pouze:</span><span class="sxs-lookup"><span data-stu-id="14939-247">Offline support is usually relevant only:</span></span>

* <span data-ttu-id="14939-248">Pokud je vaše primární úložiště dat místní pro prohlížeč.</span><span class="sxs-lookup"><span data-stu-id="14939-248">If your primary data store is local to the browser.</span></span> <span data-ttu-id="14939-249">Například při sestavování uživatelského rozhraní pro zařízení [IoT](https://en.wikipedia.org/wiki/Internet_of_things) , které ukládá data v `localStorage` nebo [IndexedDB](https://developer.mozilla.org/docs/Web/API/IndexedDB_API).</span><span class="sxs-lookup"><span data-stu-id="14939-249">For example, when building a UI for an [IoT](https://en.wikipedia.org/wiki/Internet_of_things) device that stores data in `localStorage` or [IndexedDB](https://developer.mozilla.org/docs/Web/API/IndexedDB_API).</span></span>

* <span data-ttu-id="14939-250">Pokud budete chtít načíst a uložit data rozhraní API back-endu relevantní pro každého uživatele, můžete k tomu přejít v režimu offline.</span><span class="sxs-lookup"><span data-stu-id="14939-250">If you do significant work to fetch and cache the backend API data relevant to each user, so they can navigate through it offline.</span></span> <span data-ttu-id="14939-251">Pokud podporujete úpravy, budete také muset vytvořit systém pro sledování změn a synchronizaci s back-endu.</span><span class="sxs-lookup"><span data-stu-id="14939-251">If you support editing, you will also need to build a system for tracking changes and synchronizing them with the backend.</span></span>

* <span data-ttu-id="14939-252">Pokud vaším cílem je zaručit, že se aplikace načte hned bez ohledu na stav sítě.</span><span class="sxs-lookup"><span data-stu-id="14939-252">If your goal is to guarantee the application loads immediately regardless of network conditions.</span></span> <span data-ttu-id="14939-253">Pak budete muset implementovat vhodné uživatelské prostředí kolem požadavků rozhraní API back-endu, aby se zobrazil průběh požadavků a plynulé chování, když dojde k selhání kvůli nedostupnosti sítě.</span><span class="sxs-lookup"><span data-stu-id="14939-253">You will then need to implement a suitable user experience around backend API requests to show the progress of requests and behave gracefully when they fail due to network unavailability.</span></span>

<span data-ttu-id="14939-254">Kromě toho musí PWAs s podporou offline řešit řadu mimořádných komplikací.</span><span class="sxs-lookup"><span data-stu-id="14939-254">Additionally, offline-capable PWAs need to deal with a range of extra complications.</span></span> <span data-ttu-id="14939-255">Vývojáři by se měli pečlivě seznámit s následujícími upozorněními.</span><span class="sxs-lookup"><span data-stu-id="14939-255">Developers should carefully familiarize themselves with the following caveats.</span></span>

### <a name="offline-support-only-when-published"></a><span data-ttu-id="14939-256">Podpora offline pouze v případě publikování</span><span class="sxs-lookup"><span data-stu-id="14939-256">Offline support only when published</span></span>

<span data-ttu-id="14939-257">Šablona aplikace PWA Blazorpovoluje podporu offline pouze v případě, že byla publikována.</span><span class="sxs-lookup"><span data-stu-id="14939-257">Blazor's PWA template enables offline support only when published.</span></span> <span data-ttu-id="14939-258">Důvodem je, že během vývoje obvykle chcete zobrazit každou změnu, která se projeví okamžitě v prohlížeči, aniž by procházela proces aktualizace na pozadí.</span><span class="sxs-lookup"><span data-stu-id="14939-258">This is because, during development, you typically want to see each change reflected immediately in the browser, without going through a background update process.</span></span>

<span data-ttu-id="14939-259">Proto při sestavování aplikace podporující offline není dostačující testovat aplikaci v režimu vývoje.</span><span class="sxs-lookup"><span data-stu-id="14939-259">Therefore when building an offline-capable application, it's not enough to test your application in development mode.</span></span> <span data-ttu-id="14939-260">Chcete-li pochopit, jak bude reagovat na různé podmínky v síti, musíte aplikaci otestovat v jejím publikovaném stavu.</span><span class="sxs-lookup"><span data-stu-id="14939-260">You must test your application in its published state to understand how it will respond to differing network conditions.</span></span>

### <a name="update-completion-after-user-navigation-away-from-app"></a><span data-ttu-id="14939-261">Dokončení aktualizace po navigaci uživatele z aplikace</span><span class="sxs-lookup"><span data-stu-id="14939-261">Update completion after user navigation away from app</span></span>

<span data-ttu-id="14939-262">Aktualizace se nedokončí, dokud uživatel nepřejde z vaší aplikace na všech kartách.</span><span class="sxs-lookup"><span data-stu-id="14939-262">Updates don't complete until the user has navigated away from your application in all tabs.</span></span> <span data-ttu-id="14939-263">Jak je vysvětleno v části [aktualizace na pozadí](#background-updates), po nasazení aktualizace do aplikace Prohlížeč načte aktualizované pracovní procesy služby a zahájí proces aktualizace.</span><span class="sxs-lookup"><span data-stu-id="14939-263">As explained in [Background updates](#background-updates), after you deploy an update to your application, the browser will fetch the updated service worker files and begin an update process.</span></span>

<span data-ttu-id="14939-264">Co překvapením mnoho vývojářů, i když se tato aktualizace dokončí, **neprojeví** se, dokud uživatel nepřejde na všechny karty.</span><span class="sxs-lookup"><span data-stu-id="14939-264">What surprises many developers is that, even when this update completes, it does **not** take effect until the user has navigated away in all tabs.</span></span> <span data-ttu-id="14939-265">**Není dostačující aktualizovat** kartu zobrazující vaši aplikaci, a to i v případě, že se jedná o jedinou kartu, na které se aplikace zobrazuje.</span><span class="sxs-lookup"><span data-stu-id="14939-265">It is **not** sufficient to refresh the tab displaying your application, even if it's the only tab displaying your application.</span></span> <span data-ttu-id="14939-266">Dokud nebude vaše aplikace kompletně uzavřená, nový pracovní proces služby zůstane ve stavu "čekání na aktivaci".</span><span class="sxs-lookup"><span data-stu-id="14939-266">Until your application is completely closed, the new service worker will remain in a "waiting to activate" status.</span></span> <span data-ttu-id="14939-267">**Nejedná se o konkrétní Blazor, ale spíše je standardní chování webové platformy.**</span><span class="sxs-lookup"><span data-stu-id="14939-267">**This is not specific to Blazor, but rather is a standard web platform behavior.**</span></span>

<span data-ttu-id="14939-268">To běžně vydává problémy vývojářům, kteří se pokoušejí testovat aktualizace pro pracovní pracovníky služby nebo offline prostředky v mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="14939-268">This commonly troubles developers who are trying to test updates to their service worker or offline cached resources.</span></span> <span data-ttu-id="14939-269">Pokud se ve vývojovém nástroji v prohlížeči vraťte zpět, může se zobrazit například následující text:</span><span class="sxs-lookup"><span data-stu-id="14939-269">If you check in the browser's dev tools, you may see something like the following:</span></span>

![image](https://user-images.githubusercontent.com/1101362/76226394-b93f7380-6215-11ea-8572-7d52afee2dd8.png)

<span data-ttu-id="14939-271">Pokud je seznam "klienti" (tj. karty nebo okna, ve kterém se aplikace zobrazuje) neprázdný, bude pracovní proces nadále čekat.</span><span class="sxs-lookup"><span data-stu-id="14939-271">For as long as the list of "clients" (i.e., tabs or windows displaying your application) is nonempty, the worker will continue waiting.</span></span> <span data-ttu-id="14939-272">Důvodem je zaručit konzistenci, tj., že všechny prostředky jsou načteny ze stejné atomické mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="14939-272">The reason service workers do this is to guarantee consistency, i.e., that all resources are fetched from the same atomic cache.</span></span>

<span data-ttu-id="14939-273">Při testování se může stát, že kliknete na odkaz "skipWaiting", jak je znázorněno na snímku obrazovky výše, a pak znovu načíst stránku.</span><span class="sxs-lookup"><span data-stu-id="14939-273">When testing changes, you may find it convenient to click the "skipWaiting" link as shown in the screenshot above, then reload the page.</span></span> <span data-ttu-id="14939-274">Pokud chcete, můžete to automatizovat pro všechny uživatele tak, že zakódujete pracovní proces služby, který [přeskočí fázi čekání a hned se aktivuje při aktualizaci](https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle#skip_the_waiting_phase).</span><span class="sxs-lookup"><span data-stu-id="14939-274">If you want, you can automate this for all users by coding your service worker to [skip the "waiting" phase and immediately activate on update](https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle#skip_the_waiting_phase).</span></span> <span data-ttu-id="14939-275">Pokud to ale uděláte, budete mít jistotu, že se prostředky vždycky načítají konzistentně ze stejné instance mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="14939-275">However if you do this, you are giving up the guarantee that resources are always fetched consistently from the same cache instance.</span></span>

### <a name="users-may-run-any-historical-version-of-the-app"></a><span data-ttu-id="14939-276">Uživatelé můžou spouštět všechny historické verze aplikace.</span><span class="sxs-lookup"><span data-stu-id="14939-276">Users may run any historical version of the app</span></span>

<span data-ttu-id="14939-277">Vývojáři webu obvykle očekávají, že uživatelé budou spouštět jenom nejnovější nasazené verze svých webových aplikací, protože to je obvyklé v tradičním modelu webové distribuce.</span><span class="sxs-lookup"><span data-stu-id="14939-277">Web developers habitually expect that users will only run the latest deployed version of their web application, since that's normal within the traditional web distribution model.</span></span> <span data-ttu-id="14939-278">Offline první aplikace PWA je ale více podobají nativní mobilní aplikaci, kde uživatelé nemusí nutně používat nejnovější verzi.</span><span class="sxs-lookup"><span data-stu-id="14939-278">However, an offline-first PWA is more akin to a native mobile app, where users are not necessarily running the latest version.</span></span>

<span data-ttu-id="14939-279">Jak je vysvětleno v části [aktualizace na pozadí](#background-updates), poté, co nasadíte aktualizaci do vaší aplikace, **bude mít každý existující uživatel i nadále k dispozici předchozí verzi pro alespoň jednu další návštěvu** (protože tato aktualizace probíhá na pozadí a není aktivována, dokud uživatel nepřejde).</span><span class="sxs-lookup"><span data-stu-id="14939-279">As explained in [Background updates](#background-updates), after you deploy an update to your application, **each existing user will continue to use a previous version for at least one further visit** (because the update occurs in the background and isn't activated until the user then navigates away).</span></span> <span data-ttu-id="14939-280">Předchozí používaná verze navíc nemusí nutně nasazovat předchozí verzi – může to být *jakákoli* historická verze v závislosti na tom, kdy uživatel poslední dokončení aktualizace dokončil.</span><span class="sxs-lookup"><span data-stu-id="14939-280">Plus, the previous version being used isn't necessarily the previous one you deployed - it can be *any* historical version, depending on when the user last completed an update.</span></span>

<span data-ttu-id="14939-281">To může být problém, pokud části front-end a back-end aplikace v aplikaci vyžadují smlouvu o schématu pro požadavky rozhraní API.</span><span class="sxs-lookup"><span data-stu-id="14939-281">This can be an issue if the frontend and backend parts of your application require agreement about the schema for API requests.</span></span> <span data-ttu-id="14939-282">Nekompatibilní změny schématu rozhraní API není nutné nasazovat, dokud nebudete mít jistotu, že všichni uživatelé provedli upgrade, nebo alespoň zablokovat uživatelům možnost používat nekompatibilní starší verze aplikace.</span><span class="sxs-lookup"><span data-stu-id="14939-282">You must not deploy backward-incompatible API schema changes until you can be sure that all users have upgraded, or at least block users from using incompatible older versions of the app.</span></span> <span data-ttu-id="14939-283">To je stejně jako v případě nativní mobilní aplikace.</span><span class="sxs-lookup"><span data-stu-id="14939-283">This is just like a native mobile app.</span></span> <span data-ttu-id="14939-284">Pokud nasadíte zásadní změnu v rozhraních API serveru, klientská aplikace se bude rušit pro uživatele, kteří se ještě neaktualizovali.</span><span class="sxs-lookup"><span data-stu-id="14939-284">If you deploy a breaking change in server APIs, the client app will be broken for people who haven't yet updated.</span></span>

<span data-ttu-id="14939-285">Pokud je to možné, nesaďte nenasazené změny rozhraní API back-endu.</span><span class="sxs-lookup"><span data-stu-id="14939-285">If possible, don't deploy breaking changes to your backend APIs.</span></span> <span data-ttu-id="14939-286">Pokud to ale musíte udělat, zvažte použití [rozhraní API pro standardní službu Service Worker, například `ServiceWorkerRegistration`](https://developer.mozilla.org/docs/Web/API/ServiceWorkerRegistration) , k určení, jestli je aplikace aktuální, a pokud ne, abyste zabránili použití.</span><span class="sxs-lookup"><span data-stu-id="14939-286">But if you must do so, consider using [standard Service Worker APIs such as `ServiceWorkerRegistration`](https://developer.mozilla.org/docs/Web/API/ServiceWorkerRegistration) to determine whether the application is up-to-date, and if not, to prevent usage.</span></span>

### <a name="interference-with-server-rendered-pages"></a><span data-ttu-id="14939-287">Rušení se stránkami vykreslenými serverem</span><span class="sxs-lookup"><span data-stu-id="14939-287">Interference with server-rendered pages</span></span>

<span data-ttu-id="14939-288">[Jak je popsáno výše](#support-server-rendered-pages), pokud chcete obejít chování služby Service Worker při vracení `/index.html` obsahu pro všechny požadavky na navigaci, musíte upravit logiku pracovního procesu služby.</span><span class="sxs-lookup"><span data-stu-id="14939-288">[As described above](#support-server-rendered-pages), if you want to bypass the service worker's behavior of returning `/index.html` contents for all navigation requests, you need to edit the logic in your service worker.</span></span>

### <a name="all-service-worker-asset-manifest-contents-are-cached-by-default"></a><span data-ttu-id="14939-289">Ve výchozím nastavení se veškerý obsah manifestu Asset Service Worker ukládá do mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="14939-289">All service worker asset manifest contents are cached by default</span></span>

<span data-ttu-id="14939-290">[Jak je popsáno výše](#control-asset-caching), soubor *Service-Worker-assets. js* se vygeneruje během sestavování a zobrazí všechny prostředky, které by pracovní proces služby měl načíst a Uložit do mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="14939-290">[As described above](#control-asset-caching), the file *service-worker-assets.js* is generated during build and lists all assets the service worker should fetch and cache.</span></span>

<span data-ttu-id="14939-291">Vzhledem k tomu, že tento seznam ve výchozím nastavení zahrnuje všechno emitované do *wwwroot* (včetně obsahu dodaných externími balíčky a projekty), je nutné, abyste měli pozor, abyste do něj neumístili příliš mnoho obsahu.</span><span class="sxs-lookup"><span data-stu-id="14939-291">Since this list by default includes everything emitted to *wwwroot* (including content supplied by external packages and projects), you must be careful not to put too much content there.</span></span> <span data-ttu-id="14939-292">Pokud například adresář *wwwroot* obsahuje miliony imagí, pracovník služby by se pokusil načíst a uložit je do mezipaměti, což spotřebovává nadměrné šířky pásma a pravděpodobně se neúspěšně dokončuje.</span><span class="sxs-lookup"><span data-stu-id="14939-292">If for example your *wwwroot* directory contains millions of images, the service worker would try to fetch and cache them all, consuming excessive bandwidth and most likely not completing successfully.</span></span>

<span data-ttu-id="14939-293">Můžete implementovat libovolnou logiku pro řízení, které podmnožiny obsahu manifestu by měly být načteny a ukládány do mezipaměti úpravou funkce `onInstall` v *Service-Worker. Publish. js*.</span><span class="sxs-lookup"><span data-stu-id="14939-293">You can implement arbitrary logic to control which subset of the manifest's contents should be fetched and cached by editing the `onInstall` function in *service-worker.published.js*.</span></span>

### <a name="interaction-with-authentication"></a><span data-ttu-id="14939-294">Interakce s ověřováním</span><span class="sxs-lookup"><span data-stu-id="14939-294">Interaction with authentication</span></span>

<span data-ttu-id="14939-295">V kombinaci s možnostmi ověřování je možné použít šablonu PWA.</span><span class="sxs-lookup"><span data-stu-id="14939-295">It's possible to use the PWA template option in conjunction with the authentication options.</span></span> <span data-ttu-id="14939-296">Aplikace PWA podporující offline může také podporovat ověřování, když má uživatel připojení k síti.</span><span class="sxs-lookup"><span data-stu-id="14939-296">An offline-capable PWA can also support authentication when the user has network connectivity.</span></span>

<span data-ttu-id="14939-297">Pokud však uživatel nemá připojení k síti, nebude moci ověřit ani získat přístupové tokeny.</span><span class="sxs-lookup"><span data-stu-id="14939-297">However, when a user does not have network connectivity, they will not be able to authenticate or obtain access tokens.</span></span> <span data-ttu-id="14939-298">Při pokusu o návštěvě přihlašovací stránky se ve výchozím nastavení zobrazí zpráva oznamující "Chyba sítě".</span><span class="sxs-lookup"><span data-stu-id="14939-298">Attempting to visit the "login" page will by default display a message saying "network error".</span></span>

<span data-ttu-id="14939-299">V takovém případě je to vaše úloha navržení toku uživatelského rozhraní, který uživateli umožňuje pracovat v režimu offline bez nutnosti ověřit nebo získat přístupové tokeny nebo nejméně v těchto případech v případě bezproblémového fungování.</span><span class="sxs-lookup"><span data-stu-id="14939-299">As such it's your job to design a UI flow that lets the user do useful things while offline without attempting to authenticate or obtain access tokens, or at least failing in a graceful way in those cases.</span></span> <span data-ttu-id="14939-300">Pokud to není u vaší aplikace možné, možná nebudete chtít povolit podporu offline.</span><span class="sxs-lookup"><span data-stu-id="14939-300">If this isn't possible in your application, you might not want to enable offline support.</span></span>
