---
title: Testování řadiče logiku v ASP.NET Core
author: ardalis
description: Zjistěte, jak otestovat řadiče logiku v ASP.NET Core s Moq a xUnit.
manager: wpickett
ms.author: riande
ms.date: 10/14/2016
ms.prod: asp.net-core
ms.technology: aspnet
ms.topic: article
uid: mvc/controllers/testing
ms.openlocfilehash: 51b7a02c697807c9e3504b70f89370126ee0e781
ms.sourcegitcommit: 5130b3034165f5cf49d829fe7475a84aa33d2693
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 05/03/2018
---
# <a name="test-controller-logic-in-aspnet-core"></a><span data-ttu-id="c815a-103">Testování řadiče logiku v ASP.NET Core</span><span class="sxs-lookup"><span data-stu-id="c815a-103">Test controller logic in ASP.NET Core</span></span>

<span data-ttu-id="c815a-104">Podle [Steve Smith](https://ardalis.com/)</span><span class="sxs-lookup"><span data-stu-id="c815a-104">By [Steve Smith](https://ardalis.com/)</span></span>

<span data-ttu-id="c815a-105">Řadiče v aplikacích ASP.NET MVC musí být malé a zaměřují se na otázky uživatelského rozhraní.</span><span class="sxs-lookup"><span data-stu-id="c815a-105">Controllers in ASP.NET MVC apps should be small and focused on user-interface concerns.</span></span> <span data-ttu-id="c815a-106">Velké řadiče, které pracují s obavy bez uživatelského rozhraní je složité testování a údržbu.</span><span class="sxs-lookup"><span data-stu-id="c815a-106">Large controllers that deal with non-UI concerns are more difficult to test and maintain.</span></span>

[<span data-ttu-id="c815a-107">Zobrazení nebo stažení ukázky z webu GitHub</span><span class="sxs-lookup"><span data-stu-id="c815a-107">View or download sample from GitHub</span></span>](https://github.com/aspnet/Docs/tree/master/aspnetcore/mvc/controllers/testing/sample)

## <a name="testing-controllers"></a><span data-ttu-id="c815a-108">Testování řadiče</span><span class="sxs-lookup"><span data-stu-id="c815a-108">Testing controllers</span></span>

<span data-ttu-id="c815a-109">Řadiče jsou centrální součástí všech aplikací ASP.NET MVC jádra.</span><span class="sxs-lookup"><span data-stu-id="c815a-109">Controllers are a central part of any ASP.NET Core MVC application.</span></span> <span data-ttu-id="c815a-110">Jako takový měli byste mít přitom jistotu, že chovají se jako určený pro vaši aplikaci.</span><span class="sxs-lookup"><span data-stu-id="c815a-110">As such, you should have confidence they behave as intended for your app.</span></span> <span data-ttu-id="c815a-111">Automatizované testy vám může poskytnout tento spolehlivosti a chyby může zjistit, než dosáhnou produkční.</span><span class="sxs-lookup"><span data-stu-id="c815a-111">Automated tests can provide you with this confidence and can detect errors before they reach production.</span></span> <span data-ttu-id="c815a-112">Je důležité předejde nepotřebné odpovědnosti v rámci své řadiče a zkontrolovat vaše testy se zaměřují jen na odpovědnosti řadiče.</span><span class="sxs-lookup"><span data-stu-id="c815a-112">It's important to avoid placing unnecessary responsibilities within your controllers and ensure your tests focus only on controller responsibilities.</span></span>

<span data-ttu-id="c815a-113">Řadič logiku by měl být minimální a nesmí být zaměřené na obchodní logiku nebo infrastrukturu obavy (například přístup k datům).</span><span class="sxs-lookup"><span data-stu-id="c815a-113">Controller logic should be minimal and not be focused on business logic or infrastructure concerns (for example, data access).</span></span> <span data-ttu-id="c815a-114">Otestujte řadič logiku, není rozhraní.</span><span class="sxs-lookup"><span data-stu-id="c815a-114">Test controller logic, not the framework.</span></span> <span data-ttu-id="c815a-115">Test jak řadičem *chová* podle vstupy platný nebo neplatný.</span><span class="sxs-lookup"><span data-stu-id="c815a-115">Test how the controller *behaves* based on valid or invalid inputs.</span></span> <span data-ttu-id="c815a-116">Otestujte řadič odpovědí na základě výsledku operace firmy, které provádí.</span><span class="sxs-lookup"><span data-stu-id="c815a-116">Test controller responses based on the result of the business operation it performs.</span></span>

<span data-ttu-id="c815a-117">Typické řadiče zodpovědnosti:</span><span class="sxs-lookup"><span data-stu-id="c815a-117">Typical controller responsibilities:</span></span>

* <span data-ttu-id="c815a-118">Ověřte `ModelState.IsValid`.</span><span class="sxs-lookup"><span data-stu-id="c815a-118">Verify `ModelState.IsValid`.</span></span>
* <span data-ttu-id="c815a-119">Vrátí odpověď chyby, pokud `ModelState` je neplatný.</span><span class="sxs-lookup"><span data-stu-id="c815a-119">Return an error response if `ModelState` is invalid.</span></span>
* <span data-ttu-id="c815a-120">Načtení entity obchodní z trvalost.</span><span class="sxs-lookup"><span data-stu-id="c815a-120">Retrieve a business entity from persistence.</span></span>
* <span data-ttu-id="c815a-121">Provedení akce v obchodní entity.</span><span class="sxs-lookup"><span data-stu-id="c815a-121">Perform an action on the business entity.</span></span>
* <span data-ttu-id="c815a-122">Uložte obchodní entity do trvalost.</span><span class="sxs-lookup"><span data-stu-id="c815a-122">Save the business entity to persistence.</span></span>
* <span data-ttu-id="c815a-123">Vrátí odpovídající `IActionResult`.</span><span class="sxs-lookup"><span data-stu-id="c815a-123">Return an appropriate `IActionResult`.</span></span>

## <a name="unit-testing"></a><span data-ttu-id="c815a-124">Testování jednotek</span><span class="sxs-lookup"><span data-stu-id="c815a-124">Unit testing</span></span>

<span data-ttu-id="c815a-125">[Testování částí](/dotnet/articles/core/testing/unit-testing-with-dotnet-test) zahrnuje testování součástí aplikace izolovaně od jeho infrastruktury a závislosti.</span><span class="sxs-lookup"><span data-stu-id="c815a-125">[Unit testing](/dotnet/articles/core/testing/unit-testing-with-dotnet-test) involves testing a part of an app in isolation from its infrastructure and dependencies.</span></span> <span data-ttu-id="c815a-126">Při testování řadiče logiku, obsah jenom jednu akci testování částí, není chování jeho závislé součásti nebo rozhraní sám sebe.</span><span class="sxs-lookup"><span data-stu-id="c815a-126">When unit testing controller logic, only the contents of a single action is tested, not the behavior of its dependencies or of the framework itself.</span></span> <span data-ttu-id="c815a-127">Jako jednotku můžete otestovat vaše akce kontroleru, ujistěte se, že byste se zaměřit jenom na své chování.</span><span class="sxs-lookup"><span data-stu-id="c815a-127">As you unit test your controller actions, make sure you focus only on its behavior.</span></span> <span data-ttu-id="c815a-128">Testování částí řadiče zabraňuje třeba [filtry](filters.md), [směrování](../../fundamentals/routing.md), nebo [model vazby](../models/model-binding.md).</span><span class="sxs-lookup"><span data-stu-id="c815a-128">A controller unit test avoids things like [filters](filters.md), [routing](../../fundamentals/routing.md), or [model binding](../models/model-binding.md).</span></span> <span data-ttu-id="c815a-129">Se zaměříte na testování právě jednou z věcí, testy jednotek jsou obecně jednoduché k zápisu a rychlé spuštění.</span><span class="sxs-lookup"><span data-stu-id="c815a-129">By focusing on testing just one thing, unit tests are generally simple to write and quick to run.</span></span> <span data-ttu-id="c815a-130">Kvalitně sadu testů jednotek se může spouštět často bez mnoho zásahů.</span><span class="sxs-lookup"><span data-stu-id="c815a-130">A well-written set of unit tests can be run frequently without much overhead.</span></span> <span data-ttu-id="c815a-131">Testy jednotek však není rozpoznat problémy v interakci mezi součástmi, což je účelem [integrace testy](xref:mvc/controllers/testing#integration-testing).</span><span class="sxs-lookup"><span data-stu-id="c815a-131">However, unit tests don't detect issues in the interaction between components, which is the purpose of [integration tests](xref:mvc/controllers/testing#integration-testing).</span></span>

<span data-ttu-id="c815a-132">Pokud píšete vlastní filtry, tras atd., měli byste testování částí je, ale nikoli jako součást testy na určitý kontroler akce.</span><span class="sxs-lookup"><span data-stu-id="c815a-132">If you're writing custom filters, routes, etc, you should unit test them, but not as part of your tests on a particular controller action.</span></span> <span data-ttu-id="c815a-133">Musí být testovány v izolaci.</span><span class="sxs-lookup"><span data-stu-id="c815a-133">They should be tested in isolation.</span></span>

> [!TIP]
> <span data-ttu-id="c815a-134">[Vytvoření a spuštění testů jednotek pomocí sady Visual Studio](/visualstudio/test/unit-test-your-code).</span><span class="sxs-lookup"><span data-stu-id="c815a-134">[Create and run unit tests with Visual Studio](/visualstudio/test/unit-test-your-code).</span></span>

<span data-ttu-id="c815a-135">K předvedení testování částí, zkontrolujte následující řadiče.</span><span class="sxs-lookup"><span data-stu-id="c815a-135">To demonstrate unit testing, review the following controller.</span></span> <span data-ttu-id="c815a-136">Zobrazí seznam Debata relací a umožňuje nové Debata relací se vytvoří s příspěvku na:</span><span class="sxs-lookup"><span data-stu-id="c815a-136">It displays a list of brainstorming sessions and allows new brainstorming sessions to be created with a POST:</span></span>

[!code-csharp[](testing/sample/TestingControllersSample/src/TestingControllersSample/Controllers/HomeController.cs?highlight=12,16,21,42,43)]

<span data-ttu-id="c815a-137">Kontroleru je následující [explicitní závislosti Princip](http://deviq.com/explicit-dependencies-principle/), byla očekávána vkládání závislostí poskytnout instanci `IBrainstormSessionRepository`.</span><span class="sxs-lookup"><span data-stu-id="c815a-137">The controller is following the [explicit dependencies principle](http://deviq.com/explicit-dependencies-principle/), expecting dependency injection to provide it with an instance of `IBrainstormSessionRepository`.</span></span> <span data-ttu-id="c815a-138">Díky tomu je poměrně snadno testovat pomocí mock objektu rozhraní, jako je třeba [Moq](https://www.nuget.org/packages/Moq/).</span><span class="sxs-lookup"><span data-stu-id="c815a-138">This makes it fairly easy to test using a mock object framework, like [Moq](https://www.nuget.org/packages/Moq/).</span></span> <span data-ttu-id="c815a-139">`HTTP GET Index` Metoda má žádné opakování nebo větvení a pouze volání jednu metodu.</span><span class="sxs-lookup"><span data-stu-id="c815a-139">The `HTTP GET Index` method has no looping or branching and only calls one method.</span></span> <span data-ttu-id="c815a-140">Abyste to mohli otestovat `Index` metoda, potřebujeme ověřit, jestli `ViewResult` se vrátí, s `ViewModel` z v úložišti `List` metoda.</span><span class="sxs-lookup"><span data-stu-id="c815a-140">To test this `Index` method, we need to verify that a `ViewResult` is returned, with a `ViewModel` from the repository's `List` method.</span></span>

[!code-csharp[](testing/sample/TestingControllersSample/tests/TestingControllersSample.Tests/UnitTests/HomeControllerTests.cs?highlight=17-18&range=1-33,76-95)]

<span data-ttu-id="c815a-141">`HomeController` `HTTP POST Index` By měl ověřit – metoda (viz výše):</span><span class="sxs-lookup"><span data-stu-id="c815a-141">The `HomeController` `HTTP POST Index` method (shown above) should verify:</span></span>

* <span data-ttu-id="c815a-142">Metoda akce vrací chybný požadavek `ViewResult` s příslušná data při `ModelState.IsValid` je `false`</span><span class="sxs-lookup"><span data-stu-id="c815a-142">The action method returns a Bad Request `ViewResult` with the appropriate data when `ModelState.IsValid` is `false`</span></span>

* <span data-ttu-id="c815a-143">`Add` Je volána metoda na úložiště a `RedirectToActionResult` je vrácen s správné argumenty při `ModelState.IsValid` hodnotu true.</span><span class="sxs-lookup"><span data-stu-id="c815a-143">The `Add` method on the repository is called and a `RedirectToActionResult` is returned with the correct arguments when `ModelState.IsValid` is true.</span></span>

<span data-ttu-id="c815a-144">Neplatný stav modelu může být testována přidáním chyb s použitím `AddModelError` jak je znázorněno níže prvního testu.</span><span class="sxs-lookup"><span data-stu-id="c815a-144">Invalid model state can be tested by adding errors using `AddModelError` as shown in the first test below.</span></span>

[!code-csharp[](testing/sample/TestingControllersSample/tests/TestingControllersSample.Tests/UnitTests/HomeControllerTests.cs?highlight=8,15-16,37-39&range=35-75)]

<span data-ttu-id="c815a-145">První test potvrdí, kdy `ModelState` není platný, stejné `ViewResult` se vrátí jako pro `GET` požadavku.</span><span class="sxs-lookup"><span data-stu-id="c815a-145">The first test confirms when `ModelState` isn't valid, the same `ViewResult` is returned as for a `GET` request.</span></span> <span data-ttu-id="c815a-146">Všimněte si, že test není pokusí předat ve model neplatný.</span><span class="sxs-lookup"><span data-stu-id="c815a-146">Note that the test doesn't attempt to pass in an invalid model.</span></span> <span data-ttu-id="c815a-147">Že nebude fungovat přesto vzhledem k tomu, že není spuštěna vazby modelu (i když [integrace testovací](xref:mvc/controllers/testing#integration-testing) využije vazby modelu cvičení).</span><span class="sxs-lookup"><span data-stu-id="c815a-147">That wouldn't work anyway since model binding isn't running (though an [integration test](xref:mvc/controllers/testing#integration-testing) would use exercise model binding).</span></span> <span data-ttu-id="c815a-148">V takovém případě není testuje vazby modelu.</span><span class="sxs-lookup"><span data-stu-id="c815a-148">In this case, model binding isn't being tested.</span></span> <span data-ttu-id="c815a-149">Tyto testy jednotek jenom testujete, jaké jsou kód v metodě akce.</span><span class="sxs-lookup"><span data-stu-id="c815a-149">These unit tests are only testing what the code in the action method does.</span></span>

<span data-ttu-id="c815a-150">Druhý test ověřuje, že když `ModelState` je platný, nový `BrainstormSession` se přidá (prostřednictvím úložiště), a vrátí metodu `RedirectToActionResult` s očekávanou vlastností.</span><span class="sxs-lookup"><span data-stu-id="c815a-150">The second test verifies that when `ModelState` is valid, a new `BrainstormSession` is added (via the repository), and the method returns a `RedirectToActionResult` with the expected properties.</span></span> <span data-ttu-id="c815a-151">Mocked volání, které nejsou názvem jsou obvykle ignorováno, ale volání `Verifiable` na konci instalace volání umožňuje ověřit v testu.</span><span class="sxs-lookup"><span data-stu-id="c815a-151">Mocked calls that aren't called are normally ignored, but calling `Verifiable` at the end of the setup call allows it to be verified in the test.</span></span> <span data-ttu-id="c815a-152">To provedete pomocí volání `mockRepo.Verify`, který selže test, pokud nebyla volána metoda očekávané.</span><span class="sxs-lookup"><span data-stu-id="c815a-152">This is done with the call to `mockRepo.Verify`, which will fail the test if the expected method wasn't called.</span></span>

> [!NOTE]
> <span data-ttu-id="c815a-153">Knihovnou Moq používanou v této ukázce usnadňuje kombinovat ověřitelný nebo "striktní", mocks s nejsou ověřitelné mocks (také nazývané "přijít" mocks nebo zástupných procedur).</span><span class="sxs-lookup"><span data-stu-id="c815a-153">The Moq library used in this sample makes it easy to mix verifiable, or "strict", mocks with non-verifiable mocks (also called "loose" mocks or stubs).</span></span> <span data-ttu-id="c815a-154">Další informace o [přizpůsobení chování model s Moq](https://github.com/Moq/moq4/wiki/Quickstart#customizing-mock-behavior).</span><span class="sxs-lookup"><span data-stu-id="c815a-154">Learn more about [customizing Mock behavior with Moq](https://github.com/Moq/moq4/wiki/Quickstart#customizing-mock-behavior).</span></span>

<span data-ttu-id="c815a-155">Jiný řadič v aplikaci zobrazí informace týkající se konkrétní Debata relace.</span><span class="sxs-lookup"><span data-stu-id="c815a-155">Another controller in the app displays information related to a particular brainstorming session.</span></span> <span data-ttu-id="c815a-156">Obsahuje některé logiku pro řeší neplatné id hodnoty:</span><span class="sxs-lookup"><span data-stu-id="c815a-156">It includes some logic to deal with invalid id values:</span></span>

[!code-csharp[](./testing/sample/TestingControllersSample/src/TestingControllersSample/Controllers/SessionController.cs?highlight=19,20,21,22,25,26,27,28)]

<span data-ttu-id="c815a-157">Akce kontroleru má tři případech chcete otestovat, jeden pro každou `return` příkaz:</span><span class="sxs-lookup"><span data-stu-id="c815a-157">The controller action has three cases to test, one for each `return` statement:</span></span>

[!code-csharp[](testing/sample/TestingControllersSample/tests/TestingControllersSample.Tests/UnitTests/SessionControllerTests.cs?highlight=27,28,29,46,47,64,65,66,67,68)]

<span data-ttu-id="c815a-158">Aplikace zpřístupňuje funkci, jako webové rozhraní API (seznam nápady přidružené Debata relace a metody pro přidání nových nápadů do relace):</span><span class="sxs-lookup"><span data-stu-id="c815a-158">The app exposes functionality as a web API (a list of ideas associated with a brainstorming session and a method for adding new ideas to a session):</span></span>

<a name="ideas-controller"></a>

[!code-csharp[](testing/sample/TestingControllersSample/src/TestingControllersSample/Api/IdeasController.cs?highlight=21,22,27,30,31,32,33,34,35,36,41,42,46,52,65)]

<span data-ttu-id="c815a-159">`ForSession` Metoda vrátí seznam hodnot `IdeaDTO` typy.</span><span class="sxs-lookup"><span data-stu-id="c815a-159">The `ForSession` method returns a list of `IdeaDTO` types.</span></span> <span data-ttu-id="c815a-160">Vyhněte se vrací entity domény vaší firmy přímo prostřednictvím volání rozhraní API, protože často obsahují více dat, než klient rozhraní API vyžaduje, a jejich zbytečně spojte modelu interní domény vaší aplikace s rozhraním API vystavit externě.</span><span class="sxs-lookup"><span data-stu-id="c815a-160">Avoid returning your business domain entities directly via API calls, since frequently they include more data than the API client requires, and they unnecessarily couple your app's internal domain model with the API you expose externally.</span></span> <span data-ttu-id="c815a-161">Mapování mezi domény entity a typy, vrátíte se prostřednictvím sítě můžete provést ručně (pomocí LINQ `Select` jak je vidět tady) nebo pomocí knihovny jako [AutoMapper](https://github.com/AutoMapper/AutoMapper)</span><span class="sxs-lookup"><span data-stu-id="c815a-161">Mapping between domain entities and the types you will return over the wire can be done manually (using a LINQ `Select` as shown here) or using a library like [AutoMapper](https://github.com/AutoMapper/AutoMapper)</span></span>

<span data-ttu-id="c815a-162">Jednotka testů pro `Create` a `ForSession` metody rozhraní API:</span><span class="sxs-lookup"><span data-stu-id="c815a-162">The unit tests for the `Create` and `ForSession` API methods:</span></span>

[!code-csharp[](testing/sample/TestingControllersSample/tests/TestingControllersSample.Tests/UnitTests/ApiIdeasControllerTests.cs?highlight=18,23,29,33,38-39,43,50,58-59,68-70,76-78&range=1-83,121-135)]

<span data-ttu-id="c815a-163">Jak už jsme si říkali, k testování chování metodu při `ModelState` je neplatný, přidejte k řadiči chybu modelu v rámci testu.</span><span class="sxs-lookup"><span data-stu-id="c815a-163">As stated previously, to test the behavior of the method when `ModelState` is invalid, add a model error to the controller as part of the test.</span></span> <span data-ttu-id="c815a-164">Nepokoušejte se otestovat ověření nebo model vazby modelu v testů jednotek - právě testovací metody akce chování-li čelit konkrétní `ModelState` hodnotu.</span><span class="sxs-lookup"><span data-stu-id="c815a-164">Don't try to test model validation or model binding in your unit tests - just test your action method's behavior when confronted with a particular `ModelState` value.</span></span>

<span data-ttu-id="c815a-165">Druhý test závisí na úložiště vrací hodnotu null, takže imitované úložiště je nakonfigurovaný k vrácení hodnoty null.</span><span class="sxs-lookup"><span data-stu-id="c815a-165">The second test depends on the repository returning null, so the mock repository is configured to return null.</span></span> <span data-ttu-id="c815a-166">Není nutné k vytvoření testovací databáze (v paměti nebo jinak) a sestavte dotaz, který vrátí tento výsledek – je možné ji provést v jediném příkazu, jak je vidět.</span><span class="sxs-lookup"><span data-stu-id="c815a-166">There's no need to create a test database (in memory or otherwise) and construct a query that will return this result - it can be done in a single statement as shown.</span></span>

<span data-ttu-id="c815a-167">Poslední test ověřuje, že v úložišti `Update` metoda je volána.</span><span class="sxs-lookup"><span data-stu-id="c815a-167">The last test verifies that the repository's `Update` method is called.</span></span> <span data-ttu-id="c815a-168">Jako jsme to udělali dřív, model je volán s `Verifiable` a pak mocked v úložišti `Verify` metoda je volána potvrďte ověřitelný metoda byla spuštěna.</span><span class="sxs-lookup"><span data-stu-id="c815a-168">As we did previously, the mock is called with `Verifiable` and then the mocked repository's `Verify` method is called to confirm the verifiable method was executed.</span></span> <span data-ttu-id="c815a-169">Není odpovědnost test jednotky zajistit, aby `Update` metoda uložit data; to můžete udělat pomocí test integrace.</span><span class="sxs-lookup"><span data-stu-id="c815a-169">It's not a unit test responsibility to ensure that the `Update` method saved the data; that can be done with an integration test.</span></span>

## <a name="integration-testing"></a><span data-ttu-id="c815a-170">Testování integrace</span><span class="sxs-lookup"><span data-stu-id="c815a-170">Integration testing</span></span>

<span data-ttu-id="c815a-171">[Integrace testy](../../testing/integration-testing.md) slouží k zajištění samostatné moduly v práci aplikace správně společně.</span><span class="sxs-lookup"><span data-stu-id="c815a-171">[Integration tests](../../testing/integration-testing.md) is done to ensure separate modules within your app work correctly together.</span></span> <span data-ttu-id="c815a-172">Obecně platí nic, co můžete otestovat s testů jednotek, můžete také otestovat s test integrace, ale naopak není pravda.</span><span class="sxs-lookup"><span data-stu-id="c815a-172">Generally, anything you can test with a unit test, you can also test with an integration test, but the reverse isn't true.</span></span> <span data-ttu-id="c815a-173">Ale integrace testů jsou obvykle mnohem nižší než testování částí.</span><span class="sxs-lookup"><span data-stu-id="c815a-173">However, integration tests tend to be much slower than unit tests.</span></span> <span data-ttu-id="c815a-174">Proto je nejvhodnější pro testování ať můžete pomocí jednotkových testů a použít integrace testy pro scénáře, které zahrnují více spolupracovníci.</span><span class="sxs-lookup"><span data-stu-id="c815a-174">Thus, it's best to test whatever you can with unit tests, and use integration tests for scenarios that involve multiple collaborators.</span></span>

<span data-ttu-id="c815a-175">I když může být stále užitečné, se v testech integrace zřídka používají mock objektů.</span><span class="sxs-lookup"><span data-stu-id="c815a-175">Although they may still be useful, mock objects are rarely used in integration tests.</span></span> <span data-ttu-id="c815a-176">V jednotce testování jsou mock objektů efektivní způsob, jak řídit chování spolupracovníci mimo jednotky během testování pro testovací účely.</span><span class="sxs-lookup"><span data-stu-id="c815a-176">In unit testing, mock objects are an effective way to control how collaborators outside of the unit being tested should behave for the purposes of the test.</span></span> <span data-ttu-id="c815a-177">V test integrace skutečné spolupracovníci používají a ověřte, zda že celý subsystému společně správně funguje.</span><span class="sxs-lookup"><span data-stu-id="c815a-177">In an integration test, real collaborators are used to confirm the whole subsystem works together correctly.</span></span>

### <a name="application-state"></a><span data-ttu-id="c815a-178">Stav aplikace</span><span class="sxs-lookup"><span data-stu-id="c815a-178">Application state</span></span>

<span data-ttu-id="c815a-179">Jeden důležitý aspekt při provádění testování integrace spočívá v tom, jak nastavit stav vaší aplikace.</span><span class="sxs-lookup"><span data-stu-id="c815a-179">One important consideration when performing integration testing is how to set your app's state.</span></span> <span data-ttu-id="c815a-180">Testy muset spustit nezávisle na sobě, a proto by se měl spustit všechny testy s aplikací v známého stavu.</span><span class="sxs-lookup"><span data-stu-id="c815a-180">Tests need to run independent of one another, and so each test should start with the app in a known state.</span></span> <span data-ttu-id="c815a-181">Pokud vaše aplikace není použít databázi nebo mít žádné trvalost, nemusí to být problém.</span><span class="sxs-lookup"><span data-stu-id="c815a-181">If your app doesn't use a database or have any persistence, this may not be an issue.</span></span> <span data-ttu-id="c815a-182">Většinu aplikací reálného však zachovat jejich stavu pro nějaký druh úložiště dat, všechny změny provedené jeden test by mohlo mít vliv jiného testu, pokud se vynuluje úložiště dat.</span><span class="sxs-lookup"><span data-stu-id="c815a-182">However, most real-world apps persist their state to some kind of data store, so any modifications made by one test could impact another test unless the data store is reset.</span></span> <span data-ttu-id="c815a-183">Pomocí integrovaných `TestServer`, je velmi jednoduchá do hostitele aplikací ASP.NET Core v testech integrace, ale který nutně neuděluje přístup k datům se bude používat.</span><span class="sxs-lookup"><span data-stu-id="c815a-183">Using the built-in `TestServer`, it's very straightforward to host ASP.NET Core apps within our integration tests, but that doesn't necessarily grant access to the data it will use.</span></span> <span data-ttu-id="c815a-184">Pokud používáte skutečné databáze, jeden z přístupů je tak, aby měl aplikaci připojit k databázi test, testy můžete přístup a ujistěte se, je před každým testem resetovat do známého stavu.</span><span class="sxs-lookup"><span data-stu-id="c815a-184">If you're using an actual database, one approach is to have the app connect to a test database, which your tests can access and ensure is reset to a known state before each test executes.</span></span>

<span data-ttu-id="c815a-185">V této ukázkové aplikaci používám podporu InMemoryDatabase Entity Framework Core, takže jen z nelze připojit k němu Moje testovacího projektu.</span><span class="sxs-lookup"><span data-stu-id="c815a-185">In this sample application, I'm using Entity Framework Core's InMemoryDatabase support, so I can't just connect to it from my test project.</span></span> <span data-ttu-id="c815a-186">Místo toho I vystavit `InitializeDatabase` metoda z aplikace `Startup` třídy, které můžu volat při spuštění aplikace, pokud se nachází v `Development` prostředí.</span><span class="sxs-lookup"><span data-stu-id="c815a-186">Instead, I expose an `InitializeDatabase` method from the app's `Startup` class, which I call when the app starts up if it's in the `Development` environment.</span></span> <span data-ttu-id="c815a-187">Moje integrace testy automaticky těžit z tohoto tak dlouho, dokud se nastavit prostředí `Development`.</span><span class="sxs-lookup"><span data-stu-id="c815a-187">My integration tests automatically benefit from this as long as they set the environment to `Development`.</span></span> <span data-ttu-id="c815a-188">Nemám starat o obnovení databáze, protože InMemoryDatabase se vynuluje pokaždé, když aplikace restartuje.</span><span class="sxs-lookup"><span data-stu-id="c815a-188">I don't have to worry about resetting the database, since the InMemoryDatabase is reset each time the app restarts.</span></span>

<span data-ttu-id="c815a-189">`Startup` Třídy:</span><span class="sxs-lookup"><span data-stu-id="c815a-189">The `Startup` class:</span></span>

[!code-csharp[](testing/sample/TestingControllersSample/src/TestingControllersSample/Startup.cs?highlight=19,20,34,35,43,52)]

<span data-ttu-id="c815a-190">Zobrazí se `GetTestSession` metoda často používají v testech integrace níže.</span><span class="sxs-lookup"><span data-stu-id="c815a-190">You'll see the `GetTestSession` method used frequently in the integration tests below.</span></span>

### <a name="accessing-views"></a><span data-ttu-id="c815a-191">Přístup k zobrazení</span><span class="sxs-lookup"><span data-stu-id="c815a-191">Accessing views</span></span>

<span data-ttu-id="c815a-192">Každá třída testovací integrace nakonfiguruje `TestServer` který se spustí aplikace ASP.NET Core.</span><span class="sxs-lookup"><span data-stu-id="c815a-192">Each integration test class configures the `TestServer` that will run the ASP.NET Core app.</span></span> <span data-ttu-id="c815a-193">Ve výchozím nastavení `TestServer` hostuje webové aplikace ve složce, kde běží – v takovém případě složce projektu testu.</span><span class="sxs-lookup"><span data-stu-id="c815a-193">By default, `TestServer` hosts the web app in the folder where it's running - in this case, the test project folder.</span></span> <span data-ttu-id="c815a-194">Proto když zkusíte testovací akce kontroleru, které vracejí `ViewResult`, může se tato chyba:</span><span class="sxs-lookup"><span data-stu-id="c815a-194">Thus, when you attempt to test controller actions that return `ViewResult`, you may see this error:</span></span>

```
The view 'Index' wasn't found. The following locations were searched:
(list of locations)
```

<span data-ttu-id="c815a-195">Chcete-li opravit tento problém, nakonfigurujte kořenového serveru obsahu, tak, aby mohl vyhledat umístění zobrazení pro projekt testuje.</span><span class="sxs-lookup"><span data-stu-id="c815a-195">To correct this issue, you need to configure the server's content root, so it can locate the views for the project being tested.</span></span> <span data-ttu-id="c815a-196">To se provádí volání `UseContentRoot` v `TestFixture` třída, vidíte níže:</span><span class="sxs-lookup"><span data-stu-id="c815a-196">This is done by a call to `UseContentRoot` in the `TestFixture` class, shown below:</span></span>

[!code-csharp[](testing/sample/TestingControllersSample/tests/TestingControllersSample.Tests/IntegrationTests/TestFixture.cs?highlight=30,33)]

<span data-ttu-id="c815a-197">`TestFixture` Třída je zodpovědná za konfiguraci a vytváření `TestServer`, nastavuje se `HttpClient` ke komunikaci s `TestServer`.</span><span class="sxs-lookup"><span data-stu-id="c815a-197">The `TestFixture` class is responsible for configuring and creating the `TestServer`, setting up an `HttpClient` to communicate with the `TestServer`.</span></span> <span data-ttu-id="c815a-198">Každý integraci testy používá `Client` vlastnost pro připojení k serveru test a podání žádosti o.</span><span class="sxs-lookup"><span data-stu-id="c815a-198">Each of the integration tests uses the `Client` property to connect to the test server and make a request.</span></span>

[!code-csharp[](testing/sample/TestingControllersSample/tests/TestingControllersSample.Tests/IntegrationTests/HomeControllerTests.cs?highlight=20,26,29,30,31,35,38,39,40,41,44,47,48)]

<span data-ttu-id="c815a-199">V první testu výše `responseString` obsahuje skutečnou vykreslení HTML ze zobrazení, které mohly být zkontrolovány a ověřit tak obsahuje očekávané výsledky.</span><span class="sxs-lookup"><span data-stu-id="c815a-199">In the first test above, the `responseString` holds the actual rendered HTML from the View, which can be inspected to confirm it contains expected results.</span></span>

<span data-ttu-id="c815a-200">Druhý test vytvoří operací POST formuláře s názvem jedinečný relace a odešle ji do aplikace a pak ověřuje, že se vrátí očekávané přesměrování.</span><span class="sxs-lookup"><span data-stu-id="c815a-200">The second test constructs a form POST with a unique session name and POSTs it to the app, then verifies that the expected redirect is returned.</span></span>

### <a name="api-methods"></a><span data-ttu-id="c815a-201">Metody rozhraní API</span><span class="sxs-lookup"><span data-stu-id="c815a-201">API methods</span></span>

<span data-ttu-id="c815a-202">Pokud vaše aplikace zpřístupní webové rozhraní API, jeho vhodné mít automatizovaných testů potvrďte, že provést podle očekávání.</span><span class="sxs-lookup"><span data-stu-id="c815a-202">If your app exposes web APIs, it's a good idea to have automated tests confirm they execute as expected.</span></span> <span data-ttu-id="c815a-203">Integrované `TestServer` usnadňuje testování webových rozhraní API.</span><span class="sxs-lookup"><span data-stu-id="c815a-203">The built-in `TestServer` makes it easy to test web APIs.</span></span> <span data-ttu-id="c815a-204">Pokud vaše rozhraní API metody používají vazby modelu, byste měli vždy zkontrolovat `ModelState.IsValid`, a integrace testů jsou na správném místě potvrďte, že vaše ověření modelu funguje správně.</span><span class="sxs-lookup"><span data-stu-id="c815a-204">If your API methods are using model binding, you should always check `ModelState.IsValid`, and integration tests are the right place to confirm that your model validation is working properly.</span></span>

<span data-ttu-id="c815a-205">Následující sadu testů cíl `Create` metoda v [IdeasController](xref:mvc/controllers/testing#ideas-controller) třídy uvedené výše:</span><span class="sxs-lookup"><span data-stu-id="c815a-205">The following set of tests target the `Create` method in the [IdeasController](xref:mvc/controllers/testing#ideas-controller) class shown above:</span></span>

[!code-csharp[](testing/sample/TestingControllersSample/tests/TestingControllersSample.Tests/IntegrationTests/ApiIdeasControllerTests.cs)]

<span data-ttu-id="c815a-206">Na rozdíl od integrace testy akcí, které vrátí HTML zobrazení webového rozhraní API metody, které vracejí výsledky obvykle lze deserializovat jako objektů se silným typem, jak ukazuje poslední test výše.</span><span class="sxs-lookup"><span data-stu-id="c815a-206">Unlike integration tests of actions that returns HTML views, web API methods that return results can usually be deserialized as strongly typed objects, as the last test above shows.</span></span> <span data-ttu-id="c815a-207">V takovém případě, test deserializuje výsledek, který má `BrainstormSession` instance a potvrdí, že na nápad správně přidaná do jeho kolekce návrhy.</span><span class="sxs-lookup"><span data-stu-id="c815a-207">In this case, the test deserializes the result to a `BrainstormSession` instance, and confirms that the idea was correctly added to its collection of ideas.</span></span>

<span data-ttu-id="c815a-208">V tomto článku najdete další příklady integrace testů [ukázkový projekt](https://github.com/aspnet/Docs/tree/master/aspnetcore/mvc/controllers/testing/sample).</span><span class="sxs-lookup"><span data-stu-id="c815a-208">You'll find additional examples of integration tests in this article's [sample project](https://github.com/aspnet/Docs/tree/master/aspnetcore/mvc/controllers/testing/sample).</span></span>
