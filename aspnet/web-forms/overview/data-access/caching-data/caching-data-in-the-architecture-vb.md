---
uid: web-forms/overview/data-access/caching-data/caching-data-in-the-architecture-vb
title: "Ukládání dat v architektuře (VB) | Microsoft Docs"
author: rick-anderson
description: "V předchozích kurzu jsme zjistili, jak použít ukládání do mezipaměti na prezentační vrstvy. V tomto kurzu jsme zjistěte, jak využívat naše vrstveného architectu..."
ms.author: aspnetcontent
manager: wpickett
ms.date: 05/30/2007
ms.topic: article
ms.assetid: 5e189dd7-f4f9-4f28-9b3a-6cb7d392e9c7
ms.technology: dotnet-webforms
ms.prod: .net-framework
msc.legacyurl: /web-forms/overview/data-access/caching-data/caching-data-in-the-architecture-vb
msc.type: authoredcontent
ms.openlocfilehash: 1aca89b022bb3bb7e4154ab575b5bb5513144cd5
ms.sourcegitcommit: 060879fcf3f73d2366b5c811986f8695fff65db8
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 01/24/2018
---
<a name="caching-data-in-the-architecture-vb"></a><span data-ttu-id="b7c5f-104">Ukládání dat v architektuře (VB)</span><span class="sxs-lookup"><span data-stu-id="b7c5f-104">Caching Data in the Architecture (VB)</span></span>
====================
<span data-ttu-id="b7c5f-105">podle [Scott Meisnerová](https://twitter.com/ScottOnWriting)</span><span class="sxs-lookup"><span data-stu-id="b7c5f-105">by [Scott Mitchell](https://twitter.com/ScottOnWriting)</span></span>

<span data-ttu-id="b7c5f-106">[Stáhněte si ukázkovou aplikaci](http://download.microsoft.com/download/4/a/7/4a7a3b18-d80e-4014-8e53-a6a2427f0d93/ASPNET_Data_Tutorial_59_VB.exe) nebo [stáhnout PDF](caching-data-in-the-architecture-vb/_static/datatutorial59vb1.pdf)</span><span class="sxs-lookup"><span data-stu-id="b7c5f-106">[Download Sample App](http://download.microsoft.com/download/4/a/7/4a7a3b18-d80e-4014-8e53-a6a2427f0d93/ASPNET_Data_Tutorial_59_VB.exe) or [Download PDF](caching-data-in-the-architecture-vb/_static/datatutorial59vb1.pdf)</span></span>

> <span data-ttu-id="b7c5f-107">V předchozích kurzu jsme zjistili, jak použít ukládání do mezipaměti na prezentační vrstvy.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-107">In the previous tutorial we learned how to apply caching at the Presentation Layer.</span></span> <span data-ttu-id="b7c5f-108">V tomto kurzu jsme zjistěte, jak využívat naše Vrstvená architektura ukládat data do mezipaměti na vrstvu obchodní logiky.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-108">In this tutorial we learn how to take advantage of our layered architecture to cache data at the Business Logic Layer.</span></span> <span data-ttu-id="b7c5f-109">Provedeme to tím, že rozšíří architektura zahrnout vrstva ukládání do mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-109">We do this by extending the architecture to include a Caching Layer.</span></span>


## <a name="introduction"></a><span data-ttu-id="b7c5f-110">Úvod</span><span class="sxs-lookup"><span data-stu-id="b7c5f-110">Introduction</span></span>

<span data-ttu-id="b7c5f-111">Jak jsme viděli v předchozím kurzu, ukládání do mezipaměti ObjectDataSource s data je stejně jednoduché jako nastavení několik vlastností.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-111">As we saw in the preceding tutorial, caching the ObjectDataSource s data is as simple as setting a couple of properties.</span></span> <span data-ttu-id="b7c5f-112">Bohužel ObjectDataSource platí ukládání do mezipaměti na prezentační vrstvu, která pevně spojuje zásad ukládání do mezipaměti s stránku ASP.NET.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-112">Unfortunately, the ObjectDataSource applies caching at the Presentation Layer, which tightly couples the caching policies with the ASP.NET page.</span></span> <span data-ttu-id="b7c5f-113">Jedním z důvodů pro vytváření Vrstvená architektura je umožnit takové spojovací zařízení je přerušeno.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-113">One of the reasons for creating a layered architecture is to allow such couplings to be broken.</span></span> <span data-ttu-id="b7c5f-114">Vrstvu obchodní logiky, například oddělí obchodní logiky ze stránky ASP.NET při Data Access Layer oddělí podrobnosti o přístupu dat.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-114">The Business Logic Layer, for instance, decouples the business logic from the ASP.NET pages, while the Data Access Layer decouples the data access details.</span></span> <span data-ttu-id="b7c5f-115">Díky tomuto oddělení podrobnosti o přístupu obchodní logiku a data je preferovaná, součást, protože umožňuje systému lépe čitelný, více udržovatelný a flexibilnější, chcete-li změnit.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-115">This decoupling of business logic and data access details is preferred, in part, because it makes the system more readable, more maintainable, and more flexible to change.</span></span> <span data-ttu-id="b7c5f-116">Umožňuje také pro domény znalosti a rozdělení práce vývojář pracující na t nemá prezentační vrstvy musí být obeznámeni s podrobnostmi databáze s cílem provést jeho úlohy.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-116">It also allows for domain knowledge and division of labor a developer working on the Presentation Layer doesn t need to be familiar with the database s details in order to do her job.</span></span> <span data-ttu-id="b7c5f-117">Oddělení zásady ukládání do mezipaměti od prezentační vrstvy nabízí podobné výhody.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-117">Decoupling the caching policy from the Presentation Layer offers similar benefits.</span></span>

<span data-ttu-id="b7c5f-118">V tomto kurzu jsme se posílení Naše architektura zahrnout *ukládání do mezipaměti vrstvy* (nebo pro zkrácení CL), využívá naše zásady ukládání do mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-118">In this tutorial we will augment our architecture to include a *Caching Layer* (or CL for short) that employs our caching policy.</span></span> <span data-ttu-id="b7c5f-119">Bude obsahovat vrstvě ukládání do mezipaměti `ProductsCL` třídu, která poskytuje přístup k produktu informace metody, třeba `GetProducts()`, `GetProductsByCategoryID(categoryID)`, a tak dále, že při vyvolání, bude první pokus o načtení dat z mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-119">The Caching Layer will include a `ProductsCL` class that provides access to product information with methods like `GetProducts()`, `GetProductsByCategoryID(categoryID)`, and so forth, that, when invoked, will first attempt to retrieve the data from the cache.</span></span> <span data-ttu-id="b7c5f-120">Pokud mezipaměti je prázdná, budou tyto metody vyvolání odpovídající `ProductsBLL` metoda v BLL, které by naopak získat data z vrstvy DAL.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-120">If the cache is empty, these methods will invoke the appropriate `ProductsBLL` method in the BLL, which would in turn get the data from the DAL.</span></span> <span data-ttu-id="b7c5f-121">`ProductsCL` Metody mezipaměti data načtená z BLL před vrácením.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-121">The `ProductsCL` methods cache the data retrieved from the BLL before returning it.</span></span>

<span data-ttu-id="b7c5f-122">Jak ukazuje obrázek 1, nachází CL mezi prezentační a obchodní logiku vrstvy.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-122">As Figure 1 shows, the CL resides between the Presentation and Business Logic Layers.</span></span>


![Ukládání do mezipaměti vrstvy (CL) je další vrstvu v Naše architektura](caching-data-in-the-architecture-vb/_static/image1.png)

<span data-ttu-id="b7c5f-124">**Obrázek 1**: ukládání do mezipaměti vrstvy (CL) je další vrstvu v Naše architektura</span><span class="sxs-lookup"><span data-stu-id="b7c5f-124">**Figure 1**: The Caching Layer (CL) is Another Layer in Our Architecture</span></span>


## <a name="step-1-creating-the-caching-layer-classes"></a><span data-ttu-id="b7c5f-125">Krok 1: Vytvoření ukládání do mezipaměti vrstva tříd</span><span class="sxs-lookup"><span data-stu-id="b7c5f-125">Step 1: Creating the Caching Layer Classes</span></span>

<span data-ttu-id="b7c5f-126">V tomto kurzu vytvoříme velmi jednoduché CL s jednu třídu `ProductsCL` má pouze několik metod.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-126">In this tutorial we will create a very simple CL with a single class `ProductsCL` that has only a handful of methods.</span></span> <span data-ttu-id="b7c5f-127">Vytváření vrstva dokončení ukládání do mezipaměti pro celou aplikaci by vyžadovaly vytváření `CategoriesCL`, `EmployeesCL`, a `SuppliersCL` třídy a nabízí metody v těchto tříd vrstvy ukládání do mezipaměti pro každou metodu data přístup nebo změna v BLL.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-127">Building a complete Caching Layer for the entire application would require creating `CategoriesCL`, `EmployeesCL`, and `SuppliersCL` classes, and providing a method in these Caching Layer classes for each data access or modification method in the BLL.</span></span> <span data-ttu-id="b7c5f-128">Stejně jako u BLL a DAL, by měla být v ideálním případě implementována vrstvě ukládání do mezipaměti jako samostatné projektu knihovny tříd. ale jsme se implementaci jako třída v `App_Code` složky.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-128">As with the BLL and DAL, the Caching Layer should ideally be implemented as a separate Class Library project; however, we will implement it as a class in the `App_Code` folder.</span></span>

<span data-ttu-id="b7c5f-129">Na další samostatné této aplikace CL třídy od třídy DAL a BLL umožňují s vytvořte novou podsložku v `App_Code` složky.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-129">To more cleanly separate the CL classes from the DAL and BLL classes, let s create a new subfolder in the `App_Code` folder.</span></span> <span data-ttu-id="b7c5f-130">Klikněte pravým tlačítkem na `App_Code` složky v Průzkumníku řešení, vyberte novou složku a název nové složky `CL`.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-130">Right-click on the `App_Code` folder in the Solution Explorer, choose New Folder, and name the new folder `CL`.</span></span> <span data-ttu-id="b7c5f-131">Po vytvoření této složky, přidejte do ní novou třídu s názvem `ProductsCL.vb`.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-131">After creating this folder, add to it a new class named `ProductsCL.vb`.</span></span>


![Přidat novou složku s názvem CL a třídy s názvem ProductsCL.vb](caching-data-in-the-architecture-vb/_static/image2.png)

<span data-ttu-id="b7c5f-133">**Obrázek 2**: přidejte novou složku s názvem `CL` a třídy s názvem`ProductsCL.vb`</span><span class="sxs-lookup"><span data-stu-id="b7c5f-133">**Figure 2**: Add a New Folder Named `CL` and a Class Named `ProductsCL.vb`</span></span>


<span data-ttu-id="b7c5f-134">`ProductsCL` Třída by měla obsahovat stejnou sadu dat přístup a úpravy metody, jak se nachází v jeho odpovídající třídě vrstvu obchodní logiky (`ProductsBLL`).</span><span class="sxs-lookup"><span data-stu-id="b7c5f-134">The `ProductsCL` class should include the same set of data access and modification methods as found in its corresponding Business Logic Layer class (`ProductsBLL`).</span></span> <span data-ttu-id="b7c5f-135">Místo vytváření všechny tyto metody umožňují s jenom sestavení několik zde podívat, pro vzory používá CL.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-135">Rather than creating all of these methods, let s just build a couple here to get a feel for the patterns used by the CL.</span></span> <span data-ttu-id="b7c5f-136">Konkrétně přidáme `GetProducts()` a `GetProductsByCategoryID(categoryID)` metody v kroku 3 a `UpdateProduct` přetížení v kroku 4.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-136">In particular, we'll add the `GetProducts()` and `GetProductsByCategoryID(categoryID)` methods in Step 3 and an `UpdateProduct` overload in Step 4.</span></span> <span data-ttu-id="b7c5f-137">Můžete přidat zbývající `ProductsCL` metody a `CategoriesCL`, `EmployeesCL`, a `SuppliersCL` třídy ve volném čase.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-137">You can add the remaining `ProductsCL` methods and `CategoriesCL`, `EmployeesCL`, and `SuppliersCL` classes at your leisure.</span></span>

## <a name="step-2-reading-and-writing-to-the-data-cache"></a><span data-ttu-id="b7c5f-138">Krok 2: Čtení a zápis do mezipaměti dat</span><span class="sxs-lookup"><span data-stu-id="b7c5f-138">Step 2: Reading and Writing to the Data Cache</span></span>

<span data-ttu-id="b7c5f-139">ObjectDataSource ukládání do mezipaměti funkce prozkoumali v předchozím kurzu interně používá k ukládání data načtená z BLL data mezipaměti technologie ASP.NET.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-139">The ObjectDataSource caching feature explored in the preceding tutorial internally uses the ASP.NET data cache to store the data retrieved from the BLL.</span></span> <span data-ttu-id="b7c5f-140">Mezipaměť dat také je možné programově přistupovat z třídy kódu stránky ASP.NET nebo z třídy v architektuře s webové aplikace.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-140">The data cache can also be accessed programmatically from ASP.NET pages code-behind classes or from the classes in the web application s architecture.</span></span> <span data-ttu-id="b7c5f-141">Ke čtení a zápisu do mezipaměti data z třídy kódu s stránka technologie ASP.NET, používají následující vzorec:</span><span class="sxs-lookup"><span data-stu-id="b7c5f-141">To read and write to the data cache from an ASP.NET page s code-behind class, use the following pattern:</span></span>


[!code-vb[Main](caching-data-in-the-architecture-vb/samples/sample1.vb)]

<span data-ttu-id="b7c5f-142">[ `Cache` Třída](https://msdn.microsoft.com/library/system.web.caching.cache.aspx) s [ `Insert` metoda](https://msdn.microsoft.com/library/system.web.caching.cache.insert.aspx) má několik přetížení.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-142">The [`Cache` class](https://msdn.microsoft.com/library/system.web.caching.cache.aspx) s [`Insert` method](https://msdn.microsoft.com/library/system.web.caching.cache.insert.aspx) has a number of overloads.</span></span> <span data-ttu-id="b7c5f-143">`Cache("key") = value`a `Cache.Insert(key, value)` jsou synonyma a jak přidat položku do mezipaměti pomocí zadaného klíče bez definované vypršení platnosti.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-143">`Cache("key") = value` and `Cache.Insert(key, value)` are synonymous and both add an item to the cache using the specified key without a defined expiry.</span></span> <span data-ttu-id="b7c5f-144">Obvykle chceme zadejte vypršela platnost při přidání položky do mezipaměti, buď jako závislost, na základě času vypršení platnosti nebo obojí.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-144">Typically, we want to specify an expiry when adding an item to the cache, either as a dependency, a time-based expiry, or both.</span></span> <span data-ttu-id="b7c5f-145">Použijte jednu z dalších `Insert` přetížení metody s poskytnout informace na základě závislostí nebo čas vypršení platnosti.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-145">Use one of the other `Insert` method s overloads to provide dependency- or time-based expiry information.</span></span>

<span data-ttu-id="b7c5f-146">Ukládání do mezipaměti vrstvu, kterou s metody muset nejdřív zkontrolujte, zda požadovaná data jsou v mezipaměti a pokud ano, vrátí se z ní.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-146">The Caching Layer s methods need to first check if the requested data is in the cache and, if so, return it from there.</span></span> <span data-ttu-id="b7c5f-147">Pokud není požadovaná data v mezipaměti, odpovídající metodu BLL musí být volána.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-147">If the requested data is not in the cache, the appropriate BLL method needs to be invoked.</span></span> <span data-ttu-id="b7c5f-148">Vrácená hodnota by měla do mezipaměti a poté vrácen, jak ukazuje následující diagram pořadí.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-148">Its return value should be cached and then returned, as the following sequence diagram illustrates.</span></span>


![Metody s ukládání do mezipaměti vrstvy vrátit Data z mezipaměti, pokud je k dispozici s](caching-data-in-the-architecture-vb/_static/image3.png)

<span data-ttu-id="b7c5f-150">**Obrázek 3**: vrstvy ukládání do mezipaměti s metody vrátit Data z mezipaměti, pokud je k dispozici s</span><span class="sxs-lookup"><span data-stu-id="b7c5f-150">**Figure 3**: The Caching Layer s Methods Return Data from the Cache if it s Available</span></span>


<span data-ttu-id="b7c5f-151">Pořadí znázorněný na obrázku 3 je provést v třídách CL pomocí následujícího vzorce:</span><span class="sxs-lookup"><span data-stu-id="b7c5f-151">The sequence depicted in Figure 3 is accomplished in the CL classes using the following pattern:</span></span>


[!code-vb[Main](caching-data-in-the-architecture-vb/samples/sample2.vb)]

<span data-ttu-id="b7c5f-152">Zde *typ* je typu dat, které jsou uložené v mezipaměti `Northwind.ProductsDataTable`, například *klíč* klíč, který jednoznačně identifikuje položku mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-152">Here, *Type* is the type of data being stored in the cache `Northwind.ProductsDataTable`, for example while *key* is the key that uniquely identifies the cache item.</span></span> <span data-ttu-id="b7c5f-153">Pokud položka se zadaným *klíč* není v mezipaměti, pak *instance* bude `Nothing` a data budou načtena z odpovídající metodu BLL a přidány do mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-153">If the item with the specified *key* is not in the cache, then *instance* will be `Nothing` and the data will be retrieved from the appropriate BLL method and added to the cache.</span></span> <span data-ttu-id="b7c5f-154">V čase `Return instance` je dosaženo, *instance* obsahuje odkaz na data, buď z mezipaměti nebo stažen z BLL.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-154">By the time `Return instance` is reached, *instance* contains a reference to the data, either from the cache or pulled from the BLL.</span></span>

<span data-ttu-id="b7c5f-155">Ujistěte se, že použití výše vzoru při přístupu k datům z mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-155">Be sure to use the above pattern when accessing data from the cache.</span></span> <span data-ttu-id="b7c5f-156">Následující vzor, který vypadá na první pohled ekvivalentní, obsahuje jemně rozdíl, který představuje časování.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-156">The following pattern, which, at first glance, looks equivalent, contains a subtle difference that introduces a race condition.</span></span> <span data-ttu-id="b7c5f-157">Konflikty časování obtížně ladění, protože k sami odhalit a obtížně se znovu vyvolali.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-157">Race conditions are difficult to debug because they reveal themselves sporadically and are difficult to reproduce.</span></span>


[!code-vb[Main](caching-data-in-the-architecture-vb/samples/sample3.vb)]

<span data-ttu-id="b7c5f-158">Rozdíl v této druhé, fragment kódu nesprávný je, že místo ukládání odkaz na položky v mezipaměti v místní proměnné, datové mezipaměti pracuje přímo v příkazu podmíněného *a* v `Return`.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-158">The difference in this second, incorrect code snippet is that rather than storing a reference to the cached item in a local variable, the data cache is accessed directly in the conditional statement *and* in the `Return`.</span></span> <span data-ttu-id="b7c5f-159">Když je dosaženo tento kód, který Představte si `Cache("key")` není `Nothing`, ale předtím, než `Return` příkaz je dosaženo, vyloučí systému *klíč* z mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-159">Imagine that when this code is reached, `Cache("key")` is not `Nothing`, but before the `Return` statement is reached, the system evicts *key* from the cache.</span></span> <span data-ttu-id="b7c5f-160">V tomto případě výjimečných kód vrátí `Nothing` místo objekt očekávaného typu.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-160">In this rare case, the code will return `Nothing` rather than an object of the expected type.</span></span>

> [!NOTE]
> <span data-ttu-id="b7c5f-161">Mezipaměť dat je bezpečné pro přístup z více vláken, takže není nutné k synchronizaci vlákno přístup pro jednoduché čtení nebo zápisu.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-161">The data cache is thread-safe, so you don't need to synchronize thread access for simple reads or writes.</span></span> <span data-ttu-id="b7c5f-162">Ale pokud je třeba provést několik operací na data v mezipaměti, které musí být Atomický, jste zodpovědní za implementaci zámek nebo jiným mechanismem zajistit bezpečný přístup z více vláken.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-162">However, if you need to perform multiple operations on data in the cache that need to be atomic, you are responsible for implementing a lock or some other mechanism to ensure thread safety.</span></span> <span data-ttu-id="b7c5f-163">V tématu [synchronizaci přístup k mezipaměti technologie ASP.NET](http://www.ddj.com/184406369) Další informace.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-163">See [Synchronizing Access to the ASP.NET Cache](http://www.ddj.com/184406369) for more information.</span></span>


<span data-ttu-id="b7c5f-164">Položku můžete programově vyloučena z mezipaměti dat pomocí [ `Remove` metoda](https://msdn.microsoft.com/library/system.web.caching.cache.remove.aspx) takto:</span><span class="sxs-lookup"><span data-stu-id="b7c5f-164">An item can be programmatically evicted from the data cache using the [`Remove` method](https://msdn.microsoft.com/library/system.web.caching.cache.remove.aspx) like so:</span></span>


[!code-vb[Main](caching-data-in-the-architecture-vb/samples/sample4.vb)]

## <a name="step-3-returning-product-information-from-theproductsclclass"></a><span data-ttu-id="b7c5f-165">Krok 3: Vrací informace o produktu z`ProductsCL`– třída</span><span class="sxs-lookup"><span data-stu-id="b7c5f-165">Step 3: Returning Product Information from the`ProductsCL`Class</span></span>

<span data-ttu-id="b7c5f-166">Pro tento kurz umožní s implementovat dvě metody vrací informace o produktu z `ProductsCL` – třída: `GetProducts()` a `GetProductsByCategoryID(categoryID)`.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-166">For this tutorial let s implement two methods for returning product information from the `ProductsCL` class: `GetProducts()` and `GetProductsByCategoryID(categoryID)`.</span></span> <span data-ttu-id="b7c5f-167">Jako s `ProductsBL` třídy v vrstvy obchodní logiky, `GetProducts()` metoda v CL vrátí informace o všech produktů jako `Northwind.ProductsDataTable` objekt, při `GetProductsByCategoryID(categoryID)` vrátí všechny produkty v zadané kategorii.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-167">Like with the `ProductsBL` class in the Business Logic Layer, the `GetProducts()` method in the CL returns information about all of the products as a `Northwind.ProductsDataTable` object, while `GetProductsByCategoryID(categoryID)` returns all of the products from a specified category.</span></span>

<span data-ttu-id="b7c5f-168">Následující kód ukazuje část metody v `ProductsCL` třídy:</span><span class="sxs-lookup"><span data-stu-id="b7c5f-168">The following code shows a portion of the methods in the `ProductsCL` class:</span></span>


[!code-vb[Main](caching-data-in-the-architecture-vb/samples/sample5.vb)]

<span data-ttu-id="b7c5f-169">Nejprve, pamatujte `DataObject` a `DataObjectMethodAttribute` atributy použité u třídy a metody.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-169">First, note the `DataObject` and `DataObjectMethodAttribute` attributes applied to the class and methods.</span></span> <span data-ttu-id="b7c5f-170">Tyto atributy poskytnout informace o Průvodci s ObjectDataSource označující, co třídy a metody chcete zobrazit kroků v Průvodci s.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-170">These attributes provide information to the ObjectDataSource s wizard, indicating what classes and methods should appear in the wizard s steps.</span></span> <span data-ttu-id="b7c5f-171">Vzhledem k tomu, že CL třídy a metody bude přistupovat ObjectDataSource v prezentační vrstvě, po přidání těchto atributů k zajištění lepších možností návrhu.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-171">Since the CL classes and methods will be accessed from an ObjectDataSource in the Presentation Layer, I added these attributes to enhance the design-time experience.</span></span> <span data-ttu-id="b7c5f-172">Odkazovat zpět [vytváření vrstvu obchodní logiky](../introduction/creating-a-business-logic-layer-vb.md) kurz podrobnější popis na tyto atributy a jejich důsledky.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-172">Refer back to the [Creating a Business Logic Layer](../introduction/creating-a-business-logic-layer-vb.md) tutorial for a more thorough description on these attributes and their effects.</span></span>

<span data-ttu-id="b7c5f-173">V `GetProducts()` a `GetProductsByCategoryID(categoryID)` metody, s daty vrácenými ze `GetCacheItem(key)` metoda je přiřazený k místní proměnné.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-173">In the `GetProducts()` and `GetProductsByCategoryID(categoryID)` methods, the data returned from the `GetCacheItem(key)` method is assigned to a local variable.</span></span> <span data-ttu-id="b7c5f-174">`GetCacheItem(key)` Metodu, která podíváme krátce, vrátí konkrétní položku z mezipaměti založené na zadaný *klíč*.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-174">The `GetCacheItem(key)` method, which we'll examine shortly, returns a particular item from the cache based on the specified *key*.</span></span> <span data-ttu-id="b7c5f-175">Pokud žádná taková data nachází v mezipaměti, je načíst z odpovídající `ProductsBLL` třídy metoda a pak přidá do mezipaměti pomocí `AddCacheItem(key, value)` metoda.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-175">If no such data is found in cache, it is retrieved from the corresponding `ProductsBLL` class method and then added to the cache using the `AddCacheItem(key, value)` method.</span></span>

<span data-ttu-id="b7c5f-176">`GetCacheItem(key)` a `AddCacheItem(key, value)` metody rozhraní s datovou mezipaměť, čtení a zápis hodnot v uvedeném pořadí.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-176">The `GetCacheItem(key)` and `AddCacheItem(key, value)` methods interface with the data cache, reading and writing values, respectively.</span></span> <span data-ttu-id="b7c5f-177">`GetCacheItem(key)` Způsob je jednodušší dvou.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-177">The `GetCacheItem(key)` method is the simpler of the two.</span></span> <span data-ttu-id="b7c5f-178">Jednoduše vrací hodnotu z mezipaměti třídy pomocí předané *klíč*:</span><span class="sxs-lookup"><span data-stu-id="b7c5f-178">It simply returns the value from the Cache class using the passed-in *key*:</span></span>


[!code-vb[Main](caching-data-in-the-architecture-vb/samples/sample6.vb)]

<span data-ttu-id="b7c5f-179">`GetCacheItem(key)`nepoužívá *klíč* hodnotu jako zadaný, ale volání `GetCacheKey(key)` metoda, která vrátí hodnotu *klíč* přidá jako předpona s ProductsCache-.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-179">`GetCacheItem(key)` does not use *key* value as supplied, but instead calls the `GetCacheKey(key)` method, which returns the *key* prepended with ProductsCache-.</span></span> <span data-ttu-id="b7c5f-180">`MasterCacheKeyArray`, Který obsahuje řetězec ProductsCache, také používány `AddCacheItem(key, value)` metoda, jak jsme se zobrazí na okamžik.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-180">The `MasterCacheKeyArray`, which holds the string ProductsCache, is also used by the `AddCacheItem(key, value)` method, as we'll see momentarily.</span></span>

<span data-ttu-id="b7c5f-181">Ze třídy kódu stránky s technologie ASP.NET datovou mezipaměť je přístupná pomocí `Page` třídu s [ `Cache` vlastnost](https://msdn.microsoft.com/library/system.web.ui.page.cache.aspx)a umožňuje syntaxe jako `Cache("key") = value`, jak je popsáno v kroku 2.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-181">From an ASP.NET page s code-behind class, the data cache can be accessed using the `Page` class s [`Cache` property](https://msdn.microsoft.com/library/system.web.ui.page.cache.aspx), and allows for syntax like `Cache("key") = value`, as discussed in Step 2.</span></span> <span data-ttu-id="b7c5f-182">Od třídy, v rámci architekturu, datovou mezipaměť je přístupná pomocí `HttpRuntime.Cache` nebo `HttpContext.Current.Cache`.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-182">From a class within the architecture, the data cache can be accessed using either `HttpRuntime.Cache` or `HttpContext.Current.Cache`.</span></span> <span data-ttu-id="b7c5f-183">[Petr Janíček](https://weblogs.asp.net/pjohnson/default.aspx)na položce blogu [HttpRuntime.Cache vs. HttpContext.Current.Cache](https://weblogs.asp.net/pjohnson/httpruntime-cache-vs-httpcontext-current-cache) poznámky k výhodu v podobě malého výkonu pomocí `HttpRuntime` místo `HttpContext.Current`; v důsledku toho `ProductsCL` používá `HttpRuntime`.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-183">[Peter Johnson](https://weblogs.asp.net/pjohnson/default.aspx)'s blog entry [HttpRuntime.Cache vs. HttpContext.Current.Cache](https://weblogs.asp.net/pjohnson/httpruntime-cache-vs-httpcontext-current-cache) notes the slight performance advantage in using `HttpRuntime` instead of `HttpContext.Current`; consequently, `ProductsCL` uses `HttpRuntime`.</span></span>

> [!NOTE]
> <span data-ttu-id="b7c5f-184">Pokud vaší architektury je implementovaná pomocí projektů knihovny tříd pak budete muset přidat odkaz na `System.Web` sestavení, aby bylo možné používat [ `HttpRuntime` ](https://msdn.microsoft.com/library/system.web.httpruntime.aspx) a [ `HttpContext` ](https://msdn.microsoft.com/library/system.web.httpcontext.aspx) třídy.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-184">If your architecture is implemented using Class Library projects then you will need to add a reference to the `System.Web` assembly in order to use the [`HttpRuntime`](https://msdn.microsoft.com/library/system.web.httpruntime.aspx) and [`HttpContext`](https://msdn.microsoft.com/library/system.web.httpcontext.aspx) classes.</span></span>


<span data-ttu-id="b7c5f-185">Pokud položka není nalezena v mezipaměti, `ProductsCL` metody třídy s získat data z BLL a přidejte ji do mezipaměti pomocí `AddCacheItem(key, value)` metoda.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-185">If the item is not found in the cache, the `ProductsCL` class s methods get the data from the BLL and add it to the cache using the `AddCacheItem(key, value)` method.</span></span> <span data-ttu-id="b7c5f-186">Chcete-li přidat *hodnotu* do mezipaměti může používáme následující kód, který používá 60 sekundu čas vypršení platnosti:</span><span class="sxs-lookup"><span data-stu-id="b7c5f-186">To add *value* to the cache we could use the following code, which uses a 60 second time expiry:</span></span>


[!code-vb[Main](caching-data-in-the-architecture-vb/samples/sample7.vb)]

<span data-ttu-id="b7c5f-187">`DateTime.Now.AddSeconds(CacheDuration)`Určuje na základě času vypršení platnosti 60 sekund budoucí chvíli [ `System.Web.Caching.Cache.NoSlidingExpiration` ](https://msdn.microsoft.com/library/system.web.caching.cache.noslidingexpiration(vs.80).aspx) označuje tom, že s žádné klouzavé vypršení platnosti.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-187">`DateTime.Now.AddSeconds(CacheDuration)` specifies the time-based expiry 60 seconds in the future while [`System.Web.Caching.Cache.NoSlidingExpiration`](https://msdn.microsoft.com/library/system.web.caching.cache.noslidingexpiration(vs.80).aspx) indicates that there s no sliding expiration.</span></span> <span data-ttu-id="b7c5f-188">Když je tento `Insert` přetížení metody má vstupní parametry pro obě absolutní a klouzavé vypršení platnosti, můžete jenom zadat jednu ze dvou.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-188">While this `Insert` method overload has input parameters for both an absolute and sliding expiry, you can only provide one of the two.</span></span> <span data-ttu-id="b7c5f-189">Pokud se pokusíte zadejte absolutní čas a časové období, `Insert` vyvolá metoda výjimku `ArgumentException` výjimka.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-189">If you attempt to specify both an absolute time and a time span, the `Insert` method will throw an `ArgumentException` exception.</span></span>

> [!NOTE]
> <span data-ttu-id="b7c5f-190">Tato implementace `AddCacheItem(key, value)` metoda má aktuálně některé nedostatků.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-190">This implementation of the `AddCacheItem(key, value)` method currently has some shortcomings.</span></span> <span data-ttu-id="b7c5f-191">Jsme budete adresy a vyřešit tyto problémy v kroku 4.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-191">We'll address and overcome these issues in Step 4.</span></span>


## <a name="step-4-invalidating-the-cache-when-the-data-is-modified-through-the-architecture"></a><span data-ttu-id="b7c5f-192">Krok 4: Zneplatnění mezipaměti při dat je změnit prostřednictvím architektura</span><span class="sxs-lookup"><span data-stu-id="b7c5f-192">Step 4: Invalidating the Cache When the Data is Modified Through the Architecture</span></span>

<span data-ttu-id="b7c5f-193">Společně s metod načítání dat musí poskytovat stejné metody, jako BLL pro vložení, aktualizaci a odstraňování dat vrstvě ukládání do mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-193">Along with data retrieval methods, the Caching Layer needs to provide the same methods as the BLL for inserting, updating, and deleting data.</span></span> <span data-ttu-id="b7c5f-194">Změna metody CL s datového neupravujte data uložená v mezipaměti, ale spíš zavolejte metodu BLL s odpovídající data úpravy a pak platnost mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-194">The CL s data modification methods do not modify the cached data, but rather call the BLL s corresponding data modification method and then invalidate the cache.</span></span> <span data-ttu-id="b7c5f-195">Jak jsme viděli v předchozím kurzu, to je stejné chování, která se vztahuje ObjectDataSource při jeho ukládání do mezipaměti funkce jsou povolené a jeho `Insert`, `Update`, nebo `Delete` jsou vyvolány metody.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-195">As we saw in the preceding tutorial, this is the same behavior that the ObjectDataSource applies when its caching features are enabled and its `Insert`, `Update`, or `Delete` methods are invoked.</span></span>

<span data-ttu-id="b7c5f-196">Následující `UpdateProduct` přetížení znázorňuje, jak implementovat metod úpravy dat CL:</span><span class="sxs-lookup"><span data-stu-id="b7c5f-196">The following `UpdateProduct` overload illustrates how to implement the data modification methods in the CL:</span></span>


[!code-vb[Main](caching-data-in-the-architecture-vb/samples/sample8.vb)]

<span data-ttu-id="b7c5f-197">Úpravy příslušná data vrstvu obchodní logiky metoda je volána, ale před vrácením odpovědi musíme platnost mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-197">The appropriate data modification Business Logic Layer method is invoked, but before its response is returned we need to invalidate the cache.</span></span> <span data-ttu-id="b7c5f-198">Bohužel zneplatnění mezipaměti není jednoznačné protože `ProductsCL` třídu s `GetProducts()` a `GetProductsByCategoryID(categoryID)` metody každý přidání položek do mezipaměti s různými klíči a `GetProductsByCategoryID(categoryID)` metoda přidá položku různé mezipaměti pro každý jedinečný *categoryID*.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-198">Unfortunately, invalidating the cache is not straightforward because the `ProductsCL` class s `GetProducts()` and `GetProductsByCategoryID(categoryID)` methods each add items to the cache with different keys, and the `GetProductsByCategoryID(categoryID)` method adds a different cache item for each unique *categoryID*.</span></span>

<span data-ttu-id="b7c5f-199">Při zrušení platnosti mezipaměti, je potřeba odebrat *všechny* položek, které byl přidán nástrojem `ProductsCL` třídy.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-199">When invalidating the cache, we need to remove *all* of the items that may have been added by the `ProductsCL` class.</span></span> <span data-ttu-id="b7c5f-200">Můžete to provést tím, že přidružíte *závislosti mezipaměti* s každou položkou přidán do mezipaměti `AddCacheItem(key, value)` metoda.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-200">This can be accomplished by associating a *cache dependency* with the each item added to the cache in the `AddCacheItem(key, value)` method.</span></span> <span data-ttu-id="b7c5f-201">Obecně platí závislost mezipaměti může být jiné položky v mezipaměti, soubor v systému souborů nebo data z databáze Microsoft SQL Server.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-201">In general, a cache dependency can be another item in the cache, a file on the file system, or data from a Microsoft SQL Server database.</span></span> <span data-ttu-id="b7c5f-202">Když závislost změní nebo se nachází odebrány z mezipaměti, položky v mezipaměti je přidružen jsou automaticky odstraněna z mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-202">When the dependency changes or is removed from the cache, the cache items it is associated with are automatically evicted from the cache.</span></span> <span data-ttu-id="b7c5f-203">V tomto kurzu budeme rádi vytvoření další položky v mezipaměti, které slouží jako závislost mezipaměti pro všechny položky přidány prostřednictvím `ProductsCL` třídy.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-203">For this tutorial, we want to create an additional item in the cache that serves as a cache dependency for all items added through the `ProductsCL` class.</span></span> <span data-ttu-id="b7c5f-204">Tímto způsobem, všechny tyto položky můžete odeberou z mezipaměti jednoduše odebráním závislosti mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-204">That way, all of these items can be removed from the cache by simply removing the cache dependency.</span></span>

<span data-ttu-id="b7c5f-205">Aktualizace umožňují s `AddCacheItem(key, value)` metoda tak, aby každá položka do mezipaměti přidána prostřednictvím této metody je přidružen jeden mezipaměti závislost:</span><span class="sxs-lookup"><span data-stu-id="b7c5f-205">Let s update the `AddCacheItem(key, value)` method so that each item added to the cache through this method is associated with a single cache dependency:</span></span>


[!code-vb[Main](caching-data-in-the-architecture-vb/samples/sample9.vb)]

<span data-ttu-id="b7c5f-206">`MasterCacheKeyArray`pole řetězců obsahující jednu hodnotu, ProductsCache je.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-206">`MasterCacheKeyArray` is a string array that holds a single value, ProductsCache.</span></span> <span data-ttu-id="b7c5f-207">Nejprve položku mezipaměti je přidán do mezipaměti a přiřazené k aktuálnímu datu a času.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-207">First, a cache item is added to the cache and assigned the current date and time.</span></span> <span data-ttu-id="b7c5f-208">Pokud položku mezipaměti, která již existuje, je aktualizována.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-208">If the cache item already exists, it is updated.</span></span> <span data-ttu-id="b7c5f-209">V dalším kroku se vytvoří závislost mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-209">Next, a cache dependency is created.</span></span> <span data-ttu-id="b7c5f-210">[ `CacheDependency` Třída](https://msdn.microsoft.com/library/system.web.caching.cachedependency(VS.80).aspx) konstruktor s má několik přetížení, ale ten používá sem očekává dva `String` pole vstupy.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-210">The [`CacheDependency` class](https://msdn.microsoft.com/library/system.web.caching.cachedependency(VS.80).aspx) s constructor has a number of overloads, but the one being used in here expects two `String` array inputs.</span></span> <span data-ttu-id="b7c5f-211">První z nich určuje sadu souborů má být použit jako závislosti.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-211">The first one specifies the set of files to be used as dependencies.</span></span> <span data-ttu-id="b7c5f-212">Vzhledem k tomu, že jsme nejsou zobrazeny t chcete použít všechny závislosti na základě souborů, hodnota `Nothing` se používá pro první vstupní parametr.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-212">Since we don t want to use any file-based dependencies, a value of `Nothing` is used for the first input parameter.</span></span> <span data-ttu-id="b7c5f-213">Druhý vstupní parametr určuje sadu mezipaměti klíče k použití jako závislosti.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-213">The second input parameter specifies the set of cache keys to use as dependencies.</span></span> <span data-ttu-id="b7c5f-214">Zde jsme naše jeden závislostí, zadejte `MasterCacheKeyArray`.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-214">Here we specify our single dependency, `MasterCacheKeyArray`.</span></span> <span data-ttu-id="b7c5f-215">`CacheDependency` Pak předá do `Insert` metoda.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-215">The `CacheDependency` is then passed into the `Insert` method.</span></span>

<span data-ttu-id="b7c5f-216">Pomocí této změny `AddCacheItem(key, value)`, invaliding mezipaměti je jednoduché, odebráním závislosti.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-216">With this modification to `AddCacheItem(key, value)`, invaliding the cache is as simple as removing the dependency.</span></span>


[!code-vb[Main](caching-data-in-the-architecture-vb/samples/sample10.vb)]

## <a name="step-5-calling-the-caching-layer-from-the-presentation-layer"></a><span data-ttu-id="b7c5f-217">Krok 5: Volání vrstvě ukládání do mezipaměti z prezentační vrstvy</span><span class="sxs-lookup"><span data-stu-id="b7c5f-217">Step 5: Calling the Caching Layer from the Presentation Layer</span></span>

<span data-ttu-id="b7c5f-218">Ukládání do mezipaměti vrstvy s třídy a metody slouží k práci s daty pomocí technik jsme sunout zkontrolován v rámci těchto kurzů.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-218">The Caching Layer s classes and methods can be used to work with data using the techniques we ve examined throughout these tutorials.</span></span> <span data-ttu-id="b7c5f-219">Pro ilustraci práce se data uložená v mezipaměti, uložte změny do souboru `ProductsCL` třídy a pak otevřete `FromTheArchitecture.aspx` stránku `Caching` složky a přidejte GridView.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-219">To illustrate working with cached data, save your changes to the `ProductsCL` class and then open the `FromTheArchitecture.aspx` page in the `Caching` folder and add a GridView.</span></span> <span data-ttu-id="b7c5f-220">Rutina GridView s inteligentních značek vytvořte nové ObjectDataSource.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-220">From the GridView s smart tag, create a new ObjectDataSource.</span></span> <span data-ttu-id="b7c5f-221">V prvním kroku průvodce s byste měli vidět `ProductsCL` třídy jako jednu z možností z rozevíracího seznamu.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-221">In the wizard s first step you should see the `ProductsCL` class as one of the options from the drop-down list.</span></span>


<span data-ttu-id="b7c5f-222">[![Třída ProductsCL je součástí obchodní objekt rozevíracího seznamu](caching-data-in-the-architecture-vb/_static/image5.png)](caching-data-in-the-architecture-vb/_static/image4.png)</span><span class="sxs-lookup"><span data-stu-id="b7c5f-222">[![The ProductsCL Class is Included in the Business Object Drop-Down List](caching-data-in-the-architecture-vb/_static/image5.png)](caching-data-in-the-architecture-vb/_static/image4.png)</span></span>

<span data-ttu-id="b7c5f-223">**Obrázek 4**: `ProductsCL` třída je zahrnuta v rozevíracím seznamu objekt obchodní ([Kliknutím zobrazit obrázek v plné velikosti](caching-data-in-the-architecture-vb/_static/image6.png))</span><span class="sxs-lookup"><span data-stu-id="b7c5f-223">**Figure 4**: The `ProductsCL` Class is Included in the Business Object Drop-Down List ([Click to view full-size image](caching-data-in-the-architecture-vb/_static/image6.png))</span></span>


<span data-ttu-id="b7c5f-224">Po výběru `ProductsCL`, klikněte na tlačítko Další.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-224">After selecting `ProductsCL`, click Next.</span></span> <span data-ttu-id="b7c5f-225">Rozevíracím seznamu v kartě vyberte má dvě položky - `GetProducts()` a `GetProductsByCategoryID(categoryID)` a na kartě aktualizace má jediný `UpdateProduct` přetížení.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-225">The drop-down list in the SELECT tab has two items - `GetProducts()` and `GetProductsByCategoryID(categoryID)` and the UPDATE tab has the sole `UpdateProduct` overload.</span></span> <span data-ttu-id="b7c5f-226">Vyberte `GetProducts()` metoda kartě vyberte a `UpdateProducts` metoda z karty aktualizace a klikněte na tlačítko Dokončit.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-226">Choose the `GetProducts()` method from the SELECT tab and the `UpdateProducts` method from the UPDATE tab and click Finish.</span></span>


<span data-ttu-id="b7c5f-227">[![Metody třídy ProductsCL s jsou uvedeny v rozevírací seznamy](caching-data-in-the-architecture-vb/_static/image8.png)](caching-data-in-the-architecture-vb/_static/image7.png)</span><span class="sxs-lookup"><span data-stu-id="b7c5f-227">[![The ProductsCL Class s Methods are Listed in the Drop-Down Lists](caching-data-in-the-architecture-vb/_static/image8.png)](caching-data-in-the-architecture-vb/_static/image7.png)</span></span>

<span data-ttu-id="b7c5f-228">**Obrázek 5**: `ProductsCL` metody třídy s jsou uvedeny v rozevírací seznamy ([Kliknutím zobrazit obrázek v plné velikosti](caching-data-in-the-architecture-vb/_static/image9.png))</span><span class="sxs-lookup"><span data-stu-id="b7c5f-228">**Figure 5**: The `ProductsCL` Class s Methods are Listed in the Drop-Down Lists ([Click to view full-size image](caching-data-in-the-architecture-vb/_static/image9.png))</span></span>


<span data-ttu-id="b7c5f-229">Po dokončení průvodce, Visual Studio nastaví ObjectDataSource s `OldValuesParameterFormatString` vlastnost `original_{0}` a přidejte do GridView na odpovídající pole.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-229">After completing the wizard, Visual Studio will set the ObjectDataSource s `OldValuesParameterFormatString` property to `original_{0}` and add the appropriate fields to the GridView.</span></span> <span data-ttu-id="b7c5f-230">Změna `OldValuesParameterFormatString` vlastnost zpět na výchozí hodnotu, `{0}`a nakonfigurujte GridView na podporu stránkování, řazení a úpravy.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-230">Change the `OldValuesParameterFormatString` property back to its default value, `{0}`, and configure the GridView to support paging, sorting, and editing.</span></span> <span data-ttu-id="b7c5f-231">Vzhledem k tomu `UploadProducts` přetížení používané CL přijímá pouze název upravená produktu s a cenu omezit GridView tak, aby se upravovat pouze těchto polí.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-231">Since the `UploadProducts` overload used by the CL accepts only the edited product s name and price, limit the GridView so that only these fields are editable.</span></span>

<span data-ttu-id="b7c5f-232">V předchozím kurzu jsme definovali GridView pro zahrnutí polí pro `ProductName`, `CategoryName`, a `UnitPrice` pole.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-232">In the preceding tutorial we defined a GridView to include fields for the `ProductName`, `CategoryName`, and `UnitPrice` fields.</span></span> <span data-ttu-id="b7c5f-233">Nebojte se replikovat toto formátování a struktura, v takovém případě vaší GridView a ObjectDataSource s deklarativní značek by měl vypadat takto:</span><span class="sxs-lookup"><span data-stu-id="b7c5f-233">Feel free to replicate this formatting and structure, in which case your GridView and ObjectDataSource s declarative markup should look similar to the following:</span></span>


[!code-aspx[Main](caching-data-in-the-architecture-vb/samples/sample11.aspx)]

<span data-ttu-id="b7c5f-234">V tuto chvíli nemáme stránky, která používá vrstvě ukládání do mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-234">At this point we have a page that uses the Caching Layer.</span></span> <span data-ttu-id="b7c5f-235">Nastavte zarážky v mezipaměti v akci najdete `ProductsCL` třídu s `GetProducts()` a `UpdateProduct` metody.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-235">To see the cache in action, set breakpoints in the `ProductsCL` class s `GetProducts()` and `UpdateProduct` methods.</span></span> <span data-ttu-id="b7c5f-236">Navštivte stránku v prohlížeči a krok prostřednictvím kód při řazení a stránkování, chcete-li zobrazit data vyžádat z mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-236">Visit the page in a browser and step through the code when sorting and paging in order to see the data pulled from the cache.</span></span> <span data-ttu-id="b7c5f-237">Potom aktualizujte záznam a Upozorňujeme, že se zrušenou platností mezipaměti, a v důsledku toho načítají z BLL, když je k GridView odrážejí data.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-237">Then update a record and note that the cache is invalidated and, consequently, it is retrieved from the BLL when the data is rebound to the GridView.</span></span>

> [!NOTE]
> <span data-ttu-id="b7c5f-238">Ukládání do mezipaměti vrstvy součástí stahování doplňujícími v tomto článku není dokončena.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-238">The Caching Layer provided in the download accompanying this article is not complete.</span></span> <span data-ttu-id="b7c5f-239">Obsahuje pouze jednu třídu, `ProductsCL`, který pouze sportovní několik metod.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-239">It contains only one class, `ProductsCL`, which only sports a handful of methods.</span></span> <span data-ttu-id="b7c5f-240">Kromě toho pouze jednu stránku ASP.NET používá CL (`~/Caching/FromTheArchitecture.aspx`) nikdo jiný k ní stále odkazovat BLL přímo.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-240">Moreover, only a single ASP.NET page uses the CL (`~/Caching/FromTheArchitecture.aspx`) all others still reference the BLL directly.</span></span> <span data-ttu-id="b7c5f-241">Pokud máte v úmyslu používat CL ve vaší aplikaci, všechna volání od prezentační vrstvy by měl přejděte do CL, která by vyžadovala CL s třídy a metody zahrnutých tyto třídy a metody v BLL aktuálně používané prezentační vrstvy.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-241">If you plan on using a CL in your application, all calls from the Presentation Layer should go to the CL, which would require that the CL s classes and methods covered those classes and methods in the BLL currently used by the Presentation Layer.</span></span>


## <a name="summary"></a><span data-ttu-id="b7c5f-242">Souhrn</span><span class="sxs-lookup"><span data-stu-id="b7c5f-242">Summary</span></span>

<span data-ttu-id="b7c5f-243">Při ukládání do mezipaměti můžete použít v prezentační vrstvě s prostředím ASP.NET 2.0 s SqlDataSource a ovládací prvky ObjectDataSource by v ideálním případě ukládání do mezipaměti odpovědnosti delegovat na samostatné vrstvy architektury.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-243">While caching can be applied at the Presentation Layer with ASP.NET 2.0 s SqlDataSource and ObjectDataSource controls, ideally caching responsibilities would be delegated to a separate layer in the architecture.</span></span> <span data-ttu-id="b7c5f-244">V tomto kurzu jsme vytvořili vrstva ukládání do mezipaměti, který se nachází mezi prezentační vrstvou a vrstvu obchodní logiky.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-244">In this tutorial we created a Caching Layer that resides between the Presentation Layer and the Business Logic Layer.</span></span> <span data-ttu-id="b7c5f-245">Vrstva ukládání do mezipaměti je potřeba zadat stejnou sadu třídy a metody, které existují v BLL a se nazývají od prezentační vrstvy.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-245">The Caching Layer needs to provide the same set of classes and methods that exist in the BLL and are called from the Presentation Layer.</span></span>

<span data-ttu-id="b7c5f-246">Ukládání do mezipaměti vrstvy příklady jsme prozkoumali v této a předchozích kurzy vystavených *reaktivní načítání*.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-246">The Caching Layer examples we explored in this and the preceding tutorials exhibited *reactive loading*.</span></span> <span data-ttu-id="b7c5f-247">S reakcí načítání je načíst data do mezipaměti jenom v případě požadavku pro data a data z mezipaměti chybí.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-247">With reactive loading, the data is loaded into the cache only when a request for the data is made and that data is missing from the cache.</span></span> <span data-ttu-id="b7c5f-248">Data mohou být také *proaktivně načíst* do mezipaměti techniky, načte data do mezipaměti předtím, než je skutečně potřeba.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-248">Data can also be *proactively loaded* into the cache, a technique that loads the data into the cache before it is actually needed.</span></span> <span data-ttu-id="b7c5f-249">V dalším kurzu vidíte příklad proaktivní načítání, když se podíváme na tom, jak ukládat do mezipaměti při spuštění aplikace statické hodnoty.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-249">In the next tutorial we'll see an example of proactive loading when we look at how to store static values into the cache at application startup.</span></span>

<span data-ttu-id="b7c5f-250">Radostí programování!</span><span class="sxs-lookup"><span data-stu-id="b7c5f-250">Happy Programming!</span></span>

## <a name="about-the-author"></a><span data-ttu-id="b7c5f-251">O autorovi</span><span class="sxs-lookup"><span data-stu-id="b7c5f-251">About the Author</span></span>

<span data-ttu-id="b7c5f-252">[Scott Meisnerová](http://www.4guysfromrolla.com/ScottMitchell.shtml), Autor sedm ASP/ASP.NET knih a zakladatele z [4GuysFromRolla.com](http://www.4guysfromrolla.com), pracuje s technologií Microsoft Web od 1998.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-252">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml), author of seven ASP/ASP.NET books and founder of [4GuysFromRolla.com](http://www.4guysfromrolla.com), has been working with Microsoft Web technologies since 1998.</span></span> <span data-ttu-id="b7c5f-253">Scott funguje jako nezávislé poradce, trainer a zapisovače.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-253">Scott works as an independent consultant, trainer, and writer.</span></span> <span data-ttu-id="b7c5f-254">Jeho nejnovější seznam k [ *Edice nakladatelství Sams naučit sami technologii ASP.NET 2.0 za 24 hodin*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco).</span><span class="sxs-lookup"><span data-stu-id="b7c5f-254">His latest book is [*Sams Teach Yourself ASP.NET 2.0 in 24 Hours*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco).</span></span> <span data-ttu-id="b7c5f-255">Dosažitelný v [ mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com) nebo prostřednictvím svého blogu, který najdete na [http://ScottOnWriting.NET](http://ScottOnWriting.NET).</span><span class="sxs-lookup"><span data-stu-id="b7c5f-255">He can be reached at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com) or via his blog, which can be found at [http://ScottOnWriting.NET](http://ScottOnWriting.NET).</span></span>

## <a name="special-thanks-to"></a><span data-ttu-id="b7c5f-256">Zvláštní poděkování</span><span class="sxs-lookup"><span data-stu-id="b7c5f-256">Special Thanks To</span></span>

<span data-ttu-id="b7c5f-257">Tento kurz řady byla zkontrolovány uživatelem mnoho užitečné kontrolorů.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-257">This tutorial series was reviewed by many helpful reviewers.</span></span> <span data-ttu-id="b7c5f-258">Vést kontrolorem pro tento kurz byl Teresy Murphy.</span><span class="sxs-lookup"><span data-stu-id="b7c5f-258">Lead reviewer for this tutorial was Teresa Murphy.</span></span> <span data-ttu-id="b7c5f-259">Kontrola Moje nadcházející články MSDN máte zájem?</span><span class="sxs-lookup"><span data-stu-id="b7c5f-259">Interested in reviewing my upcoming MSDN articles?</span></span> <span data-ttu-id="b7c5f-260">Pokud ano, vyřaďte mi řádek v [ mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="b7c5f-260">If so, drop me a line at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span></span>

>[!div class="step-by-step"]
<span data-ttu-id="b7c5f-261">[Předchozí](caching-data-with-the-objectdatasource-vb.md)
[další](caching-data-at-application-startup-vb.md)</span><span class="sxs-lookup"><span data-stu-id="b7c5f-261">[Previous](caching-data-with-the-objectdatasource-vb.md)
[Next](caching-data-at-application-startup-vb.md)</span></span>
