---
uid: signalr/overview/guide-to-the-api/handling-connection-lifetime-events
title: Principy a zpracování událostí doby platnosti v knihovně SignalR | Dokumentace Microsoftu
author: pfletcher
description: Tento článek popisuje, jak pomocí událostí vystavené API rozbočovače.
ms.author: riande
ms.date: 06/10/2014
ms.assetid: 03960de2-8d95-4444-9169-4426dcc64913
msc.legacyurl: /signalr/overview/guide-to-the-api/handling-connection-lifetime-events
msc.type: authoredcontent
ms.openlocfilehash: 42cf7faf9112875e15072993b6210348d0c42534
ms.sourcegitcommit: 45ac74e400f9f2b7dbded66297730f6f14a4eb25
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 08/16/2018
ms.locfileid: "41753648"
---
<a name="understanding-and-handling-connection-lifetime-events-in-signalr"></a><span data-ttu-id="eab7c-103">Principy a zpracování událostí doby platnosti v knihovně SignalR</span><span class="sxs-lookup"><span data-stu-id="eab7c-103">Understanding and Handling Connection Lifetime Events in SignalR</span></span>
====================
<span data-ttu-id="eab7c-104">podle [Patrick Fletcher](https://github.com/pfletcher), [Petr Dykstra](https://github.com/tdykstra)</span><span class="sxs-lookup"><span data-stu-id="eab7c-104">by [Patrick Fletcher](https://github.com/pfletcher), [Tom Dykstra](https://github.com/tdykstra)</span></span>

> <span data-ttu-id="eab7c-105">Tento článek obsahuje přehled funkce SignalR připojení, opětovné připojení a odpojení události, které dokáže zpracovat a nastavení časového limitu a keepalive, které můžete nakonfigurovat.</span><span class="sxs-lookup"><span data-stu-id="eab7c-105">This article provides an overview of the SignalR connection, reconnection, and disconnection events that you can handle, and timeout and keepalive settings that you can configure.</span></span>
> 
> <span data-ttu-id="eab7c-106">Tento článek předpokládá, že máte již určitá znalost události doby života SignalR a připojení.</span><span class="sxs-lookup"><span data-stu-id="eab7c-106">The article assumes you already have some knowledge of SignalR and connection lifetime events.</span></span> <span data-ttu-id="eab7c-107">Úvod k funkci SignalR naleznete v tématu [Úvod ke knihovně SignalR](../getting-started/introduction-to-signalr.md).</span><span class="sxs-lookup"><span data-stu-id="eab7c-107">For an introduction to SignalR, see [Introduction to SignalR](../getting-started/introduction-to-signalr.md).</span></span> <span data-ttu-id="eab7c-108">Seznam událostí doby platnosti naleznete v následujících zdrojích:</span><span class="sxs-lookup"><span data-stu-id="eab7c-108">For lists of connection lifetime events, see the following resources:</span></span>
> 
> - [<span data-ttu-id="eab7c-109">Zpracování událostí doby platnosti ve třídě centra</span><span class="sxs-lookup"><span data-stu-id="eab7c-109">How to handle connection lifetime events in the Hub class</span></span>](hubs-api-guide-server.md#connectionlifetime)
> - [<span data-ttu-id="eab7c-110">Zpracování událostí doby platnosti v klientech jazyka JavaScript</span><span class="sxs-lookup"><span data-stu-id="eab7c-110">How to handle connection lifetime events in JavaScript clients</span></span>](hubs-api-guide-javascript-client.md#connectionlifetime)
> - [<span data-ttu-id="eab7c-111">Zpracování událostí doby platnosti v klientů .NET</span><span class="sxs-lookup"><span data-stu-id="eab7c-111">How to handle connection lifetime events in .NET clients</span></span>](hubs-api-guide-net-client.md#connectionlifetime)
> 
> ## <a name="software-versions-used-in-this-topic"></a><span data-ttu-id="eab7c-112">Verze softwaru použitým v tomto tématu</span><span class="sxs-lookup"><span data-stu-id="eab7c-112">Software versions used in this topic</span></span>
> 
> 
> - [<span data-ttu-id="eab7c-113">Visual Studio 2013</span><span class="sxs-lookup"><span data-stu-id="eab7c-113">Visual Studio 2013</span></span>](https://www.microsoft.com/visualstudio/eng/2013-downloads)
> - <span data-ttu-id="eab7c-114">.NET 4.5</span><span class="sxs-lookup"><span data-stu-id="eab7c-114">.NET 4.5</span></span>
> - <span data-ttu-id="eab7c-115">Funkce SignalR verze 2</span><span class="sxs-lookup"><span data-stu-id="eab7c-115">SignalR version 2</span></span>
>   
> 
> 
> ## <a name="previous-versions-of-this-topic"></a><span data-ttu-id="eab7c-116">Předchozích verzích tohoto tématu</span><span class="sxs-lookup"><span data-stu-id="eab7c-116">Previous versions of this topic</span></span>
> 
> <span data-ttu-id="eab7c-117">Informace o předchozích verzích systému SignalR naleznete v tématu [starší verze funkce SignalR](../older-versions/index.md).</span><span class="sxs-lookup"><span data-stu-id="eab7c-117">For information about earlier versions of SignalR, see [SignalR Older Versions](../older-versions/index.md).</span></span>
> 
> ## <a name="questions-and-comments"></a><span data-ttu-id="eab7c-118">Otázky a komentáře</span><span class="sxs-lookup"><span data-stu-id="eab7c-118">Questions and comments</span></span>
> 
> <span data-ttu-id="eab7c-119">Napište prosím zpětnou vazbu o tom, jak vám líbilo v tomto kurzu a co můžeme zlepšit v komentářích v dolní části stránky.</span><span class="sxs-lookup"><span data-stu-id="eab7c-119">Please leave feedback on how you liked this tutorial and what we could improve in the comments at the bottom of the page.</span></span> <span data-ttu-id="eab7c-120">Pokud máte nějaké otázky, které přímo nesouvisejí, najdete v tomto kurzu, můžete je publikovat [fórum ASP.NET SignalR](https://forums.asp.net/1254.aspx/1?ASP+NET+SignalR) nebo [StackOverflow.com](http://stackoverflow.com/).</span><span class="sxs-lookup"><span data-stu-id="eab7c-120">If you have questions that are not directly related to the tutorial, you can post them to the [ASP.NET SignalR forum](https://forums.asp.net/1254.aspx/1?ASP+NET+SignalR) or [StackOverflow.com](http://stackoverflow.com/).</span></span>


## <a name="overview"></a><span data-ttu-id="eab7c-121">Přehled</span><span class="sxs-lookup"><span data-stu-id="eab7c-121">Overview</span></span>

<span data-ttu-id="eab7c-122">Tento článek obsahuje následující části:</span><span class="sxs-lookup"><span data-stu-id="eab7c-122">This article contains the following sections:</span></span>

- [<span data-ttu-id="eab7c-123">Připojení životnost terminologie a scénáře</span><span class="sxs-lookup"><span data-stu-id="eab7c-123">Connection lifetime terminology and scenarios</span></span>](#terminology)

    - [<span data-ttu-id="eab7c-124">Připojení SignalR, připojeními a fyzické připojení</span><span class="sxs-lookup"><span data-stu-id="eab7c-124">SignalR connections, transport connections, and physical connections</span></span>](#signalrvstransport)
    - [<span data-ttu-id="eab7c-125">Scénáře odpojení přenosu</span><span class="sxs-lookup"><span data-stu-id="eab7c-125">Transport disconnection scenarios</span></span>](#transportdisconnect)
    - [<span data-ttu-id="eab7c-126">Scénáře odpojení klienta</span><span class="sxs-lookup"><span data-stu-id="eab7c-126">Client disconnection scenarios</span></span>](#clientdisconnect)
    - [<span data-ttu-id="eab7c-127">Scénáře odpojení serveru</span><span class="sxs-lookup"><span data-stu-id="eab7c-127">Server disconnection scenarios</span></span>](#serverdisconnect)
- [<span data-ttu-id="eab7c-128">Nastavení časového limitu a keepalive</span><span class="sxs-lookup"><span data-stu-id="eab7c-128">Timeout and keepalive settings</span></span>](#timeoutkeepalive)

    - [<span data-ttu-id="eab7c-129">Hodnota ConnectionTimeout</span><span class="sxs-lookup"><span data-stu-id="eab7c-129">ConnectionTimeout</span></span>](#connectiontimeout)
    - [<span data-ttu-id="eab7c-130">DisconnectTimeout</span><span class="sxs-lookup"><span data-stu-id="eab7c-130">DisconnectTimeout</span></span>](#disconnecttimeout)
    - [<span data-ttu-id="eab7c-131">KeepAlive</span><span class="sxs-lookup"><span data-stu-id="eab7c-131">KeepAlive</span></span>](#keepalive)
    - [<span data-ttu-id="eab7c-132">Jak změnit nastavení časového limitu a keepalive</span><span class="sxs-lookup"><span data-stu-id="eab7c-132">How to change timeout and keepalive settings</span></span>](#changetimeout)
- [<span data-ttu-id="eab7c-133">Jak informovat uživatele o odpojení</span><span class="sxs-lookup"><span data-stu-id="eab7c-133">How to notify the user about disconnections</span></span>](#notifydisconnect)
- [<span data-ttu-id="eab7c-134">Průběžně opětovné připojení</span><span class="sxs-lookup"><span data-stu-id="eab7c-134">How to continuously reconnect</span></span>](#continuousreconnect)
- [<span data-ttu-id="eab7c-135">Jak odpojení klienta v kódu serveru</span><span class="sxs-lookup"><span data-stu-id="eab7c-135">How to disconnect a client in server code</span></span>](#disconnectclientfromserver)
- [<span data-ttu-id="eab7c-136">Zjišťování důvod pro odpojení</span><span class="sxs-lookup"><span data-stu-id="eab7c-136">Detecting the reason for a disconnection</span></span>](#detectingreasonfordisconnection)

<span data-ttu-id="eab7c-137">Odkazy na témata, Reference k rozhraní API se API verze rozhraní .NET 4.5.</span><span class="sxs-lookup"><span data-stu-id="eab7c-137">Links to API Reference topics are to the .NET 4.5 version of the API.</span></span> <span data-ttu-id="eab7c-138">Pokud používáte .NET 4, přečtěte si téma [verze .NET 4 témat API](https://msdn.microsoft.com/library/jj891075(v=vs.100).aspx).</span><span class="sxs-lookup"><span data-stu-id="eab7c-138">If you're using .NET 4, see [the .NET 4 version of the API topics](https://msdn.microsoft.com/library/jj891075(v=vs.100).aspx).</span></span>

<a id="terminology"></a>

## <a name="connection-lifetime-terminology-and-scenarios"></a><span data-ttu-id="eab7c-139">Připojení životnost terminologie a scénáře</span><span class="sxs-lookup"><span data-stu-id="eab7c-139">Connection lifetime terminology and scenarios</span></span>

<span data-ttu-id="eab7c-140">`OnReconnected` Obslužné rutiny události v rozbočovači SignalR můžete spustit přímo po `OnConnected` , ale ne po `OnDisconnected` pro daného klienta.</span><span class="sxs-lookup"><span data-stu-id="eab7c-140">The `OnReconnected` event handler in a SignalR Hub can execute directly after `OnConnected` but not after `OnDisconnected` for a given client.</span></span> <span data-ttu-id="eab7c-141">Z důvodu, že máte opětovné připojení bez odpojení je, že existuje několik způsobů, ve kterých se používá slovo "připojení" v knihovně SignalR.</span><span class="sxs-lookup"><span data-stu-id="eab7c-141">The reason you can have a reconnection without a disconnection is that there are several ways in which the word "connection" is used in SignalR.</span></span>

<a id="signalrvstransport"></a>

### <a name="signalr-connections-transport-connections-and-physical-connections"></a><span data-ttu-id="eab7c-142">Připojení SignalR, připojeními a fyzické připojení</span><span class="sxs-lookup"><span data-stu-id="eab7c-142">SignalR connections, transport connections, and physical connections</span></span>

<span data-ttu-id="eab7c-143">Tento článek bude rozlišovat mezi *připojení SignalR*, *přenosu připojení*, a *fyzické připojení*:</span><span class="sxs-lookup"><span data-stu-id="eab7c-143">This article will differentiate between *SignalR connections*, *transport connections*, and *physical connections*:</span></span>

- <span data-ttu-id="eab7c-144">**Připojení SignalR** odkazuje na logický vztah mezi klientem a adresu URL serveru, spravuje pomocí rozhraní API SignalR a jednoznačně identifikují pomocí ID připojení.</span><span class="sxs-lookup"><span data-stu-id="eab7c-144">**SignalR connection** refers to a logical relationship between a client and a server URL, maintained by the SignalR API and uniquely identified by a connection ID.</span></span> <span data-ttu-id="eab7c-145">Data o tento vztah se spravuje pomocí SignalR a se používá k navázání připojení přenosu.</span><span class="sxs-lookup"><span data-stu-id="eab7c-145">The data about this relationship is maintained by SignalR and is used to establish a transport connection.</span></span> <span data-ttu-id="eab7c-146">Elementy end relace a technologie SignalR uvolní dat, když klient volá `Stop` metody nebo časový limit je dosaženo během SignalR je snahy o obnovení připojení přenosu ztraceny.</span><span class="sxs-lookup"><span data-stu-id="eab7c-146">The relationship ends and SignalR disposes of the data when the client calls the `Stop` method or a timeout limit is reached while SignalR is attempting to re-establish a lost transport connection.</span></span>
- <span data-ttu-id="eab7c-147">**Připojení přenosu** odkazuje na logický vztah mezi klientem a serverem, udržován jednu čtyři přenosu rozhraní API: protokoly Websocket, události odeslané serverem navždy snímků nebo dlouhý interval dotazování.</span><span class="sxs-lookup"><span data-stu-id="eab7c-147">**Transport connection** refers to a logical relationship between a client and a server, maintained by one of the four transport APIs: WebSockets, server-sent events, forever frame, or long polling.</span></span> <span data-ttu-id="eab7c-148">SignalR k vytvoření připojení přenosu používá přenos rozhraní API a rozhraní API pro přenos závisí na existenci fyzické síťové připojení k vytvoření připojení přenosu.</span><span class="sxs-lookup"><span data-stu-id="eab7c-148">SignalR uses the transport API to create a transport connection, and the transport API depends on the existence of a physical network connection to create the transport connection.</span></span> <span data-ttu-id="eab7c-149">Připojení pro přenos končí při SignalR ukončí ho nebo při přenosu rozhraní API zjistí, že fyzické připojení bylo přerušeno.</span><span class="sxs-lookup"><span data-stu-id="eab7c-149">The transport connection ends when SignalR terminates it or when the transport API detects that the physical connection is broken.</span></span>
- <span data-ttu-id="eab7c-150">**Fyzické připojení** odkazuje na fyzické síťové odkazy – vodičům stanice, bezdrátové signály, směrovače, atd. –, které usnadňují komunikace mezi klientským počítačem a serveru.</span><span class="sxs-lookup"><span data-stu-id="eab7c-150">**Physical connection** refers to the physical network links -- wires, wireless signals, routers, etc. -- that facilitate communication between a client computer and a server computer.</span></span> <span data-ttu-id="eab7c-151">Fyzické připojení musí být k dispozici, aby bylo možné navázat připojení přenosu a aby bylo možné navázat připojení SignalR musí navázat připojení přenosu.</span><span class="sxs-lookup"><span data-stu-id="eab7c-151">The physical connection must be present in order to establish a transport connection, and a transport connection must be established in order to establish a SignalR connection.</span></span> <span data-ttu-id="eab7c-152">Ale zásadní fyzické připojení není vždy okamžitě ukončí přenosového připojení nebo připojení SignalR, jak budou vysvětlena dále v tomto tématu.</span><span class="sxs-lookup"><span data-stu-id="eab7c-152">However, breaking the physical connection doesn't always immediately end the transport connection or the SignalR connection, as will be explained later in this topic.</span></span>

<span data-ttu-id="eab7c-153">V následujícím diagramu připojení SignalR je reprezentována rozhraní API rozbočovače a SignalR pro rozhraní API PersistentConnection vrstvy, připojení přenosu je reprezentována přenosy vrstvy a fyzické připojení je reprezentována řádky mezi serverem a klienty.</span><span class="sxs-lookup"><span data-stu-id="eab7c-153">In the following diagram, the SignalR connection is represented by the Hubs API and PersistentConnection API SignalR layer, the transport connection is represented by the Transports layer, and the physical connection is represented by the lines between the server and the clients.</span></span>

![Diagram architektury SignalR](handling-connection-lifetime-events/_static/image1.png)

<span data-ttu-id="eab7c-155">Při volání `Start` metody v klientovi SignalR, tím kód klienta SignalR s všechny informace potřebné pro vytvoření fyzické připojení k serveru.</span><span class="sxs-lookup"><span data-stu-id="eab7c-155">When you call the `Start` method in a SignalR client, you are providing SignalR client code with all the information it needs in order to establish a physical connection to a server.</span></span> <span data-ttu-id="eab7c-156">SignalR klientský kód používá tyto informace odeslání požadavku HTTP a naváže fyzické připojení, který používá některou z metod čtyři přenosu.</span><span class="sxs-lookup"><span data-stu-id="eab7c-156">SignalR client code uses this information to make an HTTP request and establish a physical connection that uses one of the four transport methods.</span></span> <span data-ttu-id="eab7c-157">Pokud připojení pro přenos se nezdaří a dojde k selhání serveru, připojení SignalR nebude přejděte okamžitě okamžitě vzhledem k tomu, že klient má stále informace potřebné k automaticky znovu vytvořit nové připojení přenosu pro stejnou adresu URL funkce SignalR.</span><span class="sxs-lookup"><span data-stu-id="eab7c-157">If the transport connection fails or the server fails, the SignalR connection doesn't go away immediately because the client still has the information it needs to automatically re-establish a new transport connection to the same SignalR URL.</span></span> <span data-ttu-id="eab7c-158">V tomto scénáři nepodílí bez nutnosti zásahu od uživatele aplikace a když SignalR klientský kód vytvoří nové připojení přenosu, se nespustí nové připojení SignalR.</span><span class="sxs-lookup"><span data-stu-id="eab7c-158">In this scenario, no intervention from the user application is involved, and when the SignalR client code establishes a new transport connection, it does not start a new SignalR connection.</span></span> <span data-ttu-id="eab7c-159">Ve skutečnosti se projeví kontinuitu připojení SignalR, která ID připojení, který je vytvořen při volání `Start` metoda, nezmění.</span><span class="sxs-lookup"><span data-stu-id="eab7c-159">The continuity of the SignalR connection is reflected in the fact that the connection ID, which is created when you call the `Start` method, does not change.</span></span>

<span data-ttu-id="eab7c-160">`OnReconnected` Obslužné rutiny události v centru provede, když se poté, co bylo ztraceno automaticky znovu naváže připojení přenosu.</span><span class="sxs-lookup"><span data-stu-id="eab7c-160">The `OnReconnected` event handler on the Hub executes when a transport connection is automatically re-established after having been lost.</span></span> <span data-ttu-id="eab7c-161">`OnDisconnected` Obslužná rutina události provádí na konci připojení SignalR.</span><span class="sxs-lookup"><span data-stu-id="eab7c-161">The `OnDisconnected` event handler executes at the end of a SignalR connection.</span></span> <span data-ttu-id="eab7c-162">Připojení SignalR můžete ukončit v některém z následujících způsobů:</span><span class="sxs-lookup"><span data-stu-id="eab7c-162">A SignalR connection can end in any of the following ways:</span></span>

- <span data-ttu-id="eab7c-163">Pokud klient volá `Stop` metody zpráva stop se pošle na server a klientských i serverových připojení SignalR okamžitě ukončí.</span><span class="sxs-lookup"><span data-stu-id="eab7c-163">If the client calls the `Stop` method, a stop message is sent to the server, and both client and server end the SignalR connection immediately.</span></span>
- <span data-ttu-id="eab7c-164">Jakmile dojde ke ztrátě připojení mezi klientem a serverem, klient se pokusí znovu připojit a server čeká na klientovi znovu připojit.</span><span class="sxs-lookup"><span data-stu-id="eab7c-164">After connectivity between client and server is lost, the client tries to reconnect and the server waits for the client to reconnect.</span></span> <span data-ttu-id="eab7c-165">Pokud neúspěšné pokusy o připojení a odpojení časový limit ukončení, klient a server ukončit připojení SignalR.</span><span class="sxs-lookup"><span data-stu-id="eab7c-165">If the attempts to reconnect are unsuccessful and the disconnect timeout period ends, both client and server end the SignalR connection.</span></span> <span data-ttu-id="eab7c-166">Klient zastaví pokus o opětovné připojení, a server odstraňuje její znázornění připojení SignalR.</span><span class="sxs-lookup"><span data-stu-id="eab7c-166">The client stops trying to reconnect, and the server disposes of its representation of the SignalR connection.</span></span>
- <span data-ttu-id="eab7c-167">Pokud klient přestane fungovat bez nutnosti příležitost k volání `Stop` metody server čeká na klientovi znovu připojit a končí po uplynutí časového limitu odpojení připojení SignalR.</span><span class="sxs-lookup"><span data-stu-id="eab7c-167">If the client stops running without having a chance to call the `Stop` method, the server waits for the client to reconnect, and then ends the SignalR connection after the disconnect timeout period.</span></span>
- <span data-ttu-id="eab7c-168">Pokud server přestane běží, se klient pokusí znovu připojit (znovu vytvořit připojení pro přenos) a končí po uplynutí časového limitu odpojení připojení SignalR.</span><span class="sxs-lookup"><span data-stu-id="eab7c-168">If the server stops running, the client tries to reconnect (re-create the transport connection), and then ends the SignalR connection after the disconnect timeout period.</span></span>

<span data-ttu-id="eab7c-169">Když neexistují žádné problémy s připojením a uživatelská aplikace ukončí připojení SignalR voláním `Stop` metodu, připojení SignalR a připojení pro přenos začínají i končí na přibližně ve stejnou dobu.</span><span class="sxs-lookup"><span data-stu-id="eab7c-169">When there are no connection problems, and the user application ends the SignalR connection by calling the `Stop` method, the SignalR connection and the transport connection begin and end at about the same time.</span></span> <span data-ttu-id="eab7c-170">Následující části popisují podrobnější jiné scénáře.</span><span class="sxs-lookup"><span data-stu-id="eab7c-170">The following sections describe in more detail the other scenarios.</span></span>

<a id="transportdisconnect"></a>

### <a name="transport-disconnection-scenarios"></a><span data-ttu-id="eab7c-171">Scénáře odpojení přenosu</span><span class="sxs-lookup"><span data-stu-id="eab7c-171">Transport disconnection scenarios</span></span>

<span data-ttu-id="eab7c-172">Fyzické připojení může být pomalá nebo může být přerušení připojení.</span><span class="sxs-lookup"><span data-stu-id="eab7c-172">Physical connections might be slow or there might be interruptions in connectivity.</span></span> <span data-ttu-id="eab7c-173">Závisí to na faktorech, jako je délka přerušení může dojít ke ztrátě připojení přenosu.</span><span class="sxs-lookup"><span data-stu-id="eab7c-173">Depending on factors such as the length of the interruption, the transport connection might be dropped.</span></span> <span data-ttu-id="eab7c-174">SignalR se pak pokusí znovu navázat připojení přenosu.</span><span class="sxs-lookup"><span data-stu-id="eab7c-174">SignalR then tries to re-establish the transport connection.</span></span> <span data-ttu-id="eab7c-175">Někdy přenosového připojení rozhraní API zjistí přerušení a zahodí připojení pro přenos a SignalR dozví okamžitě, že připojení bylo ztraceno.</span><span class="sxs-lookup"><span data-stu-id="eab7c-175">Sometimes the transport connection API detects the interruption and drops the transport connection, and SignalR finds out immediately that the connection is lost.</span></span> <span data-ttu-id="eab7c-176">V jiných scénářích přenosového připojení rozhraní API ani SignalR zjistí okamžitě, že připojení bylo ztraceno.</span><span class="sxs-lookup"><span data-stu-id="eab7c-176">In other scenarios, neither the transport connection API nor SignalR becomes aware immediately that connectivity has been lost.</span></span> <span data-ttu-id="eab7c-177">Pro všechny přenosy s výjimkou dlouhým dotazováním klientovi SignalR používá funkci s názvem *keepalive* ke kontrole ke ztrátě připojení, který se nedokáže rozpoznat přenosu rozhraní API.</span><span class="sxs-lookup"><span data-stu-id="eab7c-177">For all transports except long polling, the SignalR client uses a function called *keepalive* to check for loss of connectivity that the transport API is unable to detect.</span></span> <span data-ttu-id="eab7c-178">Informace o dlouho dotazování připojeních najdete v tématu [nastavení časového limitu a keepalive](#timeoutkeepalive) dále v tomto tématu.</span><span class="sxs-lookup"><span data-stu-id="eab7c-178">For information about long polling connections, see [Timeout and keepalive settings](#timeoutkeepalive) later in this topic.</span></span>

<span data-ttu-id="eab7c-179">Při připojení je neaktivní, pravidelně server odešle paket keepalive do klienta.</span><span class="sxs-lookup"><span data-stu-id="eab7c-179">When a connection is inactive, periodically the server sends a keepalive packet to the client.</span></span> <span data-ttu-id="eab7c-180">K datu, které tento článek se týká je výchozí frekvence každých 10 sekund.</span><span class="sxs-lookup"><span data-stu-id="eab7c-180">As of the date this article is being written, the default frequency is every 10 seconds.</span></span> <span data-ttu-id="eab7c-181">Prostřednictvím naslouchání pro tyto pakety, můžete zjistit klienty, pokud dojde k problému připojení.</span><span class="sxs-lookup"><span data-stu-id="eab7c-181">By listening for these packets, clients can tell if there is a connection problem.</span></span> <span data-ttu-id="eab7c-182">Pokud paketu keepalive neobdrží při očekávání, po krátkou dobu klient předpokládá, že jsou problémy s připojením, jako je například pomalost nebo přerušením.</span><span class="sxs-lookup"><span data-stu-id="eab7c-182">If a keepalive packet is not received when expected, after a short time the client assumes that there are connection problems such as slowness or interruptions.</span></span> <span data-ttu-id="eab7c-183">Pokud keepalive není stále přijata po delší dobu, klient předpokládá, že připojení bylo vyřazeno a začne pokusu o opětovné připojení.</span><span class="sxs-lookup"><span data-stu-id="eab7c-183">If the keepalive is still not received after a longer time, the client assumes that the connection has been dropped, and it begins trying to reconnect.</span></span>

<span data-ttu-id="eab7c-184">Následující diagram znázorňuje klientských a serverových události, které jsou vyvolány v rámci typického scénáře, když dochází k problémům s fyzické připojení, které nejsou rozpoznány okamžitě Transport rozhraní API.</span><span class="sxs-lookup"><span data-stu-id="eab7c-184">The following diagram illustrates the client and server events that are raised in a typical scenario when there are problems with the physical connection that aren't immediately recognized by the transport API.</span></span> <span data-ttu-id="eab7c-185">Diagram se týká následujících okolností:</span><span class="sxs-lookup"><span data-stu-id="eab7c-185">The diagram applies to the following circumstances:</span></span>

- <span data-ttu-id="eab7c-186">Přenos se protokoly Websocket, navždy rámce nebo události odeslané serverem.</span><span class="sxs-lookup"><span data-stu-id="eab7c-186">The transport is WebSockets, forever frame, or server-sent events.</span></span>
- <span data-ttu-id="eab7c-187">Existují různé doby přerušení připojení k fyzické síti.</span><span class="sxs-lookup"><span data-stu-id="eab7c-187">There are varying periods of interruption in the physical network connection.</span></span>
- <span data-ttu-id="eab7c-188">Přenos rozhraní API se dozvěděli o přerušení, není proto SignalR spoléhá na funkce keepalive vyhledáním.</span><span class="sxs-lookup"><span data-stu-id="eab7c-188">The transport API does not become aware of the interruptions, so SignalR relies on the keepalive functionality to detect them.</span></span>

![Odpojení přenosu](handling-connection-lifetime-events/_static/image2.png)

<span data-ttu-id="eab7c-190">Pokud klient přejde do režimu opětovné připojení, ale nemůže navázat připojení přenosu v časovém limitu odpojení, server ukončí připojení SignalR.</span><span class="sxs-lookup"><span data-stu-id="eab7c-190">If the client goes into reconnecting mode but can't establish a transport connection within the disconnect timeout limit, the server terminates the SignalR connection.</span></span> <span data-ttu-id="eab7c-191">Pokud k tomu dojde, spustí na serveru centra `OnDisconnected` metoda a fronty si zprávu o odpojení k odeslání do klienta v případě, že klient spravuje připojení později.</span><span class="sxs-lookup"><span data-stu-id="eab7c-191">When that happens, the server executes the Hub's `OnDisconnected` method and queues up a disconnect message to send to the client in case the client manages to connect later.</span></span> <span data-ttu-id="eab7c-192">Pokud klient znovu připojit, přijme příkaz pro odpojení a volání `Stop` metody.</span><span class="sxs-lookup"><span data-stu-id="eab7c-192">If the client then does reconnect, it receives the disconnect command and calls the `Stop` method.</span></span> <span data-ttu-id="eab7c-193">V tomto scénáři `OnReconnected` není spuštěn, když se klient znovu připojí, a `OnDisconnected` není spuštěn, když klient volá `Stop`.</span><span class="sxs-lookup"><span data-stu-id="eab7c-193">In this scenario, `OnReconnected` is not executed when the client reconnects, and `OnDisconnected` is not executed when the client calls `Stop`.</span></span> <span data-ttu-id="eab7c-194">Následující diagram znázorňuje tento scénář.</span><span class="sxs-lookup"><span data-stu-id="eab7c-194">The following diagram illustrates this scenario.</span></span>

![Narušení přenosu – časový limit serveru](handling-connection-lifetime-events/_static/image3.png)

<span data-ttu-id="eab7c-196">Události doby života připojení SignalR, které mohou být vyvolány na straně klienta jsou následující:</span><span class="sxs-lookup"><span data-stu-id="eab7c-196">The SignalR connection lifetime events that may be raised on the client are the following:</span></span>

- <span data-ttu-id="eab7c-197">`ConnectionSlow` událost klienta.</span><span class="sxs-lookup"><span data-stu-id="eab7c-197">`ConnectionSlow` client event.</span></span>

    <span data-ttu-id="eab7c-198">Vyvolá se při přednastavených podíl keepalive časový limit uplynul od poslední zprávu nebo keepalive ping byla přijata.</span><span class="sxs-lookup"><span data-stu-id="eab7c-198">Raised when a preset proportion of the keepalive timeout period has passed since the last message or keepalive ping was received.</span></span> <span data-ttu-id="eab7c-199">Keepalive výchozího časového limitu upozornění je 2/3 keepalive vypršení časového limitu.</span><span class="sxs-lookup"><span data-stu-id="eab7c-199">The default keepalive timeout warning period is 2/3 of the keepalive timeout.</span></span> <span data-ttu-id="eab7c-200">Časový limit keepalive je 20 sekund, takže dojde k upozornění na přibližně 13 sekund.</span><span class="sxs-lookup"><span data-stu-id="eab7c-200">The keepalive timeout is 20 seconds, so the warning occurs at about 13 seconds.</span></span>

    <span data-ttu-id="eab7c-201">Ve výchozím nastavení odešle server keepalive příkazy ping pro zjištění každých 10 sekund a klient vyhledává příkazy ping keepalive o každé 2 sekundy (jednu třetinu rozdíl mezi keepalive hodnotu časového limitu a hodnotu keepalive časový limit upozornění).</span><span class="sxs-lookup"><span data-stu-id="eab7c-201">By default, the server sends keepalive pings every 10 seconds, and the client checks for keepalive pings about every 2 seconds (one third of the difference between the keepalive timeout value and the keepalive timeout warning value).</span></span>

    <span data-ttu-id="eab7c-202">Pokud obdrží informace o odpojení přenosu rozhraní API, SignalR může být informováni o odpojení předtím, než časový limit upozornění keepalive předá.</span><span class="sxs-lookup"><span data-stu-id="eab7c-202">If the transport API becomes aware of a disconnection, SignalR might be informed of the disconnection before the keepalive timeout warning period passes.</span></span> <span data-ttu-id="eab7c-203">V takovém případě `ConnectionSlow` nebude vyvolána událost a SignalR přejde přímo na `Reconnecting` událostí.</span><span class="sxs-lookup"><span data-stu-id="eab7c-203">In that case, the `ConnectionSlow` event would not be raised, and SignalR would go directly to the `Reconnecting` event.</span></span>
- <span data-ttu-id="eab7c-204">`Reconnecting` událost klienta.</span><span class="sxs-lookup"><span data-stu-id="eab7c-204">`Reconnecting` client event.</span></span>

    <span data-ttu-id="eab7c-205">Vyvoláno, když (a) přenos rozhraní API zjistí, že dojde ke ztrátě nebo připojení nebo (b) keepalive časový limit uplynul od poslední zprávu nebo keepalive ping byla přijata.</span><span class="sxs-lookup"><span data-stu-id="eab7c-205">Raised when (a) the transport API detects that the connection is lost, or (b) the keepalive timeout period has passed since the last message or keepalive ping was received.</span></span> <span data-ttu-id="eab7c-206">Kód klienta SignalR se pokusí znovu připojit.</span><span class="sxs-lookup"><span data-stu-id="eab7c-206">The SignalR client code begins trying to reconnect.</span></span> <span data-ttu-id="eab7c-207">Tato událost může zpracovat, pokud má vaše aplikace provést některé akce, když dojde ke ztrátě připojení přenosu.</span><span class="sxs-lookup"><span data-stu-id="eab7c-207">You can handle this event if you want your application to take some action when a transport connection is lost.</span></span> <span data-ttu-id="eab7c-208">Keepalive výchozího časového limitu je momentálně 20 sekund.</span><span class="sxs-lookup"><span data-stu-id="eab7c-208">The default keepalive timeout period is currently 20 seconds.</span></span>

    <span data-ttu-id="eab7c-209">Pokud váš klientský kód se pokusí o volání metody rozbočovače SignalR je v režimu připojení, se pokusí odeslat příkaz SignalR.</span><span class="sxs-lookup"><span data-stu-id="eab7c-209">If your client code tries to call a Hub method while SignalR is in reconnecting mode, SignalR will try to send the command.</span></span> <span data-ttu-id="eab7c-210">Ve většině případů, těchto pokusů selže, ale v některých případech může být úspěšné.</span><span class="sxs-lookup"><span data-stu-id="eab7c-210">Most of the time, such attempts will fail, but in some circumstances they might succeed.</span></span> <span data-ttu-id="eab7c-211">Funkce SignalR pro události odeslané serverem, navždy rámce a dlouho dotazování přenosy, používá dva komunikační kanály, které klient používá k odesílání zpráv a ten, který se používá pro příjem zpráv.</span><span class="sxs-lookup"><span data-stu-id="eab7c-211">For the server-sent events, forever frame, and long polling transports, SignalR uses two communication channels, one that the client uses to send messages and one that it uses to receive messages.</span></span> <span data-ttu-id="eab7c-212">Kanál, který slouží k příjmu je trvale otevřete jednu, a to je ten, který je uzavřen, když dojde k přerušení připojení k fyzické.</span><span class="sxs-lookup"><span data-stu-id="eab7c-212">The channel used for receiving is the permanently open one, and that's the one that is closed when the physical connection is interrupted.</span></span> <span data-ttu-id="eab7c-213">Kanál používá k odeslání zůstane k dispozici, takže pokud fyzické připojení se obnoví, volání metody z klienta na server může být úspěšné, než kanál receive je obnoveno.</span><span class="sxs-lookup"><span data-stu-id="eab7c-213">The channel used for sending remains available, so if physical connectivity is restored, a method call from client to server might be successful before the receive channel is re-established.</span></span> <span data-ttu-id="eab7c-214">Návratová hodnota nemusí přijmout, dokud SignalR znovu otevře kanál pro příjem.</span><span class="sxs-lookup"><span data-stu-id="eab7c-214">The return value would not be received until SignalR re-opens the channel used for receiving.</span></span>
- <span data-ttu-id="eab7c-215">`Reconnected` událost klienta.</span><span class="sxs-lookup"><span data-stu-id="eab7c-215">`Reconnected` client event.</span></span>

    <span data-ttu-id="eab7c-216">Vyvoláno, když se obnoví připojení přenosu.</span><span class="sxs-lookup"><span data-stu-id="eab7c-216">Raised when the transport connection is reestablished.</span></span> <span data-ttu-id="eab7c-217">`OnReconnected` Spustí obslužnou rutinu události v centru.</span><span class="sxs-lookup"><span data-stu-id="eab7c-217">The `OnReconnected` event handler in the Hub executes.</span></span>
- <span data-ttu-id="eab7c-218">`Closed` událost klienta (`disconnected` událostí v jazyce JavaScript).</span><span class="sxs-lookup"><span data-stu-id="eab7c-218">`Closed` client event (`disconnected` event in JavaScript).</span></span>

    <span data-ttu-id="eab7c-219">Vyvolá se při vypršení časového limitu odpojit, zatímco při pokusu o opětovné připojení po ztrátě připojení přenosu je v kódu klienta SignalR.</span><span class="sxs-lookup"><span data-stu-id="eab7c-219">Raised when the disconnect timeout period expires while the SignalR client code is trying to reconnect after losing the transport connection.</span></span> <span data-ttu-id="eab7c-220">Odpojit výchozí časový limit je 30 sekund.</span><span class="sxs-lookup"><span data-stu-id="eab7c-220">The default disconnect timeout is 30 seconds.</span></span> <span data-ttu-id="eab7c-221">(Tato událost je aktivována také při připojení skončí kvůli tomu, `Stop` metoda je volána.)</span><span class="sxs-lookup"><span data-stu-id="eab7c-221">(This event is also raised when the connection ends because the `Stop` method is called.)</span></span>

<span data-ttu-id="eab7c-222">Události doby života zapříčinil nemusí jakékoli připojení, způsobit přerušení připojení přenosu, které nejsou zjištěny Transport rozhraní API a příjmu keepalive odesílání příkazu ping ze serveru po dobu delší než časový limit upozornění keepalive není zpoždění.</span><span class="sxs-lookup"><span data-stu-id="eab7c-222">Transport connection interruptions that are not detected by the transport API and don't delay the reception of keepalive pings from the server for longer than the keepalive timeout warning period might not cause any connection lifetime events to be raised.</span></span>

<span data-ttu-id="eab7c-223">Některá síťová prostředí záměrně nečinných připojení po zavření a jiné funkce keepalive paketů je Zabraňte to tak, že se tyto sítě vědět, že připojení SignalR je používán.</span><span class="sxs-lookup"><span data-stu-id="eab7c-223">Some network environments deliberately close idle connections, and another function of the keepalive packets is to help prevent this by letting these networks know that a SignalR connection is in use.</span></span> <span data-ttu-id="eab7c-224">V extrémních případech nemusí být výchozí frekvence odesílání příkazu ping keepalive dostatečná ochrana proti uzavřené připojení.</span><span class="sxs-lookup"><span data-stu-id="eab7c-224">In extreme cases the default frequency of keepalive pings might not be enough to prevent closed connections.</span></span> <span data-ttu-id="eab7c-225">V takovém případě můžete nakonfigurovat odesílání příkazu ping keepalive do odešlou častěji.</span><span class="sxs-lookup"><span data-stu-id="eab7c-225">In that case you can configure keepalive pings to be sent more often.</span></span> <span data-ttu-id="eab7c-226">Další informace najdete v tématu [nastavení časového limitu a keepalive](#timeoutkeepalive) dále v tomto tématu.</span><span class="sxs-lookup"><span data-stu-id="eab7c-226">For more information, see [Timeout and keepalive settings](#timeoutkeepalive) later in this topic.</span></span>

> [!NOTE] 
> 
> <span data-ttu-id="eab7c-227">**Důležité**: posloupnost událostí, je zde popsáno, není zaručeno.</span><span class="sxs-lookup"><span data-stu-id="eab7c-227">**Important**: The sequence of events described here is not guaranteed.</span></span> <span data-ttu-id="eab7c-228">SignalR je každý pokus o vyvolání událostí doby platnosti v předvídatelné podle tohoto schématu, ale existuje mnoho variant událostí sítě a mnoha způsoby, ve kterých je zpracovávat základní architektury komunikace, jako jsou přenosu rozhraní API.</span><span class="sxs-lookup"><span data-stu-id="eab7c-228">SignalR makes every attempt to raise connection lifetime events in a predictable manner according to this scheme, but there are many variations of network events and many ways in which underlying communications frameworks such as transport APIs handle them.</span></span> <span data-ttu-id="eab7c-229">Například `Reconnected` událost nemusí být vyvolána, když klient znovu připojí, nebo `OnConnected` obslužnou rutinu na serveru může spustit, když neúspěšný pokus o navázání připojení.</span><span class="sxs-lookup"><span data-stu-id="eab7c-229">For example, the `Reconnected` event might not be raised when the client reconnects, or the `OnConnected` handler on the server might run when the attempt to establish a connection is unsuccessful.</span></span> <span data-ttu-id="eab7c-230">Toto téma popisuje pouze efekty, které by bylo vytvořeno obvykle některé obvyklé okolnosti.</span><span class="sxs-lookup"><span data-stu-id="eab7c-230">This topic describes only the effects that would normally be produced by certain typical circumstances.</span></span>


<a id="clientdisconnect"></a>

### <a name="client-disconnection-scenarios"></a><span data-ttu-id="eab7c-231">Scénáře odpojení klienta</span><span class="sxs-lookup"><span data-stu-id="eab7c-231">Client disconnection scenarios</span></span>

<span data-ttu-id="eab7c-232">V prohlížeči klientovi kód klienta SignalR, která udržuje připojení SignalR běží v kontextu JavaScript webové stránky.</span><span class="sxs-lookup"><span data-stu-id="eab7c-232">In a browser client, the SignalR client code that maintains a SignalR connection runs in the JavaScript context of a web page.</span></span> <span data-ttu-id="eab7c-233">Který má proto musíme ukončit, pokud přejdete z jednoho připojení SignalR stránce do jiného a že je proč máte víc připojení s ID více připojení Pokud se připojujete z více okna prohlížeče nebo karty.</span><span class="sxs-lookup"><span data-stu-id="eab7c-233">That's why the SignalR connection has to end when you navigate from one page to another, and that's why you have multiple connections with multiple connection IDs if you connect from multiple browser windows or tabs.</span></span> <span data-ttu-id="eab7c-234">Když uživatel zavře okně nebo záložce prohlížeče, nebo přejde na novou stránku nebo aktualizuje stránku, připojení SignalR okamžitě ukončí, protože kód klienta SignalR zpracovává tento prohlížeč událostí a volání `Stop` metody.</span><span class="sxs-lookup"><span data-stu-id="eab7c-234">When the user closes a browser window or tab, or navigates to a new page or refreshes the page, the SignalR connection immediately ends because SignalR client code handles that browser event for you and calls the `Stop` method.</span></span> <span data-ttu-id="eab7c-235">V těchto scénářích platí, nebo všechny klientské platformy, když vaše aplikace volá `Stop` metody, `OnDisconnected` obslužná rutina události okamžitě spustí na serveru a klienta vyvolá `Closed` události (událost jmenuje `disconnected` v Jazyk JavaScript).</span><span class="sxs-lookup"><span data-stu-id="eab7c-235">In these scenarios, or in any client platform when your application calls the `Stop` method, the `OnDisconnected` event handler executes immediately on the server and the client raises the `Closed` event (the event is named `disconnected` in JavaScript).</span></span>

<span data-ttu-id="eab7c-236">Pokud klientská aplikace nebo počítač, který je spuštěn na dojde k chybě nebo přejde do režimu spánku (například když uživatel zavírá přenosný počítač), server není informována o co se stalo.</span><span class="sxs-lookup"><span data-stu-id="eab7c-236">If a client application or the computer that it's running on crashes or goes to sleep (for example, when the user closes the laptop), the server is not informed about what happened.</span></span> <span data-ttu-id="eab7c-237">Nejdál, co ví, server, ke ztrátě klienta může být z důvodu přerušení připojení a klient může být pokus o opětovné připojení.</span><span class="sxs-lookup"><span data-stu-id="eab7c-237">As far as the server knows, the loss of the client might be due to connectivity interruption and the client might be trying to reconnect.</span></span> <span data-ttu-id="eab7c-238">Proto v těchto scénářích server čeká, chcete dát klientům příležitost dobře se znovu připojit a `OnDisconnected` nespustí až do vypršení časového limitu odpojení (přibližně 30 sekund ve výchozím nastavení).</span><span class="sxs-lookup"><span data-stu-id="eab7c-238">Therefore, in these scenarios the server waits to give the client a chance to reconnect, and `OnDisconnected` does not execute until the disconnect timeout period expires (about 30 seconds by default).</span></span> <span data-ttu-id="eab7c-239">Následující diagram znázorňuje tento scénář.</span><span class="sxs-lookup"><span data-stu-id="eab7c-239">The following diagram illustrates this scenario.</span></span>

![Chyba klientského počítače](handling-connection-lifetime-events/_static/image4.png)

<a id="serverdisconnect"></a>

### <a name="server-disconnection-scenarios"></a><span data-ttu-id="eab7c-241">Scénáře odpojení serveru</span><span class="sxs-lookup"><span data-stu-id="eab7c-241">Server disconnection scenarios</span></span>

<span data-ttu-id="eab7c-242">Když server přejde do režimu offline--restartování, selže, doména aplikace recykluje, atd. – může být výsledek podobný došlo ke ztrátě připojení nebo přenosu rozhraní API a technologie SignalR možné, že okamžitě, že server je pryč a SignalR můžou začít vyskytovat, pokus o opětovné připojení bez Vyčkat `ConnectionSlow` událostí.</span><span class="sxs-lookup"><span data-stu-id="eab7c-242">When a server goes offline -- it reboots, fails, the app domain recycles, etc. -- the result might be similar to a lost connection, or the transport API and SignalR might know immediately that the server is gone, and SignalR might begin trying to reconnect without raising the `ConnectionSlow` event.</span></span> <span data-ttu-id="eab7c-243">Pokud klient přejde do režimu opětovné připojení a obnoví server nebo restartování nebo nový server je převeden do stavu online předtím, než vyprší časový limit odpojit, klient se znovu připojit k obnovené nebo nový server.</span><span class="sxs-lookup"><span data-stu-id="eab7c-243">If the client goes into reconnecting mode, and if the server recovers or restarts or a new server is brought online before the disconnect timeout period expires, the client will reconnect to the restored or new server.</span></span> <span data-ttu-id="eab7c-244">V takovém případě bude pokračovat připojení SignalR na straně klienta a `Reconnected` událost se vyvolá.</span><span class="sxs-lookup"><span data-stu-id="eab7c-244">In that case, the SignalR connection continues on the client and the `Reconnected` event is raised.</span></span> <span data-ttu-id="eab7c-245">Na prvním serveru `OnDisconnected` není nikdy proveden a na novém serveru `OnReconnected` provádí, i když `OnConnected` byla pro tohoto klienta na tomto serveru před nikdy proveden.</span><span class="sxs-lookup"><span data-stu-id="eab7c-245">On the first server, `OnDisconnected` is never executed, and on the new server, `OnReconnected` is executed although `OnConnected` was never executed for that client on that server before.</span></span> <span data-ttu-id="eab7c-246">(Efekt je, že stejné, pokud klient znovu připojí ke stejnému serveru po recyklaci domény restartování nebo aplikace, protože při jeho restartování serveru nemá žádné paměti aktivita předchozí připojení). Následující diagram se předpokládá, že přenos rozhraní API zjistí došlo ke ztrátě připojení okamžitě, takže `ConnectionSlow` není vyvolána událost.</span><span class="sxs-lookup"><span data-stu-id="eab7c-246">(The effect is the same if the client reconnects to the same server after a reboot or app domain recycle, because when the server restarts it has no memory of prior connection activity.) The following diagram assumes that the transport API becomes aware of the lost connection immediately, so the `ConnectionSlow` event is not raised.</span></span>

![Selhání serveru a opětovném připojení](handling-connection-lifetime-events/_static/image5.png)

<span data-ttu-id="eab7c-248">Pokud server není k dispozici v rámci časového limitu odpojení, ukončí připojení SignalR.</span><span class="sxs-lookup"><span data-stu-id="eab7c-248">If a server does not become available within the disconnect timeout period, the SignalR connection ends.</span></span> <span data-ttu-id="eab7c-249">V tomto scénáři `Closed` událostí (`disconnected` klientům JavaScript) je vyvolána na straně klienta, ale `OnDisconnected` nebude nikdy volána na serveru.</span><span class="sxs-lookup"><span data-stu-id="eab7c-249">In this scenario, the `Closed` event (`disconnected` in JavaScript clients) is raised on the client but `OnDisconnected` is never called on the server.</span></span> <span data-ttu-id="eab7c-250">Následující diagram se předpokládá, že přenos rozhraní API nebudou vědět, došlo ke ztrátě připojení, tak zjistí funkce keepalive SignalR a `ConnectionSlow` událost se vyvolá.</span><span class="sxs-lookup"><span data-stu-id="eab7c-250">The following diagram assumes that the transport API does not become aware of the lost connection, so it is detected by SignalR keepalive functionality and the `ConnectionSlow` event is raised.</span></span>

![Selhání serveru a vypršení časového limitu](handling-connection-lifetime-events/_static/image6.png)

<a id="timeoutkeepalive"></a>

## <a name="timeout-and-keepalive-settings"></a><span data-ttu-id="eab7c-252">Nastavení časového limitu a keepalive</span><span class="sxs-lookup"><span data-stu-id="eab7c-252">Timeout and keepalive settings</span></span>

<span data-ttu-id="eab7c-253">Výchozí hodnota `ConnectionTimeout`, `DisconnectTimeout`, a `KeepAlive` hodnoty jsou vhodné pro většinu scénářů, ale může změnit, pokud vaše prostředí se zvláštními potřebami.</span><span class="sxs-lookup"><span data-stu-id="eab7c-253">The default `ConnectionTimeout`, `DisconnectTimeout`, and `KeepAlive` values are appropriate for most scenarios but can be changed if your environment has special needs.</span></span> <span data-ttu-id="eab7c-254">Pokud vaše síťové prostředí zavře připojení, které jsou nečinné po dobu 5 sekund, budete muset snížit hodnotu keepalive.</span><span class="sxs-lookup"><span data-stu-id="eab7c-254">For example, if your network environment closes connections that are idle for 5 seconds, you might have to decrease the keepalive value.</span></span>

<a id="connectiontimeout"></a>

### <a name="connectiontimeout"></a><span data-ttu-id="eab7c-255">Hodnota ConnectionTimeout</span><span class="sxs-lookup"><span data-stu-id="eab7c-255">ConnectionTimeout</span></span>

<span data-ttu-id="eab7c-256">Toto nastavení představuje dobu má připojení přenosu zůstat otevřené a čeká na odpověď před zavřením a otevřením nové připojení.</span><span class="sxs-lookup"><span data-stu-id="eab7c-256">This setting represents the amount of time to leave a transport connection open and waiting for a response before closing it and opening a new connection.</span></span> <span data-ttu-id="eab7c-257">Výchozí hodnota je 110 sekund.</span><span class="sxs-lookup"><span data-stu-id="eab7c-257">The default value is 110 seconds.</span></span>

<span data-ttu-id="eab7c-258">Toto nastavení platí, pouze když funkce keepalive je zakázáno, což obvykle platí jenom pro long dotazování přenosu.</span><span class="sxs-lookup"><span data-stu-id="eab7c-258">This setting applies only when keepalive functionality is disabled, which normally applies only to the long polling transport.</span></span> <span data-ttu-id="eab7c-259">Následující diagram ukazuje účinek tohoto nastavení na dlouho dotazování připojení přenosu.</span><span class="sxs-lookup"><span data-stu-id="eab7c-259">The following diagram illustrates the effect of this setting on a long polling transport connection.</span></span>

![Dlouhé dotazování připojení pro přenos](handling-connection-lifetime-events/_static/image7.png)

<a id="disconnecttimeout"></a>

### <a name="disconnecttimeout"></a><span data-ttu-id="eab7c-261">DisconnectTimeout</span><span class="sxs-lookup"><span data-stu-id="eab7c-261">DisconnectTimeout</span></span>

<span data-ttu-id="eab7c-262">Toto nastavení představuje dobu čekání po připojení přenosu dojde ke ztrátě vyčkat, než se `Disconnected` událostí.</span><span class="sxs-lookup"><span data-stu-id="eab7c-262">This setting represents the amount of time to wait after a transport connection is lost before raising the `Disconnected` event.</span></span> <span data-ttu-id="eab7c-263">Výchozí hodnota je 30 sekund.</span><span class="sxs-lookup"><span data-stu-id="eab7c-263">The default value is 30 seconds.</span></span> <span data-ttu-id="eab7c-264">Pokud nastavíte `DisconnectTimeout`, `KeepAlive` se automaticky nastaví na 1/3 `DisconnectTimeout` hodnotu.</span><span class="sxs-lookup"><span data-stu-id="eab7c-264">When you set `DisconnectTimeout`, `KeepAlive` is automatically set to 1/3 of the `DisconnectTimeout` value.</span></span>

<a id="keepalive"></a>

### <a name="keepalive"></a><span data-ttu-id="eab7c-265">KeepAlive</span><span class="sxs-lookup"><span data-stu-id="eab7c-265">KeepAlive</span></span>

<span data-ttu-id="eab7c-266">Toto nastavení představuje dobu čekání před odesláním paketu keepalive přes nečinné připojení.</span><span class="sxs-lookup"><span data-stu-id="eab7c-266">This setting represents the amount of time to wait before sending a keepalive packet over an idle connection.</span></span> <span data-ttu-id="eab7c-267">Výchozí hodnota je 10 sekund.</span><span class="sxs-lookup"><span data-stu-id="eab7c-267">The default value is 10 seconds.</span></span> <span data-ttu-id="eab7c-268">Tato hodnota nesmí být více než 1/3 `DisconnectTimeout` hodnotu.</span><span class="sxs-lookup"><span data-stu-id="eab7c-268">This value must not be more than 1/3 of the `DisconnectTimeout` value.</span></span>

<span data-ttu-id="eab7c-269">Pokud chcete nastavit i `DisconnectTimeout` a `KeepAlive`, nastavte `KeepAlive` po `DisconnectTimeout`.</span><span class="sxs-lookup"><span data-stu-id="eab7c-269">If you want to set both `DisconnectTimeout` and `KeepAlive`, set `KeepAlive` after `DisconnectTimeout`.</span></span> <span data-ttu-id="eab7c-270">Jinak vaše `KeepAlive` nastavení se přepíšou, když `DisconnectTimeout` automaticky nastaví `KeepAlive` 1/3 hodnota časového limitu.</span><span class="sxs-lookup"><span data-stu-id="eab7c-270">Otherwise your `KeepAlive` setting will be overwritten when `DisconnectTimeout` automatically sets `KeepAlive` to 1/3 of the timeout value.</span></span>

<span data-ttu-id="eab7c-271">Pokud chcete zakázat funkce keepalive, nastavte `KeepAlive` na hodnotu null.</span><span class="sxs-lookup"><span data-stu-id="eab7c-271">If you want to disable keepalive functionality, set `KeepAlive` to null.</span></span> <span data-ttu-id="eab7c-272">Automaticky se vypne funkce Keepalive dlouhou dobu přenosu cyklického dotazování.</span><span class="sxs-lookup"><span data-stu-id="eab7c-272">Keepalive functionality is automatically disabled for the long polling transport.</span></span>

<a id="changetimeout"></a>

### <a name="how-to-change-timeout-and-keepalive-settings"></a><span data-ttu-id="eab7c-273">Jak změnit nastavení časového limitu a keepalive</span><span class="sxs-lookup"><span data-stu-id="eab7c-273">How to change timeout and keepalive settings</span></span>

<span data-ttu-id="eab7c-274">Chcete-li změnit výchozí hodnoty pro tato nastavení, je nastavit `Application_Start` ve vašich *Global.asax* souboru, jak je znázorněno v následujícím příkladu.</span><span class="sxs-lookup"><span data-stu-id="eab7c-274">To change the default values for these settings, set them in `Application_Start` in your *Global.asax* file, as shown in the following example.</span></span> <span data-ttu-id="eab7c-275">Hodnoty uvedené ve vzorovém kódu jsou stejné jako výchozí hodnoty.</span><span class="sxs-lookup"><span data-stu-id="eab7c-275">The values shown in the sample code are the same as the default values.</span></span>

[!code-csharp[Main](handling-connection-lifetime-events/samples/sample1.cs)]

<a id="notifydisconnect"></a>

## <a name="how-to-notify-the-user-about-disconnections"></a><span data-ttu-id="eab7c-276">Jak informovat uživatele o odpojení</span><span class="sxs-lookup"><span data-stu-id="eab7c-276">How to notify the user about disconnections</span></span>

<span data-ttu-id="eab7c-277">V některých aplikacích můžete chtít zobrazit zprávu pro uživatele, když nejsou potíže s připojením k.</span><span class="sxs-lookup"><span data-stu-id="eab7c-277">In some applications you might want to display a message to the user when there are connectivity problems.</span></span> <span data-ttu-id="eab7c-278">Máte několik možností, jak a kdy se má provést.</span><span class="sxs-lookup"><span data-stu-id="eab7c-278">You have several options for how and when to do this.</span></span> <span data-ttu-id="eab7c-279">Následující ukázky kódu jsou pro JavaScript klienta pomocí vygenerovaný proxy server.</span><span class="sxs-lookup"><span data-stu-id="eab7c-279">The following code samples are for a JavaScript client using the generated proxy.</span></span>

- <span data-ttu-id="eab7c-280">Zpracování `connectionSlow` události pro zobrazení zprávy, jakmile SignalR je seznámen problémy s připojením, než přejde do režimu opětovného připojení.</span><span class="sxs-lookup"><span data-stu-id="eab7c-280">Handle the `connectionSlow` event to display a message as soon as SignalR is aware of connection problems, before it goes into reconnecting mode.</span></span>

    [!code-javascript[Main](handling-connection-lifetime-events/samples/sample2.js)]
- <span data-ttu-id="eab7c-281">Zpracování `reconnecting` události a zobrazení zprávy při SignalR ví o odpojení a přechází do režimu opětovného připojení.</span><span class="sxs-lookup"><span data-stu-id="eab7c-281">Handle the `reconnecting` event to display a message when SignalR is aware of a disconnection and is going into reconnecting mode.</span></span>

    [!code-javascript[Main](handling-connection-lifetime-events/samples/sample3.js)]
- <span data-ttu-id="eab7c-282">Zpracování `disconnected` události pro zobrazení zprávy při pokus o opakované připojení k vypršení časového limitu. V tomto scénáři je jediný způsob, jak znovu navázat spojení se serverem znovu restartování připojení SignalR voláním `Start` metodu, která se vytvoří nové ID připojení.</span><span class="sxs-lookup"><span data-stu-id="eab7c-282">Handle the `disconnected` event to display a message when an attempt to reconnect has timed out. In this scenario, the only way to re-establish a connection with the server again is to restart the SignalR connection by calling the `Start` method, which will create a new connection ID.</span></span> <span data-ttu-id="eab7c-283">Následující vzorový kód používá příznak, abyste měli jistotu, že se vydáte oznámení až po opětovně se připojujícího vypršení časového limitu, nikoli za normální ukončení připojení SignalR způsobilo voláním `Stop` metody.</span><span class="sxs-lookup"><span data-stu-id="eab7c-283">The following code sample uses a flag to make sure that you issue the notification only after a reconnecting timeout, not after a normal end to the SignalR connection caused by calling the `Stop` method.</span></span>

    [!code-javascript[Main](handling-connection-lifetime-events/samples/sample4.js)]

<a id="continuousreconnect"></a>

## <a name="how-to-continuously-reconnect"></a><span data-ttu-id="eab7c-284">Průběžně opětovné připojení</span><span class="sxs-lookup"><span data-stu-id="eab7c-284">How to continuously reconnect</span></span>

<span data-ttu-id="eab7c-285">V některých aplikacích můžete automaticky znovu navázat připojení poté, co byl ztracen a pokus o připojení vypršel. K tomuto účelu můžete volat `Start` metodu z vašeho `Closed` obslužné rutiny události (`disconnected` obslužné rutiny události na klientech JavaScript).</span><span class="sxs-lookup"><span data-stu-id="eab7c-285">In some applications you might want to automatically re-establish a connection after it has been lost and the attempt to reconnect has timed out. To do that, you can call the `Start` method from your `Closed` event handler (`disconnected` event handler on JavaScript clients).</span></span> <span data-ttu-id="eab7c-286">Chcete počkat určitou dobu před voláním `Start` předejdete tím příliš často při serveru nebo fyzické připojení nejsou k dispozici.</span><span class="sxs-lookup"><span data-stu-id="eab7c-286">You might want to wait a period of time before calling `Start` in order to avoid doing this too frequently when the server or the physical connection are unavailable.</span></span> <span data-ttu-id="eab7c-287">Následující ukázka kódu je pro JavaScript klienta pomocí vygenerovaný proxy server.</span><span class="sxs-lookup"><span data-stu-id="eab7c-287">The following code sample is for a JavaScript client using the generated proxy.</span></span>

[!code-javascript[Main](handling-connection-lifetime-events/samples/sample5.js)]

<span data-ttu-id="eab7c-288">Možný problém je potřeba vědět v mobilních klientů je, že průběžné nastavitelnou pokusy, kdy server nebo fyzické připojení není k dispozici může způsobit zbytečné baterie vyprazdňování.</span><span class="sxs-lookup"><span data-stu-id="eab7c-288">A potential problem to be aware of in mobile clients is that continuous reconnection attempts when the server or physical connection isn't available could cause unnecessary battery drain.</span></span>

<a id="disconnectclientfromserver"></a>

## <a name="how-to-disconnect-a-client-in-server-code"></a><span data-ttu-id="eab7c-289">Jak odpojení klienta v kódu serveru</span><span class="sxs-lookup"><span data-stu-id="eab7c-289">How to disconnect a client in server code</span></span>

<span data-ttu-id="eab7c-290">Funkce SignalR verze 2 nemá integrovaného serveru rozhraní API pro odpojení klienti.</span><span class="sxs-lookup"><span data-stu-id="eab7c-290">SignalR version 2 does not have a built-in server API for disconnecting clients.</span></span> <span data-ttu-id="eab7c-291">Existují [plány pro přidání této funkce v budoucnu](https://github.com/SignalR/SignalR/issues/2101).</span><span class="sxs-lookup"><span data-stu-id="eab7c-291">There are [plans for adding this functionality in the future](https://github.com/SignalR/SignalR/issues/2101).</span></span> <span data-ttu-id="eab7c-292">V aktuální verzi SignalR je nejjednodušší způsob, jak odpojení klienta od serveru implementovat metodu odpojit na straně klienta a volání metody ze serveru.</span><span class="sxs-lookup"><span data-stu-id="eab7c-292">In the current SignalR release, the simplest way to disconnect a client from the server is to implement a disconnect method on the client and call that method from the server.</span></span> <span data-ttu-id="eab7c-293">Následující příklad kódu ukazuje metodu odpojit pro JavaScript klienta pomocí vygenerovaný proxy server.</span><span class="sxs-lookup"><span data-stu-id="eab7c-293">The following code sample shows a disconnect method for a JavaScript client using the generated proxy.</span></span>

[!code-javascript[Main](handling-connection-lifetime-events/samples/sample6.js)]

> [!WARNING]
> <span data-ttu-id="eab7c-294">Zabezpečení – tuto metodu pro odpojení klienti ani rozhraní API navržených integrované bude zabývat scénář napadené klienty se systémem škodlivý kód, protože klienti mohli znovu připojit nebo může dojít k odebrání napadené kód `stopClient` metodu nebo změňte Co to dělá.</span><span class="sxs-lookup"><span data-stu-id="eab7c-294">Security - Neither this method for disconnecting clients nor the proposed built-in API will address the scenario of hacked clients that are running malicious code, since the clients could reconnect or the hacked code might remove the `stopClient` method or change what it does.</span></span> <span data-ttu-id="eab7c-295">Na příslušné místo k implementaci stavové ochrany s cílem odepření služby (DOS) je v rámci nebo vrstvy serveru, ale v front-endové infrastruktury.</span><span class="sxs-lookup"><span data-stu-id="eab7c-295">The appropriate place to implement stateful denial-of-service (DOS) protection is not in the framework or the server layer, but rather in front-end infrastructure.</span></span>


<a id="detectingreasonfordisconnection"></a>
## <a name="detecting-the-reason-for-a-disconnection"></a><span data-ttu-id="eab7c-296">Zjišťování důvod pro odpojení</span><span class="sxs-lookup"><span data-stu-id="eab7c-296">Detecting the reason for a disconnection</span></span>

<span data-ttu-id="eab7c-297">SignalR 2.1 přidá přetížení k serveru `OnDisconnect` událost označující, pokud úmyslně klient odpojen spíše než vyprší časový limit. `StopCalled` Parametr je hodnota true, pokud klient explicitně uzavřel připojení.</span><span class="sxs-lookup"><span data-stu-id="eab7c-297">SignalR 2.1 adds an overload to the server `OnDisconnect` event that indicates if the client deliberately disconnected rather than timing out. The `StopCalled` parameter is true if the client explicitly closed the connection.</span></span> <span data-ttu-id="eab7c-298">V jazyce JavaScript, je-li k chybě serveru vedla klienta se odpojit, informace o chybě se předají ke klientovi jako `$.connection.hub.lastError`.</span><span class="sxs-lookup"><span data-stu-id="eab7c-298">In JavaScript, if a server error led the client to disconnect, the error information will be passed to the client as `$.connection.hub.lastError`.</span></span>

<span data-ttu-id="eab7c-299">**Server kód jazyka C#: `stopCalled` parametr**</span><span class="sxs-lookup"><span data-stu-id="eab7c-299">**C# server code: `stopCalled` parameter**</span></span>

[!code-csharp[Main](handling-connection-lifetime-events/samples/sample7.cs?highlight=1,3)]

<span data-ttu-id="eab7c-300">**Kód jazyka JavaScript klienta: přístup k `lastError` v `disconnect` událostí.**</span><span class="sxs-lookup"><span data-stu-id="eab7c-300">**JavaScript client code: accessing `lastError` in the `disconnect` event.**</span></span>

[!code-javascript[Main](handling-connection-lifetime-events/samples/sample8.js?highlight=2-3)]
